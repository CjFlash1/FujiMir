
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model PrintSize
 * 
 */
export type PrintSize = $Result.DefaultSelection<Prisma.$PrintSizePayload>
/**
 * Model QuantityTier
 * 
 */
export type QuantityTier = $Result.DefaultSelection<Prisma.$QuantityTierPayload>
/**
 * Model VolumeDiscount
 * 
 */
export type VolumeDiscount = $Result.DefaultSelection<Prisma.$VolumeDiscountPayload>
/**
 * Model GiftThreshold
 * 
 */
export type GiftThreshold = $Result.DefaultSelection<Prisma.$GiftThresholdPayload>
/**
 * Model PaperType
 * 
 */
export type PaperType = $Result.DefaultSelection<Prisma.$PaperTypePayload>
/**
 * Model PrintOption
 * 
 */
export type PrintOption = $Result.DefaultSelection<Prisma.$PrintOptionPayload>
/**
 * Model MagnetPrice
 * 
 */
export type MagnetPrice = $Result.DefaultSelection<Prisma.$MagnetPricePayload>
/**
 * Model DeliveryOption
 * 
 */
export type DeliveryOption = $Result.DefaultSelection<Prisma.$DeliveryOptionPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Translation
 * 
 */
export type Translation = $Result.DefaultSelection<Prisma.$TranslationPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model Page
 * 
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model HelpCategory
 * 
 */
export type HelpCategory = $Result.DefaultSelection<Prisma.$HelpCategoryPayload>
/**
 * Model HelpCategoryTranslation
 * 
 */
export type HelpCategoryTranslation = $Result.DefaultSelection<Prisma.$HelpCategoryTranslationPayload>
/**
 * Model HelpArticle
 * 
 */
export type HelpArticle = $Result.DefaultSelection<Prisma.$HelpArticlePayload>
/**
 * Model HelpArticleTranslation
 * 
 */
export type HelpArticleTranslation = $Result.DefaultSelection<Prisma.$HelpArticleTranslationPayload>
/**
 * Model OrderSequence
 * 
 */
export type OrderSequence = $Result.DefaultSelection<Prisma.$OrderSequencePayload>
/**
 * Model NPSender
 * 
 */
export type NPSender = $Result.DefaultSelection<Prisma.$NPSenderPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.printSize`: Exposes CRUD operations for the **PrintSize** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrintSizes
    * const printSizes = await prisma.printSize.findMany()
    * ```
    */
  get printSize(): Prisma.PrintSizeDelegate<ExtArgs>;

  /**
   * `prisma.quantityTier`: Exposes CRUD operations for the **QuantityTier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuantityTiers
    * const quantityTiers = await prisma.quantityTier.findMany()
    * ```
    */
  get quantityTier(): Prisma.QuantityTierDelegate<ExtArgs>;

  /**
   * `prisma.volumeDiscount`: Exposes CRUD operations for the **VolumeDiscount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VolumeDiscounts
    * const volumeDiscounts = await prisma.volumeDiscount.findMany()
    * ```
    */
  get volumeDiscount(): Prisma.VolumeDiscountDelegate<ExtArgs>;

  /**
   * `prisma.giftThreshold`: Exposes CRUD operations for the **GiftThreshold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GiftThresholds
    * const giftThresholds = await prisma.giftThreshold.findMany()
    * ```
    */
  get giftThreshold(): Prisma.GiftThresholdDelegate<ExtArgs>;

  /**
   * `prisma.paperType`: Exposes CRUD operations for the **PaperType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaperTypes
    * const paperTypes = await prisma.paperType.findMany()
    * ```
    */
  get paperType(): Prisma.PaperTypeDelegate<ExtArgs>;

  /**
   * `prisma.printOption`: Exposes CRUD operations for the **PrintOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrintOptions
    * const printOptions = await prisma.printOption.findMany()
    * ```
    */
  get printOption(): Prisma.PrintOptionDelegate<ExtArgs>;

  /**
   * `prisma.magnetPrice`: Exposes CRUD operations for the **MagnetPrice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MagnetPrices
    * const magnetPrices = await prisma.magnetPrice.findMany()
    * ```
    */
  get magnetPrice(): Prisma.MagnetPriceDelegate<ExtArgs>;

  /**
   * `prisma.deliveryOption`: Exposes CRUD operations for the **DeliveryOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryOptions
    * const deliveryOptions = await prisma.deliveryOption.findMany()
    * ```
    */
  get deliveryOption(): Prisma.DeliveryOptionDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.translation`: Exposes CRUD operations for the **Translation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Translations
    * const translations = await prisma.translation.findMany()
    * ```
    */
  get translation(): Prisma.TranslationDelegate<ExtArgs>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs>;

  /**
   * `prisma.page`: Exposes CRUD operations for the **Page** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.page.findMany()
    * ```
    */
  get page(): Prisma.PageDelegate<ExtArgs>;

  /**
   * `prisma.helpCategory`: Exposes CRUD operations for the **HelpCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpCategories
    * const helpCategories = await prisma.helpCategory.findMany()
    * ```
    */
  get helpCategory(): Prisma.HelpCategoryDelegate<ExtArgs>;

  /**
   * `prisma.helpCategoryTranslation`: Exposes CRUD operations for the **HelpCategoryTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpCategoryTranslations
    * const helpCategoryTranslations = await prisma.helpCategoryTranslation.findMany()
    * ```
    */
  get helpCategoryTranslation(): Prisma.HelpCategoryTranslationDelegate<ExtArgs>;

  /**
   * `prisma.helpArticle`: Exposes CRUD operations for the **HelpArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpArticles
    * const helpArticles = await prisma.helpArticle.findMany()
    * ```
    */
  get helpArticle(): Prisma.HelpArticleDelegate<ExtArgs>;

  /**
   * `prisma.helpArticleTranslation`: Exposes CRUD operations for the **HelpArticleTranslation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HelpArticleTranslations
    * const helpArticleTranslations = await prisma.helpArticleTranslation.findMany()
    * ```
    */
  get helpArticleTranslation(): Prisma.HelpArticleTranslationDelegate<ExtArgs>;

  /**
   * `prisma.orderSequence`: Exposes CRUD operations for the **OrderSequence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderSequences
    * const orderSequences = await prisma.orderSequence.findMany()
    * ```
    */
  get orderSequence(): Prisma.OrderSequenceDelegate<ExtArgs>;

  /**
   * `prisma.nPSender`: Exposes CRUD operations for the **NPSender** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NPSenders
    * const nPSenders = await prisma.nPSender.findMany()
    * ```
    */
  get nPSender(): Prisma.NPSenderDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Order: 'Order',
    OrderItem: 'OrderItem',
    PrintSize: 'PrintSize',
    QuantityTier: 'QuantityTier',
    VolumeDiscount: 'VolumeDiscount',
    GiftThreshold: 'GiftThreshold',
    PaperType: 'PaperType',
    PrintOption: 'PrintOption',
    MagnetPrice: 'MagnetPrice',
    DeliveryOption: 'DeliveryOption',
    Product: 'Product',
    Translation: 'Translation',
    Setting: 'Setting',
    Page: 'Page',
    HelpCategory: 'HelpCategory',
    HelpCategoryTranslation: 'HelpCategoryTranslation',
    HelpArticle: 'HelpArticle',
    HelpArticleTranslation: 'HelpArticleTranslation',
    OrderSequence: 'OrderSequence',
    NPSender: 'NPSender'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "order" | "orderItem" | "printSize" | "quantityTier" | "volumeDiscount" | "giftThreshold" | "paperType" | "printOption" | "magnetPrice" | "deliveryOption" | "product" | "translation" | "setting" | "page" | "helpCategory" | "helpCategoryTranslation" | "helpArticle" | "helpArticleTranslation" | "orderSequence" | "nPSender"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      PrintSize: {
        payload: Prisma.$PrintSizePayload<ExtArgs>
        fields: Prisma.PrintSizeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrintSizeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintSizePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrintSizeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintSizePayload>
          }
          findFirst: {
            args: Prisma.PrintSizeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintSizePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrintSizeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintSizePayload>
          }
          findMany: {
            args: Prisma.PrintSizeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintSizePayload>[]
          }
          create: {
            args: Prisma.PrintSizeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintSizePayload>
          }
          createMany: {
            args: Prisma.PrintSizeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrintSizeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintSizePayload>[]
          }
          delete: {
            args: Prisma.PrintSizeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintSizePayload>
          }
          update: {
            args: Prisma.PrintSizeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintSizePayload>
          }
          deleteMany: {
            args: Prisma.PrintSizeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrintSizeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrintSizeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintSizePayload>
          }
          aggregate: {
            args: Prisma.PrintSizeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrintSize>
          }
          groupBy: {
            args: Prisma.PrintSizeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrintSizeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrintSizeCountArgs<ExtArgs>
            result: $Utils.Optional<PrintSizeCountAggregateOutputType> | number
          }
        }
      }
      QuantityTier: {
        payload: Prisma.$QuantityTierPayload<ExtArgs>
        fields: Prisma.QuantityTierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuantityTierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuantityTierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuantityTierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuantityTierPayload>
          }
          findFirst: {
            args: Prisma.QuantityTierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuantityTierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuantityTierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuantityTierPayload>
          }
          findMany: {
            args: Prisma.QuantityTierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuantityTierPayload>[]
          }
          create: {
            args: Prisma.QuantityTierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuantityTierPayload>
          }
          createMany: {
            args: Prisma.QuantityTierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuantityTierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuantityTierPayload>[]
          }
          delete: {
            args: Prisma.QuantityTierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuantityTierPayload>
          }
          update: {
            args: Prisma.QuantityTierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuantityTierPayload>
          }
          deleteMany: {
            args: Prisma.QuantityTierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuantityTierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuantityTierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuantityTierPayload>
          }
          aggregate: {
            args: Prisma.QuantityTierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuantityTier>
          }
          groupBy: {
            args: Prisma.QuantityTierGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuantityTierGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuantityTierCountArgs<ExtArgs>
            result: $Utils.Optional<QuantityTierCountAggregateOutputType> | number
          }
        }
      }
      VolumeDiscount: {
        payload: Prisma.$VolumeDiscountPayload<ExtArgs>
        fields: Prisma.VolumeDiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VolumeDiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumeDiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VolumeDiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumeDiscountPayload>
          }
          findFirst: {
            args: Prisma.VolumeDiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumeDiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VolumeDiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumeDiscountPayload>
          }
          findMany: {
            args: Prisma.VolumeDiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumeDiscountPayload>[]
          }
          create: {
            args: Prisma.VolumeDiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumeDiscountPayload>
          }
          createMany: {
            args: Prisma.VolumeDiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VolumeDiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumeDiscountPayload>[]
          }
          delete: {
            args: Prisma.VolumeDiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumeDiscountPayload>
          }
          update: {
            args: Prisma.VolumeDiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumeDiscountPayload>
          }
          deleteMany: {
            args: Prisma.VolumeDiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VolumeDiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VolumeDiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VolumeDiscountPayload>
          }
          aggregate: {
            args: Prisma.VolumeDiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVolumeDiscount>
          }
          groupBy: {
            args: Prisma.VolumeDiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<VolumeDiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.VolumeDiscountCountArgs<ExtArgs>
            result: $Utils.Optional<VolumeDiscountCountAggregateOutputType> | number
          }
        }
      }
      GiftThreshold: {
        payload: Prisma.$GiftThresholdPayload<ExtArgs>
        fields: Prisma.GiftThresholdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GiftThresholdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftThresholdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GiftThresholdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftThresholdPayload>
          }
          findFirst: {
            args: Prisma.GiftThresholdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftThresholdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GiftThresholdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftThresholdPayload>
          }
          findMany: {
            args: Prisma.GiftThresholdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftThresholdPayload>[]
          }
          create: {
            args: Prisma.GiftThresholdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftThresholdPayload>
          }
          createMany: {
            args: Prisma.GiftThresholdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GiftThresholdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftThresholdPayload>[]
          }
          delete: {
            args: Prisma.GiftThresholdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftThresholdPayload>
          }
          update: {
            args: Prisma.GiftThresholdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftThresholdPayload>
          }
          deleteMany: {
            args: Prisma.GiftThresholdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GiftThresholdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GiftThresholdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftThresholdPayload>
          }
          aggregate: {
            args: Prisma.GiftThresholdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGiftThreshold>
          }
          groupBy: {
            args: Prisma.GiftThresholdGroupByArgs<ExtArgs>
            result: $Utils.Optional<GiftThresholdGroupByOutputType>[]
          }
          count: {
            args: Prisma.GiftThresholdCountArgs<ExtArgs>
            result: $Utils.Optional<GiftThresholdCountAggregateOutputType> | number
          }
        }
      }
      PaperType: {
        payload: Prisma.$PaperTypePayload<ExtArgs>
        fields: Prisma.PaperTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaperTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaperTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperTypePayload>
          }
          findFirst: {
            args: Prisma.PaperTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaperTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperTypePayload>
          }
          findMany: {
            args: Prisma.PaperTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperTypePayload>[]
          }
          create: {
            args: Prisma.PaperTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperTypePayload>
          }
          createMany: {
            args: Prisma.PaperTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaperTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperTypePayload>[]
          }
          delete: {
            args: Prisma.PaperTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperTypePayload>
          }
          update: {
            args: Prisma.PaperTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperTypePayload>
          }
          deleteMany: {
            args: Prisma.PaperTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaperTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaperTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaperTypePayload>
          }
          aggregate: {
            args: Prisma.PaperTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaperType>
          }
          groupBy: {
            args: Prisma.PaperTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaperTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaperTypeCountArgs<ExtArgs>
            result: $Utils.Optional<PaperTypeCountAggregateOutputType> | number
          }
        }
      }
      PrintOption: {
        payload: Prisma.$PrintOptionPayload<ExtArgs>
        fields: Prisma.PrintOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrintOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrintOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOptionPayload>
          }
          findFirst: {
            args: Prisma.PrintOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrintOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOptionPayload>
          }
          findMany: {
            args: Prisma.PrintOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOptionPayload>[]
          }
          create: {
            args: Prisma.PrintOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOptionPayload>
          }
          createMany: {
            args: Prisma.PrintOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrintOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOptionPayload>[]
          }
          delete: {
            args: Prisma.PrintOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOptionPayload>
          }
          update: {
            args: Prisma.PrintOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOptionPayload>
          }
          deleteMany: {
            args: Prisma.PrintOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrintOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrintOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrintOptionPayload>
          }
          aggregate: {
            args: Prisma.PrintOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrintOption>
          }
          groupBy: {
            args: Prisma.PrintOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrintOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrintOptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrintOptionCountAggregateOutputType> | number
          }
        }
      }
      MagnetPrice: {
        payload: Prisma.$MagnetPricePayload<ExtArgs>
        fields: Prisma.MagnetPriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MagnetPriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagnetPricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MagnetPriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagnetPricePayload>
          }
          findFirst: {
            args: Prisma.MagnetPriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagnetPricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MagnetPriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagnetPricePayload>
          }
          findMany: {
            args: Prisma.MagnetPriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagnetPricePayload>[]
          }
          create: {
            args: Prisma.MagnetPriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagnetPricePayload>
          }
          createMany: {
            args: Prisma.MagnetPriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MagnetPriceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagnetPricePayload>[]
          }
          delete: {
            args: Prisma.MagnetPriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagnetPricePayload>
          }
          update: {
            args: Prisma.MagnetPriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagnetPricePayload>
          }
          deleteMany: {
            args: Prisma.MagnetPriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MagnetPriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MagnetPriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagnetPricePayload>
          }
          aggregate: {
            args: Prisma.MagnetPriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMagnetPrice>
          }
          groupBy: {
            args: Prisma.MagnetPriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MagnetPriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MagnetPriceCountArgs<ExtArgs>
            result: $Utils.Optional<MagnetPriceCountAggregateOutputType> | number
          }
        }
      }
      DeliveryOption: {
        payload: Prisma.$DeliveryOptionPayload<ExtArgs>
        fields: Prisma.DeliveryOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryOptionPayload>
          }
          findFirst: {
            args: Prisma.DeliveryOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryOptionPayload>
          }
          findMany: {
            args: Prisma.DeliveryOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryOptionPayload>[]
          }
          create: {
            args: Prisma.DeliveryOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryOptionPayload>
          }
          createMany: {
            args: Prisma.DeliveryOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryOptionPayload>[]
          }
          delete: {
            args: Prisma.DeliveryOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryOptionPayload>
          }
          update: {
            args: Prisma.DeliveryOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryOptionPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryOptionPayload>
          }
          aggregate: {
            args: Prisma.DeliveryOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryOption>
          }
          groupBy: {
            args: Prisma.DeliveryOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryOptionCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryOptionCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Translation: {
        payload: Prisma.$TranslationPayload<ExtArgs>
        fields: Prisma.TranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          findFirst: {
            args: Prisma.TranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          findMany: {
            args: Prisma.TranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>[]
          }
          create: {
            args: Prisma.TranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          createMany: {
            args: Prisma.TranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>[]
          }
          delete: {
            args: Prisma.TranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          update: {
            args: Prisma.TranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          deleteMany: {
            args: Prisma.TranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TranslationPayload>
          }
          aggregate: {
            args: Prisma.TranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTranslation>
          }
          groupBy: {
            args: Prisma.TranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TranslationCountArgs<ExtArgs>
            result: $Utils.Optional<TranslationCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      Page: {
        payload: Prisma.$PagePayload<ExtArgs>
        fields: Prisma.PageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findFirst: {
            args: Prisma.PageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findMany: {
            args: Prisma.PageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          create: {
            args: Prisma.PageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          createMany: {
            args: Prisma.PageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          delete: {
            args: Prisma.PageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          update: {
            args: Prisma.PageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          deleteMany: {
            args: Prisma.PageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          aggregate: {
            args: Prisma.PageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePage>
          }
          groupBy: {
            args: Prisma.PageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageCountArgs<ExtArgs>
            result: $Utils.Optional<PageCountAggregateOutputType> | number
          }
        }
      }
      HelpCategory: {
        payload: Prisma.$HelpCategoryPayload<ExtArgs>
        fields: Prisma.HelpCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          findFirst: {
            args: Prisma.HelpCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          findMany: {
            args: Prisma.HelpCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>[]
          }
          create: {
            args: Prisma.HelpCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          createMany: {
            args: Prisma.HelpCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelpCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>[]
          }
          delete: {
            args: Prisma.HelpCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          update: {
            args: Prisma.HelpCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          deleteMany: {
            args: Prisma.HelpCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryPayload>
          }
          aggregate: {
            args: Prisma.HelpCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpCategory>
          }
          groupBy: {
            args: Prisma.HelpCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<HelpCategoryCountAggregateOutputType> | number
          }
        }
      }
      HelpCategoryTranslation: {
        payload: Prisma.$HelpCategoryTranslationPayload<ExtArgs>
        fields: Prisma.HelpCategoryTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpCategoryTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpCategoryTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryTranslationPayload>
          }
          findFirst: {
            args: Prisma.HelpCategoryTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpCategoryTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryTranslationPayload>
          }
          findMany: {
            args: Prisma.HelpCategoryTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryTranslationPayload>[]
          }
          create: {
            args: Prisma.HelpCategoryTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryTranslationPayload>
          }
          createMany: {
            args: Prisma.HelpCategoryTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelpCategoryTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryTranslationPayload>[]
          }
          delete: {
            args: Prisma.HelpCategoryTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryTranslationPayload>
          }
          update: {
            args: Prisma.HelpCategoryTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryTranslationPayload>
          }
          deleteMany: {
            args: Prisma.HelpCategoryTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpCategoryTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpCategoryTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpCategoryTranslationPayload>
          }
          aggregate: {
            args: Prisma.HelpCategoryTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpCategoryTranslation>
          }
          groupBy: {
            args: Prisma.HelpCategoryTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpCategoryTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpCategoryTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<HelpCategoryTranslationCountAggregateOutputType> | number
          }
        }
      }
      HelpArticle: {
        payload: Prisma.$HelpArticlePayload<ExtArgs>
        fields: Prisma.HelpArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          findFirst: {
            args: Prisma.HelpArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          findMany: {
            args: Prisma.HelpArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>[]
          }
          create: {
            args: Prisma.HelpArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          createMany: {
            args: Prisma.HelpArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelpArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>[]
          }
          delete: {
            args: Prisma.HelpArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          update: {
            args: Prisma.HelpArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          deleteMany: {
            args: Prisma.HelpArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticlePayload>
          }
          aggregate: {
            args: Prisma.HelpArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpArticle>
          }
          groupBy: {
            args: Prisma.HelpArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpArticleCountArgs<ExtArgs>
            result: $Utils.Optional<HelpArticleCountAggregateOutputType> | number
          }
        }
      }
      HelpArticleTranslation: {
        payload: Prisma.$HelpArticleTranslationPayload<ExtArgs>
        fields: Prisma.HelpArticleTranslationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HelpArticleTranslationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticleTranslationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HelpArticleTranslationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticleTranslationPayload>
          }
          findFirst: {
            args: Prisma.HelpArticleTranslationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticleTranslationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HelpArticleTranslationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticleTranslationPayload>
          }
          findMany: {
            args: Prisma.HelpArticleTranslationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticleTranslationPayload>[]
          }
          create: {
            args: Prisma.HelpArticleTranslationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticleTranslationPayload>
          }
          createMany: {
            args: Prisma.HelpArticleTranslationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HelpArticleTranslationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticleTranslationPayload>[]
          }
          delete: {
            args: Prisma.HelpArticleTranslationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticleTranslationPayload>
          }
          update: {
            args: Prisma.HelpArticleTranslationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticleTranslationPayload>
          }
          deleteMany: {
            args: Prisma.HelpArticleTranslationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HelpArticleTranslationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HelpArticleTranslationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HelpArticleTranslationPayload>
          }
          aggregate: {
            args: Prisma.HelpArticleTranslationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHelpArticleTranslation>
          }
          groupBy: {
            args: Prisma.HelpArticleTranslationGroupByArgs<ExtArgs>
            result: $Utils.Optional<HelpArticleTranslationGroupByOutputType>[]
          }
          count: {
            args: Prisma.HelpArticleTranslationCountArgs<ExtArgs>
            result: $Utils.Optional<HelpArticleTranslationCountAggregateOutputType> | number
          }
        }
      }
      OrderSequence: {
        payload: Prisma.$OrderSequencePayload<ExtArgs>
        fields: Prisma.OrderSequenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderSequenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderSequenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          findFirst: {
            args: Prisma.OrderSequenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderSequenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          findMany: {
            args: Prisma.OrderSequenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>[]
          }
          create: {
            args: Prisma.OrderSequenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          createMany: {
            args: Prisma.OrderSequenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderSequenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>[]
          }
          delete: {
            args: Prisma.OrderSequenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          update: {
            args: Prisma.OrderSequenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          deleteMany: {
            args: Prisma.OrderSequenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderSequenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderSequenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSequencePayload>
          }
          aggregate: {
            args: Prisma.OrderSequenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderSequence>
          }
          groupBy: {
            args: Prisma.OrderSequenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderSequenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderSequenceCountArgs<ExtArgs>
            result: $Utils.Optional<OrderSequenceCountAggregateOutputType> | number
          }
        }
      }
      NPSender: {
        payload: Prisma.$NPSenderPayload<ExtArgs>
        fields: Prisma.NPSenderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NPSenderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPSenderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NPSenderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPSenderPayload>
          }
          findFirst: {
            args: Prisma.NPSenderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPSenderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NPSenderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPSenderPayload>
          }
          findMany: {
            args: Prisma.NPSenderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPSenderPayload>[]
          }
          create: {
            args: Prisma.NPSenderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPSenderPayload>
          }
          createMany: {
            args: Prisma.NPSenderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NPSenderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPSenderPayload>[]
          }
          delete: {
            args: Prisma.NPSenderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPSenderPayload>
          }
          update: {
            args: Prisma.NPSenderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPSenderPayload>
          }
          deleteMany: {
            args: Prisma.NPSenderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NPSenderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NPSenderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPSenderPayload>
          }
          aggregate: {
            args: Prisma.NPSenderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNPSender>
          }
          groupBy: {
            args: Prisma.NPSenderGroupByArgs<ExtArgs>
            result: $Utils.Optional<NPSenderGroupByOutputType>[]
          }
          count: {
            args: Prisma.NPSenderCountArgs<ExtArgs>
            result: $Utils.Optional<NPSenderCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type PrintSizeCountOutputType
   */

  export type PrintSizeCountOutputType = {
    discounts: number
  }

  export type PrintSizeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discounts?: boolean | PrintSizeCountOutputTypeCountDiscountsArgs
  }

  // Custom InputTypes
  /**
   * PrintSizeCountOutputType without action
   */
  export type PrintSizeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSizeCountOutputType
     */
    select?: PrintSizeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrintSizeCountOutputType without action
   */
  export type PrintSizeCountOutputTypeCountDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumeDiscountWhereInput
  }


  /**
   * Count Type QuantityTierCountOutputType
   */

  export type QuantityTierCountOutputType = {
    discounts: number
  }

  export type QuantityTierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discounts?: boolean | QuantityTierCountOutputTypeCountDiscountsArgs
  }

  // Custom InputTypes
  /**
   * QuantityTierCountOutputType without action
   */
  export type QuantityTierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTierCountOutputType
     */
    select?: QuantityTierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuantityTierCountOutputType without action
   */
  export type QuantityTierCountOutputTypeCountDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumeDiscountWhereInput
  }


  /**
   * Count Type HelpCategoryCountOutputType
   */

  export type HelpCategoryCountOutputType = {
    translations: number
    articles: number
  }

  export type HelpCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | HelpCategoryCountOutputTypeCountTranslationsArgs
    articles?: boolean | HelpCategoryCountOutputTypeCountArticlesArgs
  }

  // Custom InputTypes
  /**
   * HelpCategoryCountOutputType without action
   */
  export type HelpCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryCountOutputType
     */
    select?: HelpCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HelpCategoryCountOutputType without action
   */
  export type HelpCategoryCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpCategoryTranslationWhereInput
  }

  /**
   * HelpCategoryCountOutputType without action
   */
  export type HelpCategoryCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpArticleWhereInput
  }


  /**
   * Count Type HelpArticleCountOutputType
   */

  export type HelpArticleCountOutputType = {
    translations: number
  }

  export type HelpArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | HelpArticleCountOutputTypeCountTranslationsArgs
  }

  // Custom InputTypes
  /**
   * HelpArticleCountOutputType without action
   */
  export type HelpArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleCountOutputType
     */
    select?: HelpArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HelpArticleCountOutputType without action
   */
  export type HelpArticleCountOutputTypeCountTranslationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpArticleTranslationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: string | null
    name: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    role: string | null
    name: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    name: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    name?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    name?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    role: string
    name: string | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    name?: boolean
    createdAt?: boolean
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      role: string
      name: string | null
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    totalAmount: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    totalAmount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    orderNumber: string | null
    status: string | null
    totalAmount: number | null
    customerName: string | null
    customerFirstName: string | null
    customerLastName: string | null
    customerPhone: string | null
    customerEmail: string | null
    deliveryAddress: string | null
    deliveryMethod: string | null
    recipientCityRef: string | null
    recipientWarehouseRef: string | null
    ttnNumber: string | null
    ttnRef: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    orderNumber: string | null
    status: string | null
    totalAmount: number | null
    customerName: string | null
    customerFirstName: string | null
    customerLastName: string | null
    customerPhone: string | null
    customerEmail: string | null
    deliveryAddress: string | null
    deliveryMethod: string | null
    recipientCityRef: string | null
    recipientWarehouseRef: string | null
    ttnNumber: string | null
    ttnRef: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    status: number
    totalAmount: number
    customerName: number
    customerFirstName: number
    customerLastName: number
    customerPhone: number
    customerEmail: number
    deliveryAddress: number
    deliveryMethod: number
    recipientCityRef: number
    recipientWarehouseRef: number
    ttnNumber: number
    ttnRef: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    totalAmount?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    totalAmount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    totalAmount?: true
    customerName?: true
    customerFirstName?: true
    customerLastName?: true
    customerPhone?: true
    customerEmail?: true
    deliveryAddress?: true
    deliveryMethod?: true
    recipientCityRef?: true
    recipientWarehouseRef?: true
    ttnNumber?: true
    ttnRef?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    totalAmount?: true
    customerName?: true
    customerFirstName?: true
    customerLastName?: true
    customerPhone?: true
    customerEmail?: true
    deliveryAddress?: true
    deliveryMethod?: true
    recipientCityRef?: true
    recipientWarehouseRef?: true
    ttnNumber?: true
    ttnRef?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    status?: true
    totalAmount?: true
    customerName?: true
    customerFirstName?: true
    customerLastName?: true
    customerPhone?: true
    customerEmail?: true
    deliveryAddress?: true
    deliveryMethod?: true
    recipientCityRef?: true
    recipientWarehouseRef?: true
    ttnNumber?: true
    ttnRef?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    orderNumber: string
    status: string
    totalAmount: number
    customerName: string | null
    customerFirstName: string | null
    customerLastName: string | null
    customerPhone: string | null
    customerEmail: string | null
    deliveryAddress: string | null
    deliveryMethod: string
    recipientCityRef: string | null
    recipientWarehouseRef: string | null
    ttnNumber: string | null
    ttnRef: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    totalAmount?: boolean
    customerName?: boolean
    customerFirstName?: boolean
    customerLastName?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    deliveryAddress?: boolean
    deliveryMethod?: boolean
    recipientCityRef?: boolean
    recipientWarehouseRef?: boolean
    ttnNumber?: boolean
    ttnRef?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | Order$itemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    totalAmount?: boolean
    customerName?: boolean
    customerFirstName?: boolean
    customerLastName?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    deliveryAddress?: boolean
    deliveryMethod?: boolean
    recipientCityRef?: boolean
    recipientWarehouseRef?: boolean
    ttnNumber?: boolean
    ttnRef?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    status?: boolean
    totalAmount?: boolean
    customerName?: boolean
    customerFirstName?: boolean
    customerLastName?: boolean
    customerPhone?: boolean
    customerEmail?: boolean
    deliveryAddress?: boolean
    deliveryMethod?: boolean
    recipientCityRef?: boolean
    recipientWarehouseRef?: boolean
    ttnNumber?: boolean
    ttnRef?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Order$itemsArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      items: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderNumber: string
      status: string
      totalAmount: number
      customerName: string | null
      customerFirstName: string | null
      customerLastName: string | null
      customerPhone: string | null
      customerEmail: string | null
      deliveryAddress: string | null
      deliveryMethod: string
      recipientCityRef: string | null
      recipientWarehouseRef: string | null
      ttnNumber: string | null
      ttnRef: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'String'>
    readonly totalAmount: FieldRef<"Order", 'Float'>
    readonly customerName: FieldRef<"Order", 'String'>
    readonly customerFirstName: FieldRef<"Order", 'String'>
    readonly customerLastName: FieldRef<"Order", 'String'>
    readonly customerPhone: FieldRef<"Order", 'String'>
    readonly customerEmail: FieldRef<"Order", 'String'>
    readonly deliveryAddress: FieldRef<"Order", 'String'>
    readonly deliveryMethod: FieldRef<"Order", 'String'>
    readonly recipientCityRef: FieldRef<"Order", 'String'>
    readonly recipientWarehouseRef: FieldRef<"Order", 'String'>
    readonly ttnNumber: FieldRef<"Order", 'String'>
    readonly ttnRef: FieldRef<"Order", 'String'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    quantity: number | null
    price: number | null
    subtotal: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    quantity: number | null
    price: number | null
    subtotal: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    type: string | null
    name: string | null
    quantity: number | null
    price: number | null
    subtotal: number | null
    size: string | null
    paper: string | null
    options: string | null
    files: string | null
    createdAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    type: string | null
    name: string | null
    quantity: number | null
    price: number | null
    subtotal: number | null
    size: string | null
    paper: string | null
    options: string | null
    files: string | null
    createdAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    type: number
    name: number
    quantity: number
    price: number
    subtotal: number
    size: number
    paper: number
    options: number
    files: number
    createdAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    quantity?: true
    price?: true
    subtotal?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    quantity?: true
    price?: true
    subtotal?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    name?: true
    quantity?: true
    price?: true
    subtotal?: true
    size?: true
    paper?: true
    options?: true
    files?: true
    createdAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    name?: true
    quantity?: true
    price?: true
    subtotal?: true
    size?: true
    paper?: true
    options?: true
    files?: true
    createdAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    name?: true
    quantity?: true
    price?: true
    subtotal?: true
    size?: true
    paper?: true
    options?: true
    files?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderId: number
    type: string
    name: string
    quantity: number
    price: number
    subtotal: number
    size: string | null
    paper: string | null
    options: string | null
    files: string | null
    createdAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    name?: boolean
    quantity?: boolean
    price?: boolean
    subtotal?: boolean
    size?: boolean
    paper?: boolean
    options?: boolean
    files?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    name?: boolean
    quantity?: boolean
    price?: boolean
    subtotal?: boolean
    size?: boolean
    paper?: boolean
    options?: boolean
    files?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    type?: boolean
    name?: boolean
    quantity?: boolean
    price?: boolean
    subtotal?: boolean
    size?: boolean
    paper?: boolean
    options?: boolean
    files?: boolean
    createdAt?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      type: string
      name: string
      quantity: number
      price: number
      subtotal: number
      size: string | null
      paper: string | null
      options: string | null
      files: string | null
      createdAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly type: FieldRef<"OrderItem", 'String'>
    readonly name: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly price: FieldRef<"OrderItem", 'Float'>
    readonly subtotal: FieldRef<"OrderItem", 'Float'>
    readonly size: FieldRef<"OrderItem", 'String'>
    readonly paper: FieldRef<"OrderItem", 'String'>
    readonly options: FieldRef<"OrderItem", 'String'>
    readonly files: FieldRef<"OrderItem", 'String'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model PrintSize
   */

  export type AggregatePrintSize = {
    _count: PrintSizeCountAggregateOutputType | null
    _avg: PrintSizeAvgAggregateOutputType | null
    _sum: PrintSizeSumAggregateOutputType | null
    _min: PrintSizeMinAggregateOutputType | null
    _max: PrintSizeMaxAggregateOutputType | null
  }

  export type PrintSizeAvgAggregateOutputType = {
    id: number | null
    widthMm: number | null
    heightMm: number | null
    basePrice: number | null
    sortOrder: number | null
  }

  export type PrintSizeSumAggregateOutputType = {
    id: number | null
    widthMm: number | null
    heightMm: number | null
    basePrice: number | null
    sortOrder: number | null
  }

  export type PrintSizeMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    widthMm: number | null
    heightMm: number | null
    basePrice: number | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PrintSizeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    widthMm: number | null
    heightMm: number | null
    basePrice: number | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type PrintSizeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    widthMm: number
    heightMm: number
    basePrice: number
    sortOrder: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type PrintSizeAvgAggregateInputType = {
    id?: true
    widthMm?: true
    heightMm?: true
    basePrice?: true
    sortOrder?: true
  }

  export type PrintSizeSumAggregateInputType = {
    id?: true
    widthMm?: true
    heightMm?: true
    basePrice?: true
    sortOrder?: true
  }

  export type PrintSizeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    widthMm?: true
    heightMm?: true
    basePrice?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type PrintSizeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    widthMm?: true
    heightMm?: true
    basePrice?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
  }

  export type PrintSizeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    widthMm?: true
    heightMm?: true
    basePrice?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type PrintSizeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrintSize to aggregate.
     */
    where?: PrintSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintSizes to fetch.
     */
    orderBy?: PrintSizeOrderByWithRelationInput | PrintSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrintSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrintSizes
    **/
    _count?: true | PrintSizeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrintSizeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrintSizeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrintSizeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrintSizeMaxAggregateInputType
  }

  export type GetPrintSizeAggregateType<T extends PrintSizeAggregateArgs> = {
        [P in keyof T & keyof AggregatePrintSize]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrintSize[P]>
      : GetScalarType<T[P], AggregatePrintSize[P]>
  }




  export type PrintSizeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrintSizeWhereInput
    orderBy?: PrintSizeOrderByWithAggregationInput | PrintSizeOrderByWithAggregationInput[]
    by: PrintSizeScalarFieldEnum[] | PrintSizeScalarFieldEnum
    having?: PrintSizeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrintSizeCountAggregateInputType | true
    _avg?: PrintSizeAvgAggregateInputType
    _sum?: PrintSizeSumAggregateInputType
    _min?: PrintSizeMinAggregateInputType
    _max?: PrintSizeMaxAggregateInputType
  }

  export type PrintSizeGroupByOutputType = {
    id: number
    name: string
    slug: string
    widthMm: number | null
    heightMm: number | null
    basePrice: number
    sortOrder: number
    isActive: boolean
    createdAt: Date
    _count: PrintSizeCountAggregateOutputType | null
    _avg: PrintSizeAvgAggregateOutputType | null
    _sum: PrintSizeSumAggregateOutputType | null
    _min: PrintSizeMinAggregateOutputType | null
    _max: PrintSizeMaxAggregateOutputType | null
  }

  type GetPrintSizeGroupByPayload<T extends PrintSizeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrintSizeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrintSizeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrintSizeGroupByOutputType[P]>
            : GetScalarType<T[P], PrintSizeGroupByOutputType[P]>
        }
      >
    >


  export type PrintSizeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    widthMm?: boolean
    heightMm?: boolean
    basePrice?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    discounts?: boolean | PrintSize$discountsArgs<ExtArgs>
    _count?: boolean | PrintSizeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["printSize"]>

  export type PrintSizeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    widthMm?: boolean
    heightMm?: boolean
    basePrice?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["printSize"]>

  export type PrintSizeSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    widthMm?: boolean
    heightMm?: boolean
    basePrice?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type PrintSizeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discounts?: boolean | PrintSize$discountsArgs<ExtArgs>
    _count?: boolean | PrintSizeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrintSizeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PrintSizePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrintSize"
    objects: {
      discounts: Prisma.$VolumeDiscountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      widthMm: number | null
      heightMm: number | null
      basePrice: number
      sortOrder: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["printSize"]>
    composites: {}
  }

  type PrintSizeGetPayload<S extends boolean | null | undefined | PrintSizeDefaultArgs> = $Result.GetResult<Prisma.$PrintSizePayload, S>

  type PrintSizeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrintSizeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrintSizeCountAggregateInputType | true
    }

  export interface PrintSizeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrintSize'], meta: { name: 'PrintSize' } }
    /**
     * Find zero or one PrintSize that matches the filter.
     * @param {PrintSizeFindUniqueArgs} args - Arguments to find a PrintSize
     * @example
     * // Get one PrintSize
     * const printSize = await prisma.printSize.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrintSizeFindUniqueArgs>(args: SelectSubset<T, PrintSizeFindUniqueArgs<ExtArgs>>): Prisma__PrintSizeClient<$Result.GetResult<Prisma.$PrintSizePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PrintSize that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrintSizeFindUniqueOrThrowArgs} args - Arguments to find a PrintSize
     * @example
     * // Get one PrintSize
     * const printSize = await prisma.printSize.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrintSizeFindUniqueOrThrowArgs>(args: SelectSubset<T, PrintSizeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrintSizeClient<$Result.GetResult<Prisma.$PrintSizePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PrintSize that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintSizeFindFirstArgs} args - Arguments to find a PrintSize
     * @example
     * // Get one PrintSize
     * const printSize = await prisma.printSize.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrintSizeFindFirstArgs>(args?: SelectSubset<T, PrintSizeFindFirstArgs<ExtArgs>>): Prisma__PrintSizeClient<$Result.GetResult<Prisma.$PrintSizePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PrintSize that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintSizeFindFirstOrThrowArgs} args - Arguments to find a PrintSize
     * @example
     * // Get one PrintSize
     * const printSize = await prisma.printSize.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrintSizeFindFirstOrThrowArgs>(args?: SelectSubset<T, PrintSizeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrintSizeClient<$Result.GetResult<Prisma.$PrintSizePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PrintSizes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintSizeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrintSizes
     * const printSizes = await prisma.printSize.findMany()
     * 
     * // Get first 10 PrintSizes
     * const printSizes = await prisma.printSize.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const printSizeWithIdOnly = await prisma.printSize.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrintSizeFindManyArgs>(args?: SelectSubset<T, PrintSizeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintSizePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PrintSize.
     * @param {PrintSizeCreateArgs} args - Arguments to create a PrintSize.
     * @example
     * // Create one PrintSize
     * const PrintSize = await prisma.printSize.create({
     *   data: {
     *     // ... data to create a PrintSize
     *   }
     * })
     * 
     */
    create<T extends PrintSizeCreateArgs>(args: SelectSubset<T, PrintSizeCreateArgs<ExtArgs>>): Prisma__PrintSizeClient<$Result.GetResult<Prisma.$PrintSizePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PrintSizes.
     * @param {PrintSizeCreateManyArgs} args - Arguments to create many PrintSizes.
     * @example
     * // Create many PrintSizes
     * const printSize = await prisma.printSize.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrintSizeCreateManyArgs>(args?: SelectSubset<T, PrintSizeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrintSizes and returns the data saved in the database.
     * @param {PrintSizeCreateManyAndReturnArgs} args - Arguments to create many PrintSizes.
     * @example
     * // Create many PrintSizes
     * const printSize = await prisma.printSize.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrintSizes and only return the `id`
     * const printSizeWithIdOnly = await prisma.printSize.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrintSizeCreateManyAndReturnArgs>(args?: SelectSubset<T, PrintSizeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintSizePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PrintSize.
     * @param {PrintSizeDeleteArgs} args - Arguments to delete one PrintSize.
     * @example
     * // Delete one PrintSize
     * const PrintSize = await prisma.printSize.delete({
     *   where: {
     *     // ... filter to delete one PrintSize
     *   }
     * })
     * 
     */
    delete<T extends PrintSizeDeleteArgs>(args: SelectSubset<T, PrintSizeDeleteArgs<ExtArgs>>): Prisma__PrintSizeClient<$Result.GetResult<Prisma.$PrintSizePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PrintSize.
     * @param {PrintSizeUpdateArgs} args - Arguments to update one PrintSize.
     * @example
     * // Update one PrintSize
     * const printSize = await prisma.printSize.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrintSizeUpdateArgs>(args: SelectSubset<T, PrintSizeUpdateArgs<ExtArgs>>): Prisma__PrintSizeClient<$Result.GetResult<Prisma.$PrintSizePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PrintSizes.
     * @param {PrintSizeDeleteManyArgs} args - Arguments to filter PrintSizes to delete.
     * @example
     * // Delete a few PrintSizes
     * const { count } = await prisma.printSize.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrintSizeDeleteManyArgs>(args?: SelectSubset<T, PrintSizeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrintSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintSizeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrintSizes
     * const printSize = await prisma.printSize.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrintSizeUpdateManyArgs>(args: SelectSubset<T, PrintSizeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrintSize.
     * @param {PrintSizeUpsertArgs} args - Arguments to update or create a PrintSize.
     * @example
     * // Update or create a PrintSize
     * const printSize = await prisma.printSize.upsert({
     *   create: {
     *     // ... data to create a PrintSize
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrintSize we want to update
     *   }
     * })
     */
    upsert<T extends PrintSizeUpsertArgs>(args: SelectSubset<T, PrintSizeUpsertArgs<ExtArgs>>): Prisma__PrintSizeClient<$Result.GetResult<Prisma.$PrintSizePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PrintSizes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintSizeCountArgs} args - Arguments to filter PrintSizes to count.
     * @example
     * // Count the number of PrintSizes
     * const count = await prisma.printSize.count({
     *   where: {
     *     // ... the filter for the PrintSizes we want to count
     *   }
     * })
    **/
    count<T extends PrintSizeCountArgs>(
      args?: Subset<T, PrintSizeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrintSizeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrintSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintSizeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrintSizeAggregateArgs>(args: Subset<T, PrintSizeAggregateArgs>): Prisma.PrismaPromise<GetPrintSizeAggregateType<T>>

    /**
     * Group by PrintSize.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintSizeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrintSizeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrintSizeGroupByArgs['orderBy'] }
        : { orderBy?: PrintSizeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrintSizeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrintSizeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrintSize model
   */
  readonly fields: PrintSizeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrintSize.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrintSizeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discounts<T extends PrintSize$discountsArgs<ExtArgs> = {}>(args?: Subset<T, PrintSize$discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrintSize model
   */ 
  interface PrintSizeFieldRefs {
    readonly id: FieldRef<"PrintSize", 'Int'>
    readonly name: FieldRef<"PrintSize", 'String'>
    readonly slug: FieldRef<"PrintSize", 'String'>
    readonly widthMm: FieldRef<"PrintSize", 'Float'>
    readonly heightMm: FieldRef<"PrintSize", 'Float'>
    readonly basePrice: FieldRef<"PrintSize", 'Float'>
    readonly sortOrder: FieldRef<"PrintSize", 'Int'>
    readonly isActive: FieldRef<"PrintSize", 'Boolean'>
    readonly createdAt: FieldRef<"PrintSize", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrintSize findUnique
   */
  export type PrintSizeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSize
     */
    select?: PrintSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintSizeInclude<ExtArgs> | null
    /**
     * Filter, which PrintSize to fetch.
     */
    where: PrintSizeWhereUniqueInput
  }

  /**
   * PrintSize findUniqueOrThrow
   */
  export type PrintSizeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSize
     */
    select?: PrintSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintSizeInclude<ExtArgs> | null
    /**
     * Filter, which PrintSize to fetch.
     */
    where: PrintSizeWhereUniqueInput
  }

  /**
   * PrintSize findFirst
   */
  export type PrintSizeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSize
     */
    select?: PrintSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintSizeInclude<ExtArgs> | null
    /**
     * Filter, which PrintSize to fetch.
     */
    where?: PrintSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintSizes to fetch.
     */
    orderBy?: PrintSizeOrderByWithRelationInput | PrintSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrintSizes.
     */
    cursor?: PrintSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrintSizes.
     */
    distinct?: PrintSizeScalarFieldEnum | PrintSizeScalarFieldEnum[]
  }

  /**
   * PrintSize findFirstOrThrow
   */
  export type PrintSizeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSize
     */
    select?: PrintSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintSizeInclude<ExtArgs> | null
    /**
     * Filter, which PrintSize to fetch.
     */
    where?: PrintSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintSizes to fetch.
     */
    orderBy?: PrintSizeOrderByWithRelationInput | PrintSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrintSizes.
     */
    cursor?: PrintSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintSizes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrintSizes.
     */
    distinct?: PrintSizeScalarFieldEnum | PrintSizeScalarFieldEnum[]
  }

  /**
   * PrintSize findMany
   */
  export type PrintSizeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSize
     */
    select?: PrintSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintSizeInclude<ExtArgs> | null
    /**
     * Filter, which PrintSizes to fetch.
     */
    where?: PrintSizeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintSizes to fetch.
     */
    orderBy?: PrintSizeOrderByWithRelationInput | PrintSizeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrintSizes.
     */
    cursor?: PrintSizeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintSizes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintSizes.
     */
    skip?: number
    distinct?: PrintSizeScalarFieldEnum | PrintSizeScalarFieldEnum[]
  }

  /**
   * PrintSize create
   */
  export type PrintSizeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSize
     */
    select?: PrintSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintSizeInclude<ExtArgs> | null
    /**
     * The data needed to create a PrintSize.
     */
    data: XOR<PrintSizeCreateInput, PrintSizeUncheckedCreateInput>
  }

  /**
   * PrintSize createMany
   */
  export type PrintSizeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrintSizes.
     */
    data: PrintSizeCreateManyInput | PrintSizeCreateManyInput[]
  }

  /**
   * PrintSize createManyAndReturn
   */
  export type PrintSizeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSize
     */
    select?: PrintSizeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PrintSizes.
     */
    data: PrintSizeCreateManyInput | PrintSizeCreateManyInput[]
  }

  /**
   * PrintSize update
   */
  export type PrintSizeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSize
     */
    select?: PrintSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintSizeInclude<ExtArgs> | null
    /**
     * The data needed to update a PrintSize.
     */
    data: XOR<PrintSizeUpdateInput, PrintSizeUncheckedUpdateInput>
    /**
     * Choose, which PrintSize to update.
     */
    where: PrintSizeWhereUniqueInput
  }

  /**
   * PrintSize updateMany
   */
  export type PrintSizeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrintSizes.
     */
    data: XOR<PrintSizeUpdateManyMutationInput, PrintSizeUncheckedUpdateManyInput>
    /**
     * Filter which PrintSizes to update
     */
    where?: PrintSizeWhereInput
  }

  /**
   * PrintSize upsert
   */
  export type PrintSizeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSize
     */
    select?: PrintSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintSizeInclude<ExtArgs> | null
    /**
     * The filter to search for the PrintSize to update in case it exists.
     */
    where: PrintSizeWhereUniqueInput
    /**
     * In case the PrintSize found by the `where` argument doesn't exist, create a new PrintSize with this data.
     */
    create: XOR<PrintSizeCreateInput, PrintSizeUncheckedCreateInput>
    /**
     * In case the PrintSize was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrintSizeUpdateInput, PrintSizeUncheckedUpdateInput>
  }

  /**
   * PrintSize delete
   */
  export type PrintSizeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSize
     */
    select?: PrintSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintSizeInclude<ExtArgs> | null
    /**
     * Filter which PrintSize to delete.
     */
    where: PrintSizeWhereUniqueInput
  }

  /**
   * PrintSize deleteMany
   */
  export type PrintSizeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrintSizes to delete
     */
    where?: PrintSizeWhereInput
  }

  /**
   * PrintSize.discounts
   */
  export type PrintSize$discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
    where?: VolumeDiscountWhereInput
    orderBy?: VolumeDiscountOrderByWithRelationInput | VolumeDiscountOrderByWithRelationInput[]
    cursor?: VolumeDiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolumeDiscountScalarFieldEnum | VolumeDiscountScalarFieldEnum[]
  }

  /**
   * PrintSize without action
   */
  export type PrintSizeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintSize
     */
    select?: PrintSizeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrintSizeInclude<ExtArgs> | null
  }


  /**
   * Model QuantityTier
   */

  export type AggregateQuantityTier = {
    _count: QuantityTierCountAggregateOutputType | null
    _avg: QuantityTierAvgAggregateOutputType | null
    _sum: QuantityTierSumAggregateOutputType | null
    _min: QuantityTierMinAggregateOutputType | null
    _max: QuantityTierMaxAggregateOutputType | null
  }

  export type QuantityTierAvgAggregateOutputType = {
    id: number | null
    minQuantity: number | null
    sortOrder: number | null
  }

  export type QuantityTierSumAggregateOutputType = {
    id: number | null
    minQuantity: number | null
    sortOrder: number | null
  }

  export type QuantityTierMinAggregateOutputType = {
    id: number | null
    label: string | null
    minQuantity: number | null
    sortOrder: number | null
    isActive: boolean | null
  }

  export type QuantityTierMaxAggregateOutputType = {
    id: number | null
    label: string | null
    minQuantity: number | null
    sortOrder: number | null
    isActive: boolean | null
  }

  export type QuantityTierCountAggregateOutputType = {
    id: number
    label: number
    minQuantity: number
    sortOrder: number
    isActive: number
    _all: number
  }


  export type QuantityTierAvgAggregateInputType = {
    id?: true
    minQuantity?: true
    sortOrder?: true
  }

  export type QuantityTierSumAggregateInputType = {
    id?: true
    minQuantity?: true
    sortOrder?: true
  }

  export type QuantityTierMinAggregateInputType = {
    id?: true
    label?: true
    minQuantity?: true
    sortOrder?: true
    isActive?: true
  }

  export type QuantityTierMaxAggregateInputType = {
    id?: true
    label?: true
    minQuantity?: true
    sortOrder?: true
    isActive?: true
  }

  export type QuantityTierCountAggregateInputType = {
    id?: true
    label?: true
    minQuantity?: true
    sortOrder?: true
    isActive?: true
    _all?: true
  }

  export type QuantityTierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuantityTier to aggregate.
     */
    where?: QuantityTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuantityTiers to fetch.
     */
    orderBy?: QuantityTierOrderByWithRelationInput | QuantityTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuantityTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuantityTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuantityTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuantityTiers
    **/
    _count?: true | QuantityTierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuantityTierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuantityTierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuantityTierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuantityTierMaxAggregateInputType
  }

  export type GetQuantityTierAggregateType<T extends QuantityTierAggregateArgs> = {
        [P in keyof T & keyof AggregateQuantityTier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuantityTier[P]>
      : GetScalarType<T[P], AggregateQuantityTier[P]>
  }




  export type QuantityTierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuantityTierWhereInput
    orderBy?: QuantityTierOrderByWithAggregationInput | QuantityTierOrderByWithAggregationInput[]
    by: QuantityTierScalarFieldEnum[] | QuantityTierScalarFieldEnum
    having?: QuantityTierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuantityTierCountAggregateInputType | true
    _avg?: QuantityTierAvgAggregateInputType
    _sum?: QuantityTierSumAggregateInputType
    _min?: QuantityTierMinAggregateInputType
    _max?: QuantityTierMaxAggregateInputType
  }

  export type QuantityTierGroupByOutputType = {
    id: number
    label: string
    minQuantity: number
    sortOrder: number
    isActive: boolean
    _count: QuantityTierCountAggregateOutputType | null
    _avg: QuantityTierAvgAggregateOutputType | null
    _sum: QuantityTierSumAggregateOutputType | null
    _min: QuantityTierMinAggregateOutputType | null
    _max: QuantityTierMaxAggregateOutputType | null
  }

  type GetQuantityTierGroupByPayload<T extends QuantityTierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuantityTierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuantityTierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuantityTierGroupByOutputType[P]>
            : GetScalarType<T[P], QuantityTierGroupByOutputType[P]>
        }
      >
    >


  export type QuantityTierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    minQuantity?: boolean
    sortOrder?: boolean
    isActive?: boolean
    discounts?: boolean | QuantityTier$discountsArgs<ExtArgs>
    _count?: boolean | QuantityTierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quantityTier"]>

  export type QuantityTierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    minQuantity?: boolean
    sortOrder?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["quantityTier"]>

  export type QuantityTierSelectScalar = {
    id?: boolean
    label?: boolean
    minQuantity?: boolean
    sortOrder?: boolean
    isActive?: boolean
  }

  export type QuantityTierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discounts?: boolean | QuantityTier$discountsArgs<ExtArgs>
    _count?: boolean | QuantityTierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuantityTierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QuantityTierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuantityTier"
    objects: {
      discounts: Prisma.$VolumeDiscountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      minQuantity: number
      sortOrder: number
      isActive: boolean
    }, ExtArgs["result"]["quantityTier"]>
    composites: {}
  }

  type QuantityTierGetPayload<S extends boolean | null | undefined | QuantityTierDefaultArgs> = $Result.GetResult<Prisma.$QuantityTierPayload, S>

  type QuantityTierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuantityTierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuantityTierCountAggregateInputType | true
    }

  export interface QuantityTierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuantityTier'], meta: { name: 'QuantityTier' } }
    /**
     * Find zero or one QuantityTier that matches the filter.
     * @param {QuantityTierFindUniqueArgs} args - Arguments to find a QuantityTier
     * @example
     * // Get one QuantityTier
     * const quantityTier = await prisma.quantityTier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuantityTierFindUniqueArgs>(args: SelectSubset<T, QuantityTierFindUniqueArgs<ExtArgs>>): Prisma__QuantityTierClient<$Result.GetResult<Prisma.$QuantityTierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuantityTier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuantityTierFindUniqueOrThrowArgs} args - Arguments to find a QuantityTier
     * @example
     * // Get one QuantityTier
     * const quantityTier = await prisma.quantityTier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuantityTierFindUniqueOrThrowArgs>(args: SelectSubset<T, QuantityTierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuantityTierClient<$Result.GetResult<Prisma.$QuantityTierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuantityTier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityTierFindFirstArgs} args - Arguments to find a QuantityTier
     * @example
     * // Get one QuantityTier
     * const quantityTier = await prisma.quantityTier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuantityTierFindFirstArgs>(args?: SelectSubset<T, QuantityTierFindFirstArgs<ExtArgs>>): Prisma__QuantityTierClient<$Result.GetResult<Prisma.$QuantityTierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuantityTier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityTierFindFirstOrThrowArgs} args - Arguments to find a QuantityTier
     * @example
     * // Get one QuantityTier
     * const quantityTier = await prisma.quantityTier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuantityTierFindFirstOrThrowArgs>(args?: SelectSubset<T, QuantityTierFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuantityTierClient<$Result.GetResult<Prisma.$QuantityTierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuantityTiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityTierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuantityTiers
     * const quantityTiers = await prisma.quantityTier.findMany()
     * 
     * // Get first 10 QuantityTiers
     * const quantityTiers = await prisma.quantityTier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quantityTierWithIdOnly = await prisma.quantityTier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuantityTierFindManyArgs>(args?: SelectSubset<T, QuantityTierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuantityTierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuantityTier.
     * @param {QuantityTierCreateArgs} args - Arguments to create a QuantityTier.
     * @example
     * // Create one QuantityTier
     * const QuantityTier = await prisma.quantityTier.create({
     *   data: {
     *     // ... data to create a QuantityTier
     *   }
     * })
     * 
     */
    create<T extends QuantityTierCreateArgs>(args: SelectSubset<T, QuantityTierCreateArgs<ExtArgs>>): Prisma__QuantityTierClient<$Result.GetResult<Prisma.$QuantityTierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuantityTiers.
     * @param {QuantityTierCreateManyArgs} args - Arguments to create many QuantityTiers.
     * @example
     * // Create many QuantityTiers
     * const quantityTier = await prisma.quantityTier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuantityTierCreateManyArgs>(args?: SelectSubset<T, QuantityTierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuantityTiers and returns the data saved in the database.
     * @param {QuantityTierCreateManyAndReturnArgs} args - Arguments to create many QuantityTiers.
     * @example
     * // Create many QuantityTiers
     * const quantityTier = await prisma.quantityTier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuantityTiers and only return the `id`
     * const quantityTierWithIdOnly = await prisma.quantityTier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuantityTierCreateManyAndReturnArgs>(args?: SelectSubset<T, QuantityTierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuantityTierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuantityTier.
     * @param {QuantityTierDeleteArgs} args - Arguments to delete one QuantityTier.
     * @example
     * // Delete one QuantityTier
     * const QuantityTier = await prisma.quantityTier.delete({
     *   where: {
     *     // ... filter to delete one QuantityTier
     *   }
     * })
     * 
     */
    delete<T extends QuantityTierDeleteArgs>(args: SelectSubset<T, QuantityTierDeleteArgs<ExtArgs>>): Prisma__QuantityTierClient<$Result.GetResult<Prisma.$QuantityTierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuantityTier.
     * @param {QuantityTierUpdateArgs} args - Arguments to update one QuantityTier.
     * @example
     * // Update one QuantityTier
     * const quantityTier = await prisma.quantityTier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuantityTierUpdateArgs>(args: SelectSubset<T, QuantityTierUpdateArgs<ExtArgs>>): Prisma__QuantityTierClient<$Result.GetResult<Prisma.$QuantityTierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuantityTiers.
     * @param {QuantityTierDeleteManyArgs} args - Arguments to filter QuantityTiers to delete.
     * @example
     * // Delete a few QuantityTiers
     * const { count } = await prisma.quantityTier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuantityTierDeleteManyArgs>(args?: SelectSubset<T, QuantityTierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuantityTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityTierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuantityTiers
     * const quantityTier = await prisma.quantityTier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuantityTierUpdateManyArgs>(args: SelectSubset<T, QuantityTierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuantityTier.
     * @param {QuantityTierUpsertArgs} args - Arguments to update or create a QuantityTier.
     * @example
     * // Update or create a QuantityTier
     * const quantityTier = await prisma.quantityTier.upsert({
     *   create: {
     *     // ... data to create a QuantityTier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuantityTier we want to update
     *   }
     * })
     */
    upsert<T extends QuantityTierUpsertArgs>(args: SelectSubset<T, QuantityTierUpsertArgs<ExtArgs>>): Prisma__QuantityTierClient<$Result.GetResult<Prisma.$QuantityTierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuantityTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityTierCountArgs} args - Arguments to filter QuantityTiers to count.
     * @example
     * // Count the number of QuantityTiers
     * const count = await prisma.quantityTier.count({
     *   where: {
     *     // ... the filter for the QuantityTiers we want to count
     *   }
     * })
    **/
    count<T extends QuantityTierCountArgs>(
      args?: Subset<T, QuantityTierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuantityTierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuantityTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityTierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuantityTierAggregateArgs>(args: Subset<T, QuantityTierAggregateArgs>): Prisma.PrismaPromise<GetQuantityTierAggregateType<T>>

    /**
     * Group by QuantityTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuantityTierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuantityTierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuantityTierGroupByArgs['orderBy'] }
        : { orderBy?: QuantityTierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuantityTierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuantityTierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuantityTier model
   */
  readonly fields: QuantityTierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuantityTier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuantityTierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discounts<T extends QuantityTier$discountsArgs<ExtArgs> = {}>(args?: Subset<T, QuantityTier$discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuantityTier model
   */ 
  interface QuantityTierFieldRefs {
    readonly id: FieldRef<"QuantityTier", 'Int'>
    readonly label: FieldRef<"QuantityTier", 'String'>
    readonly minQuantity: FieldRef<"QuantityTier", 'Int'>
    readonly sortOrder: FieldRef<"QuantityTier", 'Int'>
    readonly isActive: FieldRef<"QuantityTier", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * QuantityTier findUnique
   */
  export type QuantityTierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuantityTierInclude<ExtArgs> | null
    /**
     * Filter, which QuantityTier to fetch.
     */
    where: QuantityTierWhereUniqueInput
  }

  /**
   * QuantityTier findUniqueOrThrow
   */
  export type QuantityTierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuantityTierInclude<ExtArgs> | null
    /**
     * Filter, which QuantityTier to fetch.
     */
    where: QuantityTierWhereUniqueInput
  }

  /**
   * QuantityTier findFirst
   */
  export type QuantityTierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuantityTierInclude<ExtArgs> | null
    /**
     * Filter, which QuantityTier to fetch.
     */
    where?: QuantityTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuantityTiers to fetch.
     */
    orderBy?: QuantityTierOrderByWithRelationInput | QuantityTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuantityTiers.
     */
    cursor?: QuantityTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuantityTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuantityTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuantityTiers.
     */
    distinct?: QuantityTierScalarFieldEnum | QuantityTierScalarFieldEnum[]
  }

  /**
   * QuantityTier findFirstOrThrow
   */
  export type QuantityTierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuantityTierInclude<ExtArgs> | null
    /**
     * Filter, which QuantityTier to fetch.
     */
    where?: QuantityTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuantityTiers to fetch.
     */
    orderBy?: QuantityTierOrderByWithRelationInput | QuantityTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuantityTiers.
     */
    cursor?: QuantityTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuantityTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuantityTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuantityTiers.
     */
    distinct?: QuantityTierScalarFieldEnum | QuantityTierScalarFieldEnum[]
  }

  /**
   * QuantityTier findMany
   */
  export type QuantityTierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuantityTierInclude<ExtArgs> | null
    /**
     * Filter, which QuantityTiers to fetch.
     */
    where?: QuantityTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuantityTiers to fetch.
     */
    orderBy?: QuantityTierOrderByWithRelationInput | QuantityTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuantityTiers.
     */
    cursor?: QuantityTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuantityTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuantityTiers.
     */
    skip?: number
    distinct?: QuantityTierScalarFieldEnum | QuantityTierScalarFieldEnum[]
  }

  /**
   * QuantityTier create
   */
  export type QuantityTierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuantityTierInclude<ExtArgs> | null
    /**
     * The data needed to create a QuantityTier.
     */
    data: XOR<QuantityTierCreateInput, QuantityTierUncheckedCreateInput>
  }

  /**
   * QuantityTier createMany
   */
  export type QuantityTierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuantityTiers.
     */
    data: QuantityTierCreateManyInput | QuantityTierCreateManyInput[]
  }

  /**
   * QuantityTier createManyAndReturn
   */
  export type QuantityTierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuantityTiers.
     */
    data: QuantityTierCreateManyInput | QuantityTierCreateManyInput[]
  }

  /**
   * QuantityTier update
   */
  export type QuantityTierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuantityTierInclude<ExtArgs> | null
    /**
     * The data needed to update a QuantityTier.
     */
    data: XOR<QuantityTierUpdateInput, QuantityTierUncheckedUpdateInput>
    /**
     * Choose, which QuantityTier to update.
     */
    where: QuantityTierWhereUniqueInput
  }

  /**
   * QuantityTier updateMany
   */
  export type QuantityTierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuantityTiers.
     */
    data: XOR<QuantityTierUpdateManyMutationInput, QuantityTierUncheckedUpdateManyInput>
    /**
     * Filter which QuantityTiers to update
     */
    where?: QuantityTierWhereInput
  }

  /**
   * QuantityTier upsert
   */
  export type QuantityTierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuantityTierInclude<ExtArgs> | null
    /**
     * The filter to search for the QuantityTier to update in case it exists.
     */
    where: QuantityTierWhereUniqueInput
    /**
     * In case the QuantityTier found by the `where` argument doesn't exist, create a new QuantityTier with this data.
     */
    create: XOR<QuantityTierCreateInput, QuantityTierUncheckedCreateInput>
    /**
     * In case the QuantityTier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuantityTierUpdateInput, QuantityTierUncheckedUpdateInput>
  }

  /**
   * QuantityTier delete
   */
  export type QuantityTierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuantityTierInclude<ExtArgs> | null
    /**
     * Filter which QuantityTier to delete.
     */
    where: QuantityTierWhereUniqueInput
  }

  /**
   * QuantityTier deleteMany
   */
  export type QuantityTierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuantityTiers to delete
     */
    where?: QuantityTierWhereInput
  }

  /**
   * QuantityTier.discounts
   */
  export type QuantityTier$discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
    where?: VolumeDiscountWhereInput
    orderBy?: VolumeDiscountOrderByWithRelationInput | VolumeDiscountOrderByWithRelationInput[]
    cursor?: VolumeDiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VolumeDiscountScalarFieldEnum | VolumeDiscountScalarFieldEnum[]
  }

  /**
   * QuantityTier without action
   */
  export type QuantityTierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuantityTierInclude<ExtArgs> | null
  }


  /**
   * Model VolumeDiscount
   */

  export type AggregateVolumeDiscount = {
    _count: VolumeDiscountCountAggregateOutputType | null
    _avg: VolumeDiscountAvgAggregateOutputType | null
    _sum: VolumeDiscountSumAggregateOutputType | null
    _min: VolumeDiscountMinAggregateOutputType | null
    _max: VolumeDiscountMaxAggregateOutputType | null
  }

  export type VolumeDiscountAvgAggregateOutputType = {
    id: number | null
    printSizeId: number | null
    tierId: number | null
    minQuantity: number | null
    price: number | null
  }

  export type VolumeDiscountSumAggregateOutputType = {
    id: number | null
    printSizeId: number | null
    tierId: number | null
    minQuantity: number | null
    price: number | null
  }

  export type VolumeDiscountMinAggregateOutputType = {
    id: number | null
    printSizeId: number | null
    tierId: number | null
    minQuantity: number | null
    price: number | null
  }

  export type VolumeDiscountMaxAggregateOutputType = {
    id: number | null
    printSizeId: number | null
    tierId: number | null
    minQuantity: number | null
    price: number | null
  }

  export type VolumeDiscountCountAggregateOutputType = {
    id: number
    printSizeId: number
    tierId: number
    minQuantity: number
    price: number
    _all: number
  }


  export type VolumeDiscountAvgAggregateInputType = {
    id?: true
    printSizeId?: true
    tierId?: true
    minQuantity?: true
    price?: true
  }

  export type VolumeDiscountSumAggregateInputType = {
    id?: true
    printSizeId?: true
    tierId?: true
    minQuantity?: true
    price?: true
  }

  export type VolumeDiscountMinAggregateInputType = {
    id?: true
    printSizeId?: true
    tierId?: true
    minQuantity?: true
    price?: true
  }

  export type VolumeDiscountMaxAggregateInputType = {
    id?: true
    printSizeId?: true
    tierId?: true
    minQuantity?: true
    price?: true
  }

  export type VolumeDiscountCountAggregateInputType = {
    id?: true
    printSizeId?: true
    tierId?: true
    minQuantity?: true
    price?: true
    _all?: true
  }

  export type VolumeDiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolumeDiscount to aggregate.
     */
    where?: VolumeDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolumeDiscounts to fetch.
     */
    orderBy?: VolumeDiscountOrderByWithRelationInput | VolumeDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VolumeDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolumeDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolumeDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VolumeDiscounts
    **/
    _count?: true | VolumeDiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VolumeDiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VolumeDiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VolumeDiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VolumeDiscountMaxAggregateInputType
  }

  export type GetVolumeDiscountAggregateType<T extends VolumeDiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateVolumeDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVolumeDiscount[P]>
      : GetScalarType<T[P], AggregateVolumeDiscount[P]>
  }




  export type VolumeDiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VolumeDiscountWhereInput
    orderBy?: VolumeDiscountOrderByWithAggregationInput | VolumeDiscountOrderByWithAggregationInput[]
    by: VolumeDiscountScalarFieldEnum[] | VolumeDiscountScalarFieldEnum
    having?: VolumeDiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VolumeDiscountCountAggregateInputType | true
    _avg?: VolumeDiscountAvgAggregateInputType
    _sum?: VolumeDiscountSumAggregateInputType
    _min?: VolumeDiscountMinAggregateInputType
    _max?: VolumeDiscountMaxAggregateInputType
  }

  export type VolumeDiscountGroupByOutputType = {
    id: number
    printSizeId: number
    tierId: number | null
    minQuantity: number
    price: number
    _count: VolumeDiscountCountAggregateOutputType | null
    _avg: VolumeDiscountAvgAggregateOutputType | null
    _sum: VolumeDiscountSumAggregateOutputType | null
    _min: VolumeDiscountMinAggregateOutputType | null
    _max: VolumeDiscountMaxAggregateOutputType | null
  }

  type GetVolumeDiscountGroupByPayload<T extends VolumeDiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VolumeDiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VolumeDiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VolumeDiscountGroupByOutputType[P]>
            : GetScalarType<T[P], VolumeDiscountGroupByOutputType[P]>
        }
      >
    >


  export type VolumeDiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    printSizeId?: boolean
    tierId?: boolean
    minQuantity?: boolean
    price?: boolean
    printSize?: boolean | PrintSizeDefaultArgs<ExtArgs>
    tier?: boolean | VolumeDiscount$tierArgs<ExtArgs>
  }, ExtArgs["result"]["volumeDiscount"]>

  export type VolumeDiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    printSizeId?: boolean
    tierId?: boolean
    minQuantity?: boolean
    price?: boolean
    printSize?: boolean | PrintSizeDefaultArgs<ExtArgs>
    tier?: boolean | VolumeDiscount$tierArgs<ExtArgs>
  }, ExtArgs["result"]["volumeDiscount"]>

  export type VolumeDiscountSelectScalar = {
    id?: boolean
    printSizeId?: boolean
    tierId?: boolean
    minQuantity?: boolean
    price?: boolean
  }

  export type VolumeDiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    printSize?: boolean | PrintSizeDefaultArgs<ExtArgs>
    tier?: boolean | VolumeDiscount$tierArgs<ExtArgs>
  }
  export type VolumeDiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    printSize?: boolean | PrintSizeDefaultArgs<ExtArgs>
    tier?: boolean | VolumeDiscount$tierArgs<ExtArgs>
  }

  export type $VolumeDiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VolumeDiscount"
    objects: {
      printSize: Prisma.$PrintSizePayload<ExtArgs>
      tier: Prisma.$QuantityTierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      printSizeId: number
      tierId: number | null
      minQuantity: number
      price: number
    }, ExtArgs["result"]["volumeDiscount"]>
    composites: {}
  }

  type VolumeDiscountGetPayload<S extends boolean | null | undefined | VolumeDiscountDefaultArgs> = $Result.GetResult<Prisma.$VolumeDiscountPayload, S>

  type VolumeDiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VolumeDiscountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VolumeDiscountCountAggregateInputType | true
    }

  export interface VolumeDiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VolumeDiscount'], meta: { name: 'VolumeDiscount' } }
    /**
     * Find zero or one VolumeDiscount that matches the filter.
     * @param {VolumeDiscountFindUniqueArgs} args - Arguments to find a VolumeDiscount
     * @example
     * // Get one VolumeDiscount
     * const volumeDiscount = await prisma.volumeDiscount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VolumeDiscountFindUniqueArgs>(args: SelectSubset<T, VolumeDiscountFindUniqueArgs<ExtArgs>>): Prisma__VolumeDiscountClient<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VolumeDiscount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VolumeDiscountFindUniqueOrThrowArgs} args - Arguments to find a VolumeDiscount
     * @example
     * // Get one VolumeDiscount
     * const volumeDiscount = await prisma.volumeDiscount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VolumeDiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, VolumeDiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VolumeDiscountClient<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VolumeDiscount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeDiscountFindFirstArgs} args - Arguments to find a VolumeDiscount
     * @example
     * // Get one VolumeDiscount
     * const volumeDiscount = await prisma.volumeDiscount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VolumeDiscountFindFirstArgs>(args?: SelectSubset<T, VolumeDiscountFindFirstArgs<ExtArgs>>): Prisma__VolumeDiscountClient<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VolumeDiscount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeDiscountFindFirstOrThrowArgs} args - Arguments to find a VolumeDiscount
     * @example
     * // Get one VolumeDiscount
     * const volumeDiscount = await prisma.volumeDiscount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VolumeDiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, VolumeDiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__VolumeDiscountClient<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VolumeDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeDiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VolumeDiscounts
     * const volumeDiscounts = await prisma.volumeDiscount.findMany()
     * 
     * // Get first 10 VolumeDiscounts
     * const volumeDiscounts = await prisma.volumeDiscount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const volumeDiscountWithIdOnly = await prisma.volumeDiscount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VolumeDiscountFindManyArgs>(args?: SelectSubset<T, VolumeDiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VolumeDiscount.
     * @param {VolumeDiscountCreateArgs} args - Arguments to create a VolumeDiscount.
     * @example
     * // Create one VolumeDiscount
     * const VolumeDiscount = await prisma.volumeDiscount.create({
     *   data: {
     *     // ... data to create a VolumeDiscount
     *   }
     * })
     * 
     */
    create<T extends VolumeDiscountCreateArgs>(args: SelectSubset<T, VolumeDiscountCreateArgs<ExtArgs>>): Prisma__VolumeDiscountClient<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VolumeDiscounts.
     * @param {VolumeDiscountCreateManyArgs} args - Arguments to create many VolumeDiscounts.
     * @example
     * // Create many VolumeDiscounts
     * const volumeDiscount = await prisma.volumeDiscount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VolumeDiscountCreateManyArgs>(args?: SelectSubset<T, VolumeDiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VolumeDiscounts and returns the data saved in the database.
     * @param {VolumeDiscountCreateManyAndReturnArgs} args - Arguments to create many VolumeDiscounts.
     * @example
     * // Create many VolumeDiscounts
     * const volumeDiscount = await prisma.volumeDiscount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VolumeDiscounts and only return the `id`
     * const volumeDiscountWithIdOnly = await prisma.volumeDiscount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VolumeDiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, VolumeDiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VolumeDiscount.
     * @param {VolumeDiscountDeleteArgs} args - Arguments to delete one VolumeDiscount.
     * @example
     * // Delete one VolumeDiscount
     * const VolumeDiscount = await prisma.volumeDiscount.delete({
     *   where: {
     *     // ... filter to delete one VolumeDiscount
     *   }
     * })
     * 
     */
    delete<T extends VolumeDiscountDeleteArgs>(args: SelectSubset<T, VolumeDiscountDeleteArgs<ExtArgs>>): Prisma__VolumeDiscountClient<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VolumeDiscount.
     * @param {VolumeDiscountUpdateArgs} args - Arguments to update one VolumeDiscount.
     * @example
     * // Update one VolumeDiscount
     * const volumeDiscount = await prisma.volumeDiscount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VolumeDiscountUpdateArgs>(args: SelectSubset<T, VolumeDiscountUpdateArgs<ExtArgs>>): Prisma__VolumeDiscountClient<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VolumeDiscounts.
     * @param {VolumeDiscountDeleteManyArgs} args - Arguments to filter VolumeDiscounts to delete.
     * @example
     * // Delete a few VolumeDiscounts
     * const { count } = await prisma.volumeDiscount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VolumeDiscountDeleteManyArgs>(args?: SelectSubset<T, VolumeDiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VolumeDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeDiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VolumeDiscounts
     * const volumeDiscount = await prisma.volumeDiscount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VolumeDiscountUpdateManyArgs>(args: SelectSubset<T, VolumeDiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VolumeDiscount.
     * @param {VolumeDiscountUpsertArgs} args - Arguments to update or create a VolumeDiscount.
     * @example
     * // Update or create a VolumeDiscount
     * const volumeDiscount = await prisma.volumeDiscount.upsert({
     *   create: {
     *     // ... data to create a VolumeDiscount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VolumeDiscount we want to update
     *   }
     * })
     */
    upsert<T extends VolumeDiscountUpsertArgs>(args: SelectSubset<T, VolumeDiscountUpsertArgs<ExtArgs>>): Prisma__VolumeDiscountClient<$Result.GetResult<Prisma.$VolumeDiscountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VolumeDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeDiscountCountArgs} args - Arguments to filter VolumeDiscounts to count.
     * @example
     * // Count the number of VolumeDiscounts
     * const count = await prisma.volumeDiscount.count({
     *   where: {
     *     // ... the filter for the VolumeDiscounts we want to count
     *   }
     * })
    **/
    count<T extends VolumeDiscountCountArgs>(
      args?: Subset<T, VolumeDiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VolumeDiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VolumeDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeDiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VolumeDiscountAggregateArgs>(args: Subset<T, VolumeDiscountAggregateArgs>): Prisma.PrismaPromise<GetVolumeDiscountAggregateType<T>>

    /**
     * Group by VolumeDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VolumeDiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VolumeDiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VolumeDiscountGroupByArgs['orderBy'] }
        : { orderBy?: VolumeDiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VolumeDiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVolumeDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VolumeDiscount model
   */
  readonly fields: VolumeDiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VolumeDiscount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VolumeDiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    printSize<T extends PrintSizeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrintSizeDefaultArgs<ExtArgs>>): Prisma__PrintSizeClient<$Result.GetResult<Prisma.$PrintSizePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tier<T extends VolumeDiscount$tierArgs<ExtArgs> = {}>(args?: Subset<T, VolumeDiscount$tierArgs<ExtArgs>>): Prisma__QuantityTierClient<$Result.GetResult<Prisma.$QuantityTierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VolumeDiscount model
   */ 
  interface VolumeDiscountFieldRefs {
    readonly id: FieldRef<"VolumeDiscount", 'Int'>
    readonly printSizeId: FieldRef<"VolumeDiscount", 'Int'>
    readonly tierId: FieldRef<"VolumeDiscount", 'Int'>
    readonly minQuantity: FieldRef<"VolumeDiscount", 'Int'>
    readonly price: FieldRef<"VolumeDiscount", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * VolumeDiscount findUnique
   */
  export type VolumeDiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
    /**
     * Filter, which VolumeDiscount to fetch.
     */
    where: VolumeDiscountWhereUniqueInput
  }

  /**
   * VolumeDiscount findUniqueOrThrow
   */
  export type VolumeDiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
    /**
     * Filter, which VolumeDiscount to fetch.
     */
    where: VolumeDiscountWhereUniqueInput
  }

  /**
   * VolumeDiscount findFirst
   */
  export type VolumeDiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
    /**
     * Filter, which VolumeDiscount to fetch.
     */
    where?: VolumeDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolumeDiscounts to fetch.
     */
    orderBy?: VolumeDiscountOrderByWithRelationInput | VolumeDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolumeDiscounts.
     */
    cursor?: VolumeDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolumeDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolumeDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolumeDiscounts.
     */
    distinct?: VolumeDiscountScalarFieldEnum | VolumeDiscountScalarFieldEnum[]
  }

  /**
   * VolumeDiscount findFirstOrThrow
   */
  export type VolumeDiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
    /**
     * Filter, which VolumeDiscount to fetch.
     */
    where?: VolumeDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolumeDiscounts to fetch.
     */
    orderBy?: VolumeDiscountOrderByWithRelationInput | VolumeDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VolumeDiscounts.
     */
    cursor?: VolumeDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolumeDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolumeDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VolumeDiscounts.
     */
    distinct?: VolumeDiscountScalarFieldEnum | VolumeDiscountScalarFieldEnum[]
  }

  /**
   * VolumeDiscount findMany
   */
  export type VolumeDiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
    /**
     * Filter, which VolumeDiscounts to fetch.
     */
    where?: VolumeDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VolumeDiscounts to fetch.
     */
    orderBy?: VolumeDiscountOrderByWithRelationInput | VolumeDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VolumeDiscounts.
     */
    cursor?: VolumeDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VolumeDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VolumeDiscounts.
     */
    skip?: number
    distinct?: VolumeDiscountScalarFieldEnum | VolumeDiscountScalarFieldEnum[]
  }

  /**
   * VolumeDiscount create
   */
  export type VolumeDiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a VolumeDiscount.
     */
    data: XOR<VolumeDiscountCreateInput, VolumeDiscountUncheckedCreateInput>
  }

  /**
   * VolumeDiscount createMany
   */
  export type VolumeDiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VolumeDiscounts.
     */
    data: VolumeDiscountCreateManyInput | VolumeDiscountCreateManyInput[]
  }

  /**
   * VolumeDiscount createManyAndReturn
   */
  export type VolumeDiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VolumeDiscounts.
     */
    data: VolumeDiscountCreateManyInput | VolumeDiscountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VolumeDiscount update
   */
  export type VolumeDiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a VolumeDiscount.
     */
    data: XOR<VolumeDiscountUpdateInput, VolumeDiscountUncheckedUpdateInput>
    /**
     * Choose, which VolumeDiscount to update.
     */
    where: VolumeDiscountWhereUniqueInput
  }

  /**
   * VolumeDiscount updateMany
   */
  export type VolumeDiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VolumeDiscounts.
     */
    data: XOR<VolumeDiscountUpdateManyMutationInput, VolumeDiscountUncheckedUpdateManyInput>
    /**
     * Filter which VolumeDiscounts to update
     */
    where?: VolumeDiscountWhereInput
  }

  /**
   * VolumeDiscount upsert
   */
  export type VolumeDiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the VolumeDiscount to update in case it exists.
     */
    where: VolumeDiscountWhereUniqueInput
    /**
     * In case the VolumeDiscount found by the `where` argument doesn't exist, create a new VolumeDiscount with this data.
     */
    create: XOR<VolumeDiscountCreateInput, VolumeDiscountUncheckedCreateInput>
    /**
     * In case the VolumeDiscount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VolumeDiscountUpdateInput, VolumeDiscountUncheckedUpdateInput>
  }

  /**
   * VolumeDiscount delete
   */
  export type VolumeDiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
    /**
     * Filter which VolumeDiscount to delete.
     */
    where: VolumeDiscountWhereUniqueInput
  }

  /**
   * VolumeDiscount deleteMany
   */
  export type VolumeDiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VolumeDiscounts to delete
     */
    where?: VolumeDiscountWhereInput
  }

  /**
   * VolumeDiscount.tier
   */
  export type VolumeDiscount$tierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuantityTier
     */
    select?: QuantityTierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuantityTierInclude<ExtArgs> | null
    where?: QuantityTierWhereInput
  }

  /**
   * VolumeDiscount without action
   */
  export type VolumeDiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VolumeDiscount
     */
    select?: VolumeDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VolumeDiscountInclude<ExtArgs> | null
  }


  /**
   * Model GiftThreshold
   */

  export type AggregateGiftThreshold = {
    _count: GiftThresholdCountAggregateOutputType | null
    _avg: GiftThresholdAvgAggregateOutputType | null
    _sum: GiftThresholdSumAggregateOutputType | null
    _min: GiftThresholdMinAggregateOutputType | null
    _max: GiftThresholdMaxAggregateOutputType | null
  }

  export type GiftThresholdAvgAggregateOutputType = {
    id: number | null
    minAmount: number | null
  }

  export type GiftThresholdSumAggregateOutputType = {
    id: number | null
    minAmount: number | null
  }

  export type GiftThresholdMinAggregateOutputType = {
    id: number | null
    minAmount: number | null
    giftName: string | null
    isActive: boolean | null
  }

  export type GiftThresholdMaxAggregateOutputType = {
    id: number | null
    minAmount: number | null
    giftName: string | null
    isActive: boolean | null
  }

  export type GiftThresholdCountAggregateOutputType = {
    id: number
    minAmount: number
    giftName: number
    isActive: number
    _all: number
  }


  export type GiftThresholdAvgAggregateInputType = {
    id?: true
    minAmount?: true
  }

  export type GiftThresholdSumAggregateInputType = {
    id?: true
    minAmount?: true
  }

  export type GiftThresholdMinAggregateInputType = {
    id?: true
    minAmount?: true
    giftName?: true
    isActive?: true
  }

  export type GiftThresholdMaxAggregateInputType = {
    id?: true
    minAmount?: true
    giftName?: true
    isActive?: true
  }

  export type GiftThresholdCountAggregateInputType = {
    id?: true
    minAmount?: true
    giftName?: true
    isActive?: true
    _all?: true
  }

  export type GiftThresholdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GiftThreshold to aggregate.
     */
    where?: GiftThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftThresholds to fetch.
     */
    orderBy?: GiftThresholdOrderByWithRelationInput | GiftThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GiftThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GiftThresholds
    **/
    _count?: true | GiftThresholdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GiftThresholdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GiftThresholdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GiftThresholdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GiftThresholdMaxAggregateInputType
  }

  export type GetGiftThresholdAggregateType<T extends GiftThresholdAggregateArgs> = {
        [P in keyof T & keyof AggregateGiftThreshold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGiftThreshold[P]>
      : GetScalarType<T[P], AggregateGiftThreshold[P]>
  }




  export type GiftThresholdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiftThresholdWhereInput
    orderBy?: GiftThresholdOrderByWithAggregationInput | GiftThresholdOrderByWithAggregationInput[]
    by: GiftThresholdScalarFieldEnum[] | GiftThresholdScalarFieldEnum
    having?: GiftThresholdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GiftThresholdCountAggregateInputType | true
    _avg?: GiftThresholdAvgAggregateInputType
    _sum?: GiftThresholdSumAggregateInputType
    _min?: GiftThresholdMinAggregateInputType
    _max?: GiftThresholdMaxAggregateInputType
  }

  export type GiftThresholdGroupByOutputType = {
    id: number
    minAmount: number
    giftName: string
    isActive: boolean
    _count: GiftThresholdCountAggregateOutputType | null
    _avg: GiftThresholdAvgAggregateOutputType | null
    _sum: GiftThresholdSumAggregateOutputType | null
    _min: GiftThresholdMinAggregateOutputType | null
    _max: GiftThresholdMaxAggregateOutputType | null
  }

  type GetGiftThresholdGroupByPayload<T extends GiftThresholdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GiftThresholdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GiftThresholdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GiftThresholdGroupByOutputType[P]>
            : GetScalarType<T[P], GiftThresholdGroupByOutputType[P]>
        }
      >
    >


  export type GiftThresholdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    minAmount?: boolean
    giftName?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["giftThreshold"]>

  export type GiftThresholdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    minAmount?: boolean
    giftName?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["giftThreshold"]>

  export type GiftThresholdSelectScalar = {
    id?: boolean
    minAmount?: boolean
    giftName?: boolean
    isActive?: boolean
  }


  export type $GiftThresholdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GiftThreshold"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      minAmount: number
      giftName: string
      isActive: boolean
    }, ExtArgs["result"]["giftThreshold"]>
    composites: {}
  }

  type GiftThresholdGetPayload<S extends boolean | null | undefined | GiftThresholdDefaultArgs> = $Result.GetResult<Prisma.$GiftThresholdPayload, S>

  type GiftThresholdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GiftThresholdFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GiftThresholdCountAggregateInputType | true
    }

  export interface GiftThresholdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GiftThreshold'], meta: { name: 'GiftThreshold' } }
    /**
     * Find zero or one GiftThreshold that matches the filter.
     * @param {GiftThresholdFindUniqueArgs} args - Arguments to find a GiftThreshold
     * @example
     * // Get one GiftThreshold
     * const giftThreshold = await prisma.giftThreshold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GiftThresholdFindUniqueArgs>(args: SelectSubset<T, GiftThresholdFindUniqueArgs<ExtArgs>>): Prisma__GiftThresholdClient<$Result.GetResult<Prisma.$GiftThresholdPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GiftThreshold that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GiftThresholdFindUniqueOrThrowArgs} args - Arguments to find a GiftThreshold
     * @example
     * // Get one GiftThreshold
     * const giftThreshold = await prisma.giftThreshold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GiftThresholdFindUniqueOrThrowArgs>(args: SelectSubset<T, GiftThresholdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GiftThresholdClient<$Result.GetResult<Prisma.$GiftThresholdPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GiftThreshold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftThresholdFindFirstArgs} args - Arguments to find a GiftThreshold
     * @example
     * // Get one GiftThreshold
     * const giftThreshold = await prisma.giftThreshold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GiftThresholdFindFirstArgs>(args?: SelectSubset<T, GiftThresholdFindFirstArgs<ExtArgs>>): Prisma__GiftThresholdClient<$Result.GetResult<Prisma.$GiftThresholdPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GiftThreshold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftThresholdFindFirstOrThrowArgs} args - Arguments to find a GiftThreshold
     * @example
     * // Get one GiftThreshold
     * const giftThreshold = await prisma.giftThreshold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GiftThresholdFindFirstOrThrowArgs>(args?: SelectSubset<T, GiftThresholdFindFirstOrThrowArgs<ExtArgs>>): Prisma__GiftThresholdClient<$Result.GetResult<Prisma.$GiftThresholdPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GiftThresholds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftThresholdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GiftThresholds
     * const giftThresholds = await prisma.giftThreshold.findMany()
     * 
     * // Get first 10 GiftThresholds
     * const giftThresholds = await prisma.giftThreshold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const giftThresholdWithIdOnly = await prisma.giftThreshold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GiftThresholdFindManyArgs>(args?: SelectSubset<T, GiftThresholdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftThresholdPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GiftThreshold.
     * @param {GiftThresholdCreateArgs} args - Arguments to create a GiftThreshold.
     * @example
     * // Create one GiftThreshold
     * const GiftThreshold = await prisma.giftThreshold.create({
     *   data: {
     *     // ... data to create a GiftThreshold
     *   }
     * })
     * 
     */
    create<T extends GiftThresholdCreateArgs>(args: SelectSubset<T, GiftThresholdCreateArgs<ExtArgs>>): Prisma__GiftThresholdClient<$Result.GetResult<Prisma.$GiftThresholdPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GiftThresholds.
     * @param {GiftThresholdCreateManyArgs} args - Arguments to create many GiftThresholds.
     * @example
     * // Create many GiftThresholds
     * const giftThreshold = await prisma.giftThreshold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GiftThresholdCreateManyArgs>(args?: SelectSubset<T, GiftThresholdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GiftThresholds and returns the data saved in the database.
     * @param {GiftThresholdCreateManyAndReturnArgs} args - Arguments to create many GiftThresholds.
     * @example
     * // Create many GiftThresholds
     * const giftThreshold = await prisma.giftThreshold.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GiftThresholds and only return the `id`
     * const giftThresholdWithIdOnly = await prisma.giftThreshold.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GiftThresholdCreateManyAndReturnArgs>(args?: SelectSubset<T, GiftThresholdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftThresholdPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a GiftThreshold.
     * @param {GiftThresholdDeleteArgs} args - Arguments to delete one GiftThreshold.
     * @example
     * // Delete one GiftThreshold
     * const GiftThreshold = await prisma.giftThreshold.delete({
     *   where: {
     *     // ... filter to delete one GiftThreshold
     *   }
     * })
     * 
     */
    delete<T extends GiftThresholdDeleteArgs>(args: SelectSubset<T, GiftThresholdDeleteArgs<ExtArgs>>): Prisma__GiftThresholdClient<$Result.GetResult<Prisma.$GiftThresholdPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GiftThreshold.
     * @param {GiftThresholdUpdateArgs} args - Arguments to update one GiftThreshold.
     * @example
     * // Update one GiftThreshold
     * const giftThreshold = await prisma.giftThreshold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GiftThresholdUpdateArgs>(args: SelectSubset<T, GiftThresholdUpdateArgs<ExtArgs>>): Prisma__GiftThresholdClient<$Result.GetResult<Prisma.$GiftThresholdPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GiftThresholds.
     * @param {GiftThresholdDeleteManyArgs} args - Arguments to filter GiftThresholds to delete.
     * @example
     * // Delete a few GiftThresholds
     * const { count } = await prisma.giftThreshold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GiftThresholdDeleteManyArgs>(args?: SelectSubset<T, GiftThresholdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GiftThresholds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftThresholdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GiftThresholds
     * const giftThreshold = await prisma.giftThreshold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GiftThresholdUpdateManyArgs>(args: SelectSubset<T, GiftThresholdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GiftThreshold.
     * @param {GiftThresholdUpsertArgs} args - Arguments to update or create a GiftThreshold.
     * @example
     * // Update or create a GiftThreshold
     * const giftThreshold = await prisma.giftThreshold.upsert({
     *   create: {
     *     // ... data to create a GiftThreshold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GiftThreshold we want to update
     *   }
     * })
     */
    upsert<T extends GiftThresholdUpsertArgs>(args: SelectSubset<T, GiftThresholdUpsertArgs<ExtArgs>>): Prisma__GiftThresholdClient<$Result.GetResult<Prisma.$GiftThresholdPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GiftThresholds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftThresholdCountArgs} args - Arguments to filter GiftThresholds to count.
     * @example
     * // Count the number of GiftThresholds
     * const count = await prisma.giftThreshold.count({
     *   where: {
     *     // ... the filter for the GiftThresholds we want to count
     *   }
     * })
    **/
    count<T extends GiftThresholdCountArgs>(
      args?: Subset<T, GiftThresholdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GiftThresholdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GiftThreshold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftThresholdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GiftThresholdAggregateArgs>(args: Subset<T, GiftThresholdAggregateArgs>): Prisma.PrismaPromise<GetGiftThresholdAggregateType<T>>

    /**
     * Group by GiftThreshold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftThresholdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GiftThresholdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GiftThresholdGroupByArgs['orderBy'] }
        : { orderBy?: GiftThresholdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GiftThresholdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGiftThresholdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GiftThreshold model
   */
  readonly fields: GiftThresholdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GiftThreshold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GiftThresholdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GiftThreshold model
   */ 
  interface GiftThresholdFieldRefs {
    readonly id: FieldRef<"GiftThreshold", 'Int'>
    readonly minAmount: FieldRef<"GiftThreshold", 'Float'>
    readonly giftName: FieldRef<"GiftThreshold", 'String'>
    readonly isActive: FieldRef<"GiftThreshold", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * GiftThreshold findUnique
   */
  export type GiftThresholdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftThreshold
     */
    select?: GiftThresholdSelect<ExtArgs> | null
    /**
     * Filter, which GiftThreshold to fetch.
     */
    where: GiftThresholdWhereUniqueInput
  }

  /**
   * GiftThreshold findUniqueOrThrow
   */
  export type GiftThresholdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftThreshold
     */
    select?: GiftThresholdSelect<ExtArgs> | null
    /**
     * Filter, which GiftThreshold to fetch.
     */
    where: GiftThresholdWhereUniqueInput
  }

  /**
   * GiftThreshold findFirst
   */
  export type GiftThresholdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftThreshold
     */
    select?: GiftThresholdSelect<ExtArgs> | null
    /**
     * Filter, which GiftThreshold to fetch.
     */
    where?: GiftThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftThresholds to fetch.
     */
    orderBy?: GiftThresholdOrderByWithRelationInput | GiftThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GiftThresholds.
     */
    cursor?: GiftThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GiftThresholds.
     */
    distinct?: GiftThresholdScalarFieldEnum | GiftThresholdScalarFieldEnum[]
  }

  /**
   * GiftThreshold findFirstOrThrow
   */
  export type GiftThresholdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftThreshold
     */
    select?: GiftThresholdSelect<ExtArgs> | null
    /**
     * Filter, which GiftThreshold to fetch.
     */
    where?: GiftThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftThresholds to fetch.
     */
    orderBy?: GiftThresholdOrderByWithRelationInput | GiftThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GiftThresholds.
     */
    cursor?: GiftThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftThresholds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GiftThresholds.
     */
    distinct?: GiftThresholdScalarFieldEnum | GiftThresholdScalarFieldEnum[]
  }

  /**
   * GiftThreshold findMany
   */
  export type GiftThresholdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftThreshold
     */
    select?: GiftThresholdSelect<ExtArgs> | null
    /**
     * Filter, which GiftThresholds to fetch.
     */
    where?: GiftThresholdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GiftThresholds to fetch.
     */
    orderBy?: GiftThresholdOrderByWithRelationInput | GiftThresholdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GiftThresholds.
     */
    cursor?: GiftThresholdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GiftThresholds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GiftThresholds.
     */
    skip?: number
    distinct?: GiftThresholdScalarFieldEnum | GiftThresholdScalarFieldEnum[]
  }

  /**
   * GiftThreshold create
   */
  export type GiftThresholdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftThreshold
     */
    select?: GiftThresholdSelect<ExtArgs> | null
    /**
     * The data needed to create a GiftThreshold.
     */
    data: XOR<GiftThresholdCreateInput, GiftThresholdUncheckedCreateInput>
  }

  /**
   * GiftThreshold createMany
   */
  export type GiftThresholdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GiftThresholds.
     */
    data: GiftThresholdCreateManyInput | GiftThresholdCreateManyInput[]
  }

  /**
   * GiftThreshold createManyAndReturn
   */
  export type GiftThresholdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftThreshold
     */
    select?: GiftThresholdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many GiftThresholds.
     */
    data: GiftThresholdCreateManyInput | GiftThresholdCreateManyInput[]
  }

  /**
   * GiftThreshold update
   */
  export type GiftThresholdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftThreshold
     */
    select?: GiftThresholdSelect<ExtArgs> | null
    /**
     * The data needed to update a GiftThreshold.
     */
    data: XOR<GiftThresholdUpdateInput, GiftThresholdUncheckedUpdateInput>
    /**
     * Choose, which GiftThreshold to update.
     */
    where: GiftThresholdWhereUniqueInput
  }

  /**
   * GiftThreshold updateMany
   */
  export type GiftThresholdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GiftThresholds.
     */
    data: XOR<GiftThresholdUpdateManyMutationInput, GiftThresholdUncheckedUpdateManyInput>
    /**
     * Filter which GiftThresholds to update
     */
    where?: GiftThresholdWhereInput
  }

  /**
   * GiftThreshold upsert
   */
  export type GiftThresholdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftThreshold
     */
    select?: GiftThresholdSelect<ExtArgs> | null
    /**
     * The filter to search for the GiftThreshold to update in case it exists.
     */
    where: GiftThresholdWhereUniqueInput
    /**
     * In case the GiftThreshold found by the `where` argument doesn't exist, create a new GiftThreshold with this data.
     */
    create: XOR<GiftThresholdCreateInput, GiftThresholdUncheckedCreateInput>
    /**
     * In case the GiftThreshold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GiftThresholdUpdateInput, GiftThresholdUncheckedUpdateInput>
  }

  /**
   * GiftThreshold delete
   */
  export type GiftThresholdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftThreshold
     */
    select?: GiftThresholdSelect<ExtArgs> | null
    /**
     * Filter which GiftThreshold to delete.
     */
    where: GiftThresholdWhereUniqueInput
  }

  /**
   * GiftThreshold deleteMany
   */
  export type GiftThresholdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GiftThresholds to delete
     */
    where?: GiftThresholdWhereInput
  }

  /**
   * GiftThreshold without action
   */
  export type GiftThresholdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftThreshold
     */
    select?: GiftThresholdSelect<ExtArgs> | null
  }


  /**
   * Model PaperType
   */

  export type AggregatePaperType = {
    _count: PaperTypeCountAggregateOutputType | null
    _avg: PaperTypeAvgAggregateOutputType | null
    _sum: PaperTypeSumAggregateOutputType | null
    _min: PaperTypeMinAggregateOutputType | null
    _max: PaperTypeMaxAggregateOutputType | null
  }

  export type PaperTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type PaperTypeSumAggregateOutputType = {
    id: number | null
  }

  export type PaperTypeMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    isActive: boolean | null
  }

  export type PaperTypeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    isActive: boolean | null
  }

  export type PaperTypeCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    isActive: number
    _all: number
  }


  export type PaperTypeAvgAggregateInputType = {
    id?: true
  }

  export type PaperTypeSumAggregateInputType = {
    id?: true
  }

  export type PaperTypeMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    isActive?: true
  }

  export type PaperTypeMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    isActive?: true
  }

  export type PaperTypeCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    isActive?: true
    _all?: true
  }

  export type PaperTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaperType to aggregate.
     */
    where?: PaperTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaperTypes to fetch.
     */
    orderBy?: PaperTypeOrderByWithRelationInput | PaperTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaperTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaperTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaperTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaperTypes
    **/
    _count?: true | PaperTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaperTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaperTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaperTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaperTypeMaxAggregateInputType
  }

  export type GetPaperTypeAggregateType<T extends PaperTypeAggregateArgs> = {
        [P in keyof T & keyof AggregatePaperType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaperType[P]>
      : GetScalarType<T[P], AggregatePaperType[P]>
  }




  export type PaperTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaperTypeWhereInput
    orderBy?: PaperTypeOrderByWithAggregationInput | PaperTypeOrderByWithAggregationInput[]
    by: PaperTypeScalarFieldEnum[] | PaperTypeScalarFieldEnum
    having?: PaperTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaperTypeCountAggregateInputType | true
    _avg?: PaperTypeAvgAggregateInputType
    _sum?: PaperTypeSumAggregateInputType
    _min?: PaperTypeMinAggregateInputType
    _max?: PaperTypeMaxAggregateInputType
  }

  export type PaperTypeGroupByOutputType = {
    id: number
    name: string
    slug: string
    description: string | null
    isActive: boolean
    _count: PaperTypeCountAggregateOutputType | null
    _avg: PaperTypeAvgAggregateOutputType | null
    _sum: PaperTypeSumAggregateOutputType | null
    _min: PaperTypeMinAggregateOutputType | null
    _max: PaperTypeMaxAggregateOutputType | null
  }

  type GetPaperTypeGroupByPayload<T extends PaperTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaperTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaperTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaperTypeGroupByOutputType[P]>
            : GetScalarType<T[P], PaperTypeGroupByOutputType[P]>
        }
      >
    >


  export type PaperTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["paperType"]>

  export type PaperTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["paperType"]>

  export type PaperTypeSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    isActive?: boolean
  }


  export type $PaperTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaperType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      description: string | null
      isActive: boolean
    }, ExtArgs["result"]["paperType"]>
    composites: {}
  }

  type PaperTypeGetPayload<S extends boolean | null | undefined | PaperTypeDefaultArgs> = $Result.GetResult<Prisma.$PaperTypePayload, S>

  type PaperTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaperTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaperTypeCountAggregateInputType | true
    }

  export interface PaperTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaperType'], meta: { name: 'PaperType' } }
    /**
     * Find zero or one PaperType that matches the filter.
     * @param {PaperTypeFindUniqueArgs} args - Arguments to find a PaperType
     * @example
     * // Get one PaperType
     * const paperType = await prisma.paperType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaperTypeFindUniqueArgs>(args: SelectSubset<T, PaperTypeFindUniqueArgs<ExtArgs>>): Prisma__PaperTypeClient<$Result.GetResult<Prisma.$PaperTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaperType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaperTypeFindUniqueOrThrowArgs} args - Arguments to find a PaperType
     * @example
     * // Get one PaperType
     * const paperType = await prisma.paperType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaperTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, PaperTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaperTypeClient<$Result.GetResult<Prisma.$PaperTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaperType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperTypeFindFirstArgs} args - Arguments to find a PaperType
     * @example
     * // Get one PaperType
     * const paperType = await prisma.paperType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaperTypeFindFirstArgs>(args?: SelectSubset<T, PaperTypeFindFirstArgs<ExtArgs>>): Prisma__PaperTypeClient<$Result.GetResult<Prisma.$PaperTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaperType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperTypeFindFirstOrThrowArgs} args - Arguments to find a PaperType
     * @example
     * // Get one PaperType
     * const paperType = await prisma.paperType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaperTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, PaperTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaperTypeClient<$Result.GetResult<Prisma.$PaperTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaperTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaperTypes
     * const paperTypes = await prisma.paperType.findMany()
     * 
     * // Get first 10 PaperTypes
     * const paperTypes = await prisma.paperType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paperTypeWithIdOnly = await prisma.paperType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaperTypeFindManyArgs>(args?: SelectSubset<T, PaperTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaperTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaperType.
     * @param {PaperTypeCreateArgs} args - Arguments to create a PaperType.
     * @example
     * // Create one PaperType
     * const PaperType = await prisma.paperType.create({
     *   data: {
     *     // ... data to create a PaperType
     *   }
     * })
     * 
     */
    create<T extends PaperTypeCreateArgs>(args: SelectSubset<T, PaperTypeCreateArgs<ExtArgs>>): Prisma__PaperTypeClient<$Result.GetResult<Prisma.$PaperTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaperTypes.
     * @param {PaperTypeCreateManyArgs} args - Arguments to create many PaperTypes.
     * @example
     * // Create many PaperTypes
     * const paperType = await prisma.paperType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaperTypeCreateManyArgs>(args?: SelectSubset<T, PaperTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaperTypes and returns the data saved in the database.
     * @param {PaperTypeCreateManyAndReturnArgs} args - Arguments to create many PaperTypes.
     * @example
     * // Create many PaperTypes
     * const paperType = await prisma.paperType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaperTypes and only return the `id`
     * const paperTypeWithIdOnly = await prisma.paperType.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaperTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, PaperTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaperTypePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaperType.
     * @param {PaperTypeDeleteArgs} args - Arguments to delete one PaperType.
     * @example
     * // Delete one PaperType
     * const PaperType = await prisma.paperType.delete({
     *   where: {
     *     // ... filter to delete one PaperType
     *   }
     * })
     * 
     */
    delete<T extends PaperTypeDeleteArgs>(args: SelectSubset<T, PaperTypeDeleteArgs<ExtArgs>>): Prisma__PaperTypeClient<$Result.GetResult<Prisma.$PaperTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaperType.
     * @param {PaperTypeUpdateArgs} args - Arguments to update one PaperType.
     * @example
     * // Update one PaperType
     * const paperType = await prisma.paperType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaperTypeUpdateArgs>(args: SelectSubset<T, PaperTypeUpdateArgs<ExtArgs>>): Prisma__PaperTypeClient<$Result.GetResult<Prisma.$PaperTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaperTypes.
     * @param {PaperTypeDeleteManyArgs} args - Arguments to filter PaperTypes to delete.
     * @example
     * // Delete a few PaperTypes
     * const { count } = await prisma.paperType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaperTypeDeleteManyArgs>(args?: SelectSubset<T, PaperTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaperTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaperTypes
     * const paperType = await prisma.paperType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaperTypeUpdateManyArgs>(args: SelectSubset<T, PaperTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaperType.
     * @param {PaperTypeUpsertArgs} args - Arguments to update or create a PaperType.
     * @example
     * // Update or create a PaperType
     * const paperType = await prisma.paperType.upsert({
     *   create: {
     *     // ... data to create a PaperType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaperType we want to update
     *   }
     * })
     */
    upsert<T extends PaperTypeUpsertArgs>(args: SelectSubset<T, PaperTypeUpsertArgs<ExtArgs>>): Prisma__PaperTypeClient<$Result.GetResult<Prisma.$PaperTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaperTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperTypeCountArgs} args - Arguments to filter PaperTypes to count.
     * @example
     * // Count the number of PaperTypes
     * const count = await prisma.paperType.count({
     *   where: {
     *     // ... the filter for the PaperTypes we want to count
     *   }
     * })
    **/
    count<T extends PaperTypeCountArgs>(
      args?: Subset<T, PaperTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaperTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaperType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaperTypeAggregateArgs>(args: Subset<T, PaperTypeAggregateArgs>): Prisma.PrismaPromise<GetPaperTypeAggregateType<T>>

    /**
     * Group by PaperType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaperTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaperTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaperTypeGroupByArgs['orderBy'] }
        : { orderBy?: PaperTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaperTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaperTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaperType model
   */
  readonly fields: PaperTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaperType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaperTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaperType model
   */ 
  interface PaperTypeFieldRefs {
    readonly id: FieldRef<"PaperType", 'Int'>
    readonly name: FieldRef<"PaperType", 'String'>
    readonly slug: FieldRef<"PaperType", 'String'>
    readonly description: FieldRef<"PaperType", 'String'>
    readonly isActive: FieldRef<"PaperType", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PaperType findUnique
   */
  export type PaperTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperType
     */
    select?: PaperTypeSelect<ExtArgs> | null
    /**
     * Filter, which PaperType to fetch.
     */
    where: PaperTypeWhereUniqueInput
  }

  /**
   * PaperType findUniqueOrThrow
   */
  export type PaperTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperType
     */
    select?: PaperTypeSelect<ExtArgs> | null
    /**
     * Filter, which PaperType to fetch.
     */
    where: PaperTypeWhereUniqueInput
  }

  /**
   * PaperType findFirst
   */
  export type PaperTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperType
     */
    select?: PaperTypeSelect<ExtArgs> | null
    /**
     * Filter, which PaperType to fetch.
     */
    where?: PaperTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaperTypes to fetch.
     */
    orderBy?: PaperTypeOrderByWithRelationInput | PaperTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaperTypes.
     */
    cursor?: PaperTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaperTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaperTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaperTypes.
     */
    distinct?: PaperTypeScalarFieldEnum | PaperTypeScalarFieldEnum[]
  }

  /**
   * PaperType findFirstOrThrow
   */
  export type PaperTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperType
     */
    select?: PaperTypeSelect<ExtArgs> | null
    /**
     * Filter, which PaperType to fetch.
     */
    where?: PaperTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaperTypes to fetch.
     */
    orderBy?: PaperTypeOrderByWithRelationInput | PaperTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaperTypes.
     */
    cursor?: PaperTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaperTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaperTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaperTypes.
     */
    distinct?: PaperTypeScalarFieldEnum | PaperTypeScalarFieldEnum[]
  }

  /**
   * PaperType findMany
   */
  export type PaperTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperType
     */
    select?: PaperTypeSelect<ExtArgs> | null
    /**
     * Filter, which PaperTypes to fetch.
     */
    where?: PaperTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaperTypes to fetch.
     */
    orderBy?: PaperTypeOrderByWithRelationInput | PaperTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaperTypes.
     */
    cursor?: PaperTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaperTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaperTypes.
     */
    skip?: number
    distinct?: PaperTypeScalarFieldEnum | PaperTypeScalarFieldEnum[]
  }

  /**
   * PaperType create
   */
  export type PaperTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperType
     */
    select?: PaperTypeSelect<ExtArgs> | null
    /**
     * The data needed to create a PaperType.
     */
    data: XOR<PaperTypeCreateInput, PaperTypeUncheckedCreateInput>
  }

  /**
   * PaperType createMany
   */
  export type PaperTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaperTypes.
     */
    data: PaperTypeCreateManyInput | PaperTypeCreateManyInput[]
  }

  /**
   * PaperType createManyAndReturn
   */
  export type PaperTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperType
     */
    select?: PaperTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaperTypes.
     */
    data: PaperTypeCreateManyInput | PaperTypeCreateManyInput[]
  }

  /**
   * PaperType update
   */
  export type PaperTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperType
     */
    select?: PaperTypeSelect<ExtArgs> | null
    /**
     * The data needed to update a PaperType.
     */
    data: XOR<PaperTypeUpdateInput, PaperTypeUncheckedUpdateInput>
    /**
     * Choose, which PaperType to update.
     */
    where: PaperTypeWhereUniqueInput
  }

  /**
   * PaperType updateMany
   */
  export type PaperTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaperTypes.
     */
    data: XOR<PaperTypeUpdateManyMutationInput, PaperTypeUncheckedUpdateManyInput>
    /**
     * Filter which PaperTypes to update
     */
    where?: PaperTypeWhereInput
  }

  /**
   * PaperType upsert
   */
  export type PaperTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperType
     */
    select?: PaperTypeSelect<ExtArgs> | null
    /**
     * The filter to search for the PaperType to update in case it exists.
     */
    where: PaperTypeWhereUniqueInput
    /**
     * In case the PaperType found by the `where` argument doesn't exist, create a new PaperType with this data.
     */
    create: XOR<PaperTypeCreateInput, PaperTypeUncheckedCreateInput>
    /**
     * In case the PaperType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaperTypeUpdateInput, PaperTypeUncheckedUpdateInput>
  }

  /**
   * PaperType delete
   */
  export type PaperTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperType
     */
    select?: PaperTypeSelect<ExtArgs> | null
    /**
     * Filter which PaperType to delete.
     */
    where: PaperTypeWhereUniqueInput
  }

  /**
   * PaperType deleteMany
   */
  export type PaperTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaperTypes to delete
     */
    where?: PaperTypeWhereInput
  }

  /**
   * PaperType without action
   */
  export type PaperTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaperType
     */
    select?: PaperTypeSelect<ExtArgs> | null
  }


  /**
   * Model PrintOption
   */

  export type AggregatePrintOption = {
    _count: PrintOptionCountAggregateOutputType | null
    _avg: PrintOptionAvgAggregateOutputType | null
    _sum: PrintOptionSumAggregateOutputType | null
    _min: PrintOptionMinAggregateOutputType | null
    _max: PrintOptionMaxAggregateOutputType | null
  }

  export type PrintOptionAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type PrintOptionSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type PrintOptionMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    priceType: string | null
    price: number | null
    isActive: boolean | null
  }

  export type PrintOptionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    priceType: string | null
    price: number | null
    isActive: boolean | null
  }

  export type PrintOptionCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    priceType: number
    price: number
    isActive: number
    _all: number
  }


  export type PrintOptionAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type PrintOptionSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type PrintOptionMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    priceType?: true
    price?: true
    isActive?: true
  }

  export type PrintOptionMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    priceType?: true
    price?: true
    isActive?: true
  }

  export type PrintOptionCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    priceType?: true
    price?: true
    isActive?: true
    _all?: true
  }

  export type PrintOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrintOption to aggregate.
     */
    where?: PrintOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintOptions to fetch.
     */
    orderBy?: PrintOptionOrderByWithRelationInput | PrintOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrintOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrintOptions
    **/
    _count?: true | PrintOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrintOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrintOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrintOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrintOptionMaxAggregateInputType
  }

  export type GetPrintOptionAggregateType<T extends PrintOptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrintOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrintOption[P]>
      : GetScalarType<T[P], AggregatePrintOption[P]>
  }




  export type PrintOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrintOptionWhereInput
    orderBy?: PrintOptionOrderByWithAggregationInput | PrintOptionOrderByWithAggregationInput[]
    by: PrintOptionScalarFieldEnum[] | PrintOptionScalarFieldEnum
    having?: PrintOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrintOptionCountAggregateInputType | true
    _avg?: PrintOptionAvgAggregateInputType
    _sum?: PrintOptionSumAggregateInputType
    _min?: PrintOptionMinAggregateInputType
    _max?: PrintOptionMaxAggregateInputType
  }

  export type PrintOptionGroupByOutputType = {
    id: number
    name: string
    slug: string
    priceType: string
    price: number
    isActive: boolean
    _count: PrintOptionCountAggregateOutputType | null
    _avg: PrintOptionAvgAggregateOutputType | null
    _sum: PrintOptionSumAggregateOutputType | null
    _min: PrintOptionMinAggregateOutputType | null
    _max: PrintOptionMaxAggregateOutputType | null
  }

  type GetPrintOptionGroupByPayload<T extends PrintOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrintOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrintOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrintOptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrintOptionGroupByOutputType[P]>
        }
      >
    >


  export type PrintOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    priceType?: boolean
    price?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["printOption"]>

  export type PrintOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    priceType?: boolean
    price?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["printOption"]>

  export type PrintOptionSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    priceType?: boolean
    price?: boolean
    isActive?: boolean
  }


  export type $PrintOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrintOption"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      priceType: string
      price: number
      isActive: boolean
    }, ExtArgs["result"]["printOption"]>
    composites: {}
  }

  type PrintOptionGetPayload<S extends boolean | null | undefined | PrintOptionDefaultArgs> = $Result.GetResult<Prisma.$PrintOptionPayload, S>

  type PrintOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrintOptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrintOptionCountAggregateInputType | true
    }

  export interface PrintOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrintOption'], meta: { name: 'PrintOption' } }
    /**
     * Find zero or one PrintOption that matches the filter.
     * @param {PrintOptionFindUniqueArgs} args - Arguments to find a PrintOption
     * @example
     * // Get one PrintOption
     * const printOption = await prisma.printOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrintOptionFindUniqueArgs>(args: SelectSubset<T, PrintOptionFindUniqueArgs<ExtArgs>>): Prisma__PrintOptionClient<$Result.GetResult<Prisma.$PrintOptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PrintOption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrintOptionFindUniqueOrThrowArgs} args - Arguments to find a PrintOption
     * @example
     * // Get one PrintOption
     * const printOption = await prisma.printOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrintOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrintOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrintOptionClient<$Result.GetResult<Prisma.$PrintOptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PrintOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOptionFindFirstArgs} args - Arguments to find a PrintOption
     * @example
     * // Get one PrintOption
     * const printOption = await prisma.printOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrintOptionFindFirstArgs>(args?: SelectSubset<T, PrintOptionFindFirstArgs<ExtArgs>>): Prisma__PrintOptionClient<$Result.GetResult<Prisma.$PrintOptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PrintOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOptionFindFirstOrThrowArgs} args - Arguments to find a PrintOption
     * @example
     * // Get one PrintOption
     * const printOption = await prisma.printOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrintOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrintOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrintOptionClient<$Result.GetResult<Prisma.$PrintOptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PrintOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrintOptions
     * const printOptions = await prisma.printOption.findMany()
     * 
     * // Get first 10 PrintOptions
     * const printOptions = await prisma.printOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const printOptionWithIdOnly = await prisma.printOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrintOptionFindManyArgs>(args?: SelectSubset<T, PrintOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintOptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PrintOption.
     * @param {PrintOptionCreateArgs} args - Arguments to create a PrintOption.
     * @example
     * // Create one PrintOption
     * const PrintOption = await prisma.printOption.create({
     *   data: {
     *     // ... data to create a PrintOption
     *   }
     * })
     * 
     */
    create<T extends PrintOptionCreateArgs>(args: SelectSubset<T, PrintOptionCreateArgs<ExtArgs>>): Prisma__PrintOptionClient<$Result.GetResult<Prisma.$PrintOptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PrintOptions.
     * @param {PrintOptionCreateManyArgs} args - Arguments to create many PrintOptions.
     * @example
     * // Create many PrintOptions
     * const printOption = await prisma.printOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrintOptionCreateManyArgs>(args?: SelectSubset<T, PrintOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrintOptions and returns the data saved in the database.
     * @param {PrintOptionCreateManyAndReturnArgs} args - Arguments to create many PrintOptions.
     * @example
     * // Create many PrintOptions
     * const printOption = await prisma.printOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrintOptions and only return the `id`
     * const printOptionWithIdOnly = await prisma.printOption.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrintOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrintOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrintOptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PrintOption.
     * @param {PrintOptionDeleteArgs} args - Arguments to delete one PrintOption.
     * @example
     * // Delete one PrintOption
     * const PrintOption = await prisma.printOption.delete({
     *   where: {
     *     // ... filter to delete one PrintOption
     *   }
     * })
     * 
     */
    delete<T extends PrintOptionDeleteArgs>(args: SelectSubset<T, PrintOptionDeleteArgs<ExtArgs>>): Prisma__PrintOptionClient<$Result.GetResult<Prisma.$PrintOptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PrintOption.
     * @param {PrintOptionUpdateArgs} args - Arguments to update one PrintOption.
     * @example
     * // Update one PrintOption
     * const printOption = await prisma.printOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrintOptionUpdateArgs>(args: SelectSubset<T, PrintOptionUpdateArgs<ExtArgs>>): Prisma__PrintOptionClient<$Result.GetResult<Prisma.$PrintOptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PrintOptions.
     * @param {PrintOptionDeleteManyArgs} args - Arguments to filter PrintOptions to delete.
     * @example
     * // Delete a few PrintOptions
     * const { count } = await prisma.printOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrintOptionDeleteManyArgs>(args?: SelectSubset<T, PrintOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrintOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrintOptions
     * const printOption = await prisma.printOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrintOptionUpdateManyArgs>(args: SelectSubset<T, PrintOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrintOption.
     * @param {PrintOptionUpsertArgs} args - Arguments to update or create a PrintOption.
     * @example
     * // Update or create a PrintOption
     * const printOption = await prisma.printOption.upsert({
     *   create: {
     *     // ... data to create a PrintOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrintOption we want to update
     *   }
     * })
     */
    upsert<T extends PrintOptionUpsertArgs>(args: SelectSubset<T, PrintOptionUpsertArgs<ExtArgs>>): Prisma__PrintOptionClient<$Result.GetResult<Prisma.$PrintOptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PrintOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOptionCountArgs} args - Arguments to filter PrintOptions to count.
     * @example
     * // Count the number of PrintOptions
     * const count = await prisma.printOption.count({
     *   where: {
     *     // ... the filter for the PrintOptions we want to count
     *   }
     * })
    **/
    count<T extends PrintOptionCountArgs>(
      args?: Subset<T, PrintOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrintOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrintOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrintOptionAggregateArgs>(args: Subset<T, PrintOptionAggregateArgs>): Prisma.PrismaPromise<GetPrintOptionAggregateType<T>>

    /**
     * Group by PrintOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrintOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrintOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrintOptionGroupByArgs['orderBy'] }
        : { orderBy?: PrintOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrintOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrintOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrintOption model
   */
  readonly fields: PrintOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrintOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrintOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrintOption model
   */ 
  interface PrintOptionFieldRefs {
    readonly id: FieldRef<"PrintOption", 'Int'>
    readonly name: FieldRef<"PrintOption", 'String'>
    readonly slug: FieldRef<"PrintOption", 'String'>
    readonly priceType: FieldRef<"PrintOption", 'String'>
    readonly price: FieldRef<"PrintOption", 'Float'>
    readonly isActive: FieldRef<"PrintOption", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PrintOption findUnique
   */
  export type PrintOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOption
     */
    select?: PrintOptionSelect<ExtArgs> | null
    /**
     * Filter, which PrintOption to fetch.
     */
    where: PrintOptionWhereUniqueInput
  }

  /**
   * PrintOption findUniqueOrThrow
   */
  export type PrintOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOption
     */
    select?: PrintOptionSelect<ExtArgs> | null
    /**
     * Filter, which PrintOption to fetch.
     */
    where: PrintOptionWhereUniqueInput
  }

  /**
   * PrintOption findFirst
   */
  export type PrintOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOption
     */
    select?: PrintOptionSelect<ExtArgs> | null
    /**
     * Filter, which PrintOption to fetch.
     */
    where?: PrintOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintOptions to fetch.
     */
    orderBy?: PrintOptionOrderByWithRelationInput | PrintOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrintOptions.
     */
    cursor?: PrintOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrintOptions.
     */
    distinct?: PrintOptionScalarFieldEnum | PrintOptionScalarFieldEnum[]
  }

  /**
   * PrintOption findFirstOrThrow
   */
  export type PrintOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOption
     */
    select?: PrintOptionSelect<ExtArgs> | null
    /**
     * Filter, which PrintOption to fetch.
     */
    where?: PrintOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintOptions to fetch.
     */
    orderBy?: PrintOptionOrderByWithRelationInput | PrintOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrintOptions.
     */
    cursor?: PrintOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrintOptions.
     */
    distinct?: PrintOptionScalarFieldEnum | PrintOptionScalarFieldEnum[]
  }

  /**
   * PrintOption findMany
   */
  export type PrintOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOption
     */
    select?: PrintOptionSelect<ExtArgs> | null
    /**
     * Filter, which PrintOptions to fetch.
     */
    where?: PrintOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrintOptions to fetch.
     */
    orderBy?: PrintOptionOrderByWithRelationInput | PrintOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrintOptions.
     */
    cursor?: PrintOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrintOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrintOptions.
     */
    skip?: number
    distinct?: PrintOptionScalarFieldEnum | PrintOptionScalarFieldEnum[]
  }

  /**
   * PrintOption create
   */
  export type PrintOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOption
     */
    select?: PrintOptionSelect<ExtArgs> | null
    /**
     * The data needed to create a PrintOption.
     */
    data: XOR<PrintOptionCreateInput, PrintOptionUncheckedCreateInput>
  }

  /**
   * PrintOption createMany
   */
  export type PrintOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrintOptions.
     */
    data: PrintOptionCreateManyInput | PrintOptionCreateManyInput[]
  }

  /**
   * PrintOption createManyAndReturn
   */
  export type PrintOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOption
     */
    select?: PrintOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PrintOptions.
     */
    data: PrintOptionCreateManyInput | PrintOptionCreateManyInput[]
  }

  /**
   * PrintOption update
   */
  export type PrintOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOption
     */
    select?: PrintOptionSelect<ExtArgs> | null
    /**
     * The data needed to update a PrintOption.
     */
    data: XOR<PrintOptionUpdateInput, PrintOptionUncheckedUpdateInput>
    /**
     * Choose, which PrintOption to update.
     */
    where: PrintOptionWhereUniqueInput
  }

  /**
   * PrintOption updateMany
   */
  export type PrintOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrintOptions.
     */
    data: XOR<PrintOptionUpdateManyMutationInput, PrintOptionUncheckedUpdateManyInput>
    /**
     * Filter which PrintOptions to update
     */
    where?: PrintOptionWhereInput
  }

  /**
   * PrintOption upsert
   */
  export type PrintOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOption
     */
    select?: PrintOptionSelect<ExtArgs> | null
    /**
     * The filter to search for the PrintOption to update in case it exists.
     */
    where: PrintOptionWhereUniqueInput
    /**
     * In case the PrintOption found by the `where` argument doesn't exist, create a new PrintOption with this data.
     */
    create: XOR<PrintOptionCreateInput, PrintOptionUncheckedCreateInput>
    /**
     * In case the PrintOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrintOptionUpdateInput, PrintOptionUncheckedUpdateInput>
  }

  /**
   * PrintOption delete
   */
  export type PrintOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOption
     */
    select?: PrintOptionSelect<ExtArgs> | null
    /**
     * Filter which PrintOption to delete.
     */
    where: PrintOptionWhereUniqueInput
  }

  /**
   * PrintOption deleteMany
   */
  export type PrintOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrintOptions to delete
     */
    where?: PrintOptionWhereInput
  }

  /**
   * PrintOption without action
   */
  export type PrintOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrintOption
     */
    select?: PrintOptionSelect<ExtArgs> | null
  }


  /**
   * Model MagnetPrice
   */

  export type AggregateMagnetPrice = {
    _count: MagnetPriceCountAggregateOutputType | null
    _avg: MagnetPriceAvgAggregateOutputType | null
    _sum: MagnetPriceSumAggregateOutputType | null
    _min: MagnetPriceMinAggregateOutputType | null
    _max: MagnetPriceMaxAggregateOutputType | null
  }

  export type MagnetPriceAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type MagnetPriceSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type MagnetPriceMinAggregateOutputType = {
    id: number | null
    sizeSlug: string | null
    price: number | null
    isActive: boolean | null
  }

  export type MagnetPriceMaxAggregateOutputType = {
    id: number | null
    sizeSlug: string | null
    price: number | null
    isActive: boolean | null
  }

  export type MagnetPriceCountAggregateOutputType = {
    id: number
    sizeSlug: number
    price: number
    isActive: number
    _all: number
  }


  export type MagnetPriceAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type MagnetPriceSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type MagnetPriceMinAggregateInputType = {
    id?: true
    sizeSlug?: true
    price?: true
    isActive?: true
  }

  export type MagnetPriceMaxAggregateInputType = {
    id?: true
    sizeSlug?: true
    price?: true
    isActive?: true
  }

  export type MagnetPriceCountAggregateInputType = {
    id?: true
    sizeSlug?: true
    price?: true
    isActive?: true
    _all?: true
  }

  export type MagnetPriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagnetPrice to aggregate.
     */
    where?: MagnetPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagnetPrices to fetch.
     */
    orderBy?: MagnetPriceOrderByWithRelationInput | MagnetPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MagnetPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagnetPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagnetPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MagnetPrices
    **/
    _count?: true | MagnetPriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MagnetPriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MagnetPriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagnetPriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagnetPriceMaxAggregateInputType
  }

  export type GetMagnetPriceAggregateType<T extends MagnetPriceAggregateArgs> = {
        [P in keyof T & keyof AggregateMagnetPrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagnetPrice[P]>
      : GetScalarType<T[P], AggregateMagnetPrice[P]>
  }




  export type MagnetPriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagnetPriceWhereInput
    orderBy?: MagnetPriceOrderByWithAggregationInput | MagnetPriceOrderByWithAggregationInput[]
    by: MagnetPriceScalarFieldEnum[] | MagnetPriceScalarFieldEnum
    having?: MagnetPriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagnetPriceCountAggregateInputType | true
    _avg?: MagnetPriceAvgAggregateInputType
    _sum?: MagnetPriceSumAggregateInputType
    _min?: MagnetPriceMinAggregateInputType
    _max?: MagnetPriceMaxAggregateInputType
  }

  export type MagnetPriceGroupByOutputType = {
    id: number
    sizeSlug: string
    price: number
    isActive: boolean
    _count: MagnetPriceCountAggregateOutputType | null
    _avg: MagnetPriceAvgAggregateOutputType | null
    _sum: MagnetPriceSumAggregateOutputType | null
    _min: MagnetPriceMinAggregateOutputType | null
    _max: MagnetPriceMaxAggregateOutputType | null
  }

  type GetMagnetPriceGroupByPayload<T extends MagnetPriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagnetPriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagnetPriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagnetPriceGroupByOutputType[P]>
            : GetScalarType<T[P], MagnetPriceGroupByOutputType[P]>
        }
      >
    >


  export type MagnetPriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sizeSlug?: boolean
    price?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["magnetPrice"]>

  export type MagnetPriceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sizeSlug?: boolean
    price?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["magnetPrice"]>

  export type MagnetPriceSelectScalar = {
    id?: boolean
    sizeSlug?: boolean
    price?: boolean
    isActive?: boolean
  }


  export type $MagnetPricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MagnetPrice"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sizeSlug: string
      price: number
      isActive: boolean
    }, ExtArgs["result"]["magnetPrice"]>
    composites: {}
  }

  type MagnetPriceGetPayload<S extends boolean | null | undefined | MagnetPriceDefaultArgs> = $Result.GetResult<Prisma.$MagnetPricePayload, S>

  type MagnetPriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MagnetPriceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MagnetPriceCountAggregateInputType | true
    }

  export interface MagnetPriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MagnetPrice'], meta: { name: 'MagnetPrice' } }
    /**
     * Find zero or one MagnetPrice that matches the filter.
     * @param {MagnetPriceFindUniqueArgs} args - Arguments to find a MagnetPrice
     * @example
     * // Get one MagnetPrice
     * const magnetPrice = await prisma.magnetPrice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MagnetPriceFindUniqueArgs>(args: SelectSubset<T, MagnetPriceFindUniqueArgs<ExtArgs>>): Prisma__MagnetPriceClient<$Result.GetResult<Prisma.$MagnetPricePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MagnetPrice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MagnetPriceFindUniqueOrThrowArgs} args - Arguments to find a MagnetPrice
     * @example
     * // Get one MagnetPrice
     * const magnetPrice = await prisma.magnetPrice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MagnetPriceFindUniqueOrThrowArgs>(args: SelectSubset<T, MagnetPriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MagnetPriceClient<$Result.GetResult<Prisma.$MagnetPricePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MagnetPrice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnetPriceFindFirstArgs} args - Arguments to find a MagnetPrice
     * @example
     * // Get one MagnetPrice
     * const magnetPrice = await prisma.magnetPrice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MagnetPriceFindFirstArgs>(args?: SelectSubset<T, MagnetPriceFindFirstArgs<ExtArgs>>): Prisma__MagnetPriceClient<$Result.GetResult<Prisma.$MagnetPricePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MagnetPrice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnetPriceFindFirstOrThrowArgs} args - Arguments to find a MagnetPrice
     * @example
     * // Get one MagnetPrice
     * const magnetPrice = await prisma.magnetPrice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MagnetPriceFindFirstOrThrowArgs>(args?: SelectSubset<T, MagnetPriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MagnetPriceClient<$Result.GetResult<Prisma.$MagnetPricePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MagnetPrices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnetPriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MagnetPrices
     * const magnetPrices = await prisma.magnetPrice.findMany()
     * 
     * // Get first 10 MagnetPrices
     * const magnetPrices = await prisma.magnetPrice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const magnetPriceWithIdOnly = await prisma.magnetPrice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MagnetPriceFindManyArgs>(args?: SelectSubset<T, MagnetPriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagnetPricePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MagnetPrice.
     * @param {MagnetPriceCreateArgs} args - Arguments to create a MagnetPrice.
     * @example
     * // Create one MagnetPrice
     * const MagnetPrice = await prisma.magnetPrice.create({
     *   data: {
     *     // ... data to create a MagnetPrice
     *   }
     * })
     * 
     */
    create<T extends MagnetPriceCreateArgs>(args: SelectSubset<T, MagnetPriceCreateArgs<ExtArgs>>): Prisma__MagnetPriceClient<$Result.GetResult<Prisma.$MagnetPricePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MagnetPrices.
     * @param {MagnetPriceCreateManyArgs} args - Arguments to create many MagnetPrices.
     * @example
     * // Create many MagnetPrices
     * const magnetPrice = await prisma.magnetPrice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MagnetPriceCreateManyArgs>(args?: SelectSubset<T, MagnetPriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MagnetPrices and returns the data saved in the database.
     * @param {MagnetPriceCreateManyAndReturnArgs} args - Arguments to create many MagnetPrices.
     * @example
     * // Create many MagnetPrices
     * const magnetPrice = await prisma.magnetPrice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MagnetPrices and only return the `id`
     * const magnetPriceWithIdOnly = await prisma.magnetPrice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MagnetPriceCreateManyAndReturnArgs>(args?: SelectSubset<T, MagnetPriceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagnetPricePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MagnetPrice.
     * @param {MagnetPriceDeleteArgs} args - Arguments to delete one MagnetPrice.
     * @example
     * // Delete one MagnetPrice
     * const MagnetPrice = await prisma.magnetPrice.delete({
     *   where: {
     *     // ... filter to delete one MagnetPrice
     *   }
     * })
     * 
     */
    delete<T extends MagnetPriceDeleteArgs>(args: SelectSubset<T, MagnetPriceDeleteArgs<ExtArgs>>): Prisma__MagnetPriceClient<$Result.GetResult<Prisma.$MagnetPricePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MagnetPrice.
     * @param {MagnetPriceUpdateArgs} args - Arguments to update one MagnetPrice.
     * @example
     * // Update one MagnetPrice
     * const magnetPrice = await prisma.magnetPrice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MagnetPriceUpdateArgs>(args: SelectSubset<T, MagnetPriceUpdateArgs<ExtArgs>>): Prisma__MagnetPriceClient<$Result.GetResult<Prisma.$MagnetPricePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MagnetPrices.
     * @param {MagnetPriceDeleteManyArgs} args - Arguments to filter MagnetPrices to delete.
     * @example
     * // Delete a few MagnetPrices
     * const { count } = await prisma.magnetPrice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MagnetPriceDeleteManyArgs>(args?: SelectSubset<T, MagnetPriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagnetPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnetPriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MagnetPrices
     * const magnetPrice = await prisma.magnetPrice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MagnetPriceUpdateManyArgs>(args: SelectSubset<T, MagnetPriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MagnetPrice.
     * @param {MagnetPriceUpsertArgs} args - Arguments to update or create a MagnetPrice.
     * @example
     * // Update or create a MagnetPrice
     * const magnetPrice = await prisma.magnetPrice.upsert({
     *   create: {
     *     // ... data to create a MagnetPrice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MagnetPrice we want to update
     *   }
     * })
     */
    upsert<T extends MagnetPriceUpsertArgs>(args: SelectSubset<T, MagnetPriceUpsertArgs<ExtArgs>>): Prisma__MagnetPriceClient<$Result.GetResult<Prisma.$MagnetPricePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MagnetPrices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnetPriceCountArgs} args - Arguments to filter MagnetPrices to count.
     * @example
     * // Count the number of MagnetPrices
     * const count = await prisma.magnetPrice.count({
     *   where: {
     *     // ... the filter for the MagnetPrices we want to count
     *   }
     * })
    **/
    count<T extends MagnetPriceCountArgs>(
      args?: Subset<T, MagnetPriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagnetPriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MagnetPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnetPriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagnetPriceAggregateArgs>(args: Subset<T, MagnetPriceAggregateArgs>): Prisma.PrismaPromise<GetMagnetPriceAggregateType<T>>

    /**
     * Group by MagnetPrice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnetPriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MagnetPriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MagnetPriceGroupByArgs['orderBy'] }
        : { orderBy?: MagnetPriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MagnetPriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagnetPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MagnetPrice model
   */
  readonly fields: MagnetPriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MagnetPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MagnetPriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MagnetPrice model
   */ 
  interface MagnetPriceFieldRefs {
    readonly id: FieldRef<"MagnetPrice", 'Int'>
    readonly sizeSlug: FieldRef<"MagnetPrice", 'String'>
    readonly price: FieldRef<"MagnetPrice", 'Float'>
    readonly isActive: FieldRef<"MagnetPrice", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * MagnetPrice findUnique
   */
  export type MagnetPriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagnetPrice
     */
    select?: MagnetPriceSelect<ExtArgs> | null
    /**
     * Filter, which MagnetPrice to fetch.
     */
    where: MagnetPriceWhereUniqueInput
  }

  /**
   * MagnetPrice findUniqueOrThrow
   */
  export type MagnetPriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagnetPrice
     */
    select?: MagnetPriceSelect<ExtArgs> | null
    /**
     * Filter, which MagnetPrice to fetch.
     */
    where: MagnetPriceWhereUniqueInput
  }

  /**
   * MagnetPrice findFirst
   */
  export type MagnetPriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagnetPrice
     */
    select?: MagnetPriceSelect<ExtArgs> | null
    /**
     * Filter, which MagnetPrice to fetch.
     */
    where?: MagnetPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagnetPrices to fetch.
     */
    orderBy?: MagnetPriceOrderByWithRelationInput | MagnetPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagnetPrices.
     */
    cursor?: MagnetPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagnetPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagnetPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagnetPrices.
     */
    distinct?: MagnetPriceScalarFieldEnum | MagnetPriceScalarFieldEnum[]
  }

  /**
   * MagnetPrice findFirstOrThrow
   */
  export type MagnetPriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagnetPrice
     */
    select?: MagnetPriceSelect<ExtArgs> | null
    /**
     * Filter, which MagnetPrice to fetch.
     */
    where?: MagnetPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagnetPrices to fetch.
     */
    orderBy?: MagnetPriceOrderByWithRelationInput | MagnetPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagnetPrices.
     */
    cursor?: MagnetPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagnetPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagnetPrices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagnetPrices.
     */
    distinct?: MagnetPriceScalarFieldEnum | MagnetPriceScalarFieldEnum[]
  }

  /**
   * MagnetPrice findMany
   */
  export type MagnetPriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagnetPrice
     */
    select?: MagnetPriceSelect<ExtArgs> | null
    /**
     * Filter, which MagnetPrices to fetch.
     */
    where?: MagnetPriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagnetPrices to fetch.
     */
    orderBy?: MagnetPriceOrderByWithRelationInput | MagnetPriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MagnetPrices.
     */
    cursor?: MagnetPriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagnetPrices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagnetPrices.
     */
    skip?: number
    distinct?: MagnetPriceScalarFieldEnum | MagnetPriceScalarFieldEnum[]
  }

  /**
   * MagnetPrice create
   */
  export type MagnetPriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagnetPrice
     */
    select?: MagnetPriceSelect<ExtArgs> | null
    /**
     * The data needed to create a MagnetPrice.
     */
    data: XOR<MagnetPriceCreateInput, MagnetPriceUncheckedCreateInput>
  }

  /**
   * MagnetPrice createMany
   */
  export type MagnetPriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MagnetPrices.
     */
    data: MagnetPriceCreateManyInput | MagnetPriceCreateManyInput[]
  }

  /**
   * MagnetPrice createManyAndReturn
   */
  export type MagnetPriceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagnetPrice
     */
    select?: MagnetPriceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MagnetPrices.
     */
    data: MagnetPriceCreateManyInput | MagnetPriceCreateManyInput[]
  }

  /**
   * MagnetPrice update
   */
  export type MagnetPriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagnetPrice
     */
    select?: MagnetPriceSelect<ExtArgs> | null
    /**
     * The data needed to update a MagnetPrice.
     */
    data: XOR<MagnetPriceUpdateInput, MagnetPriceUncheckedUpdateInput>
    /**
     * Choose, which MagnetPrice to update.
     */
    where: MagnetPriceWhereUniqueInput
  }

  /**
   * MagnetPrice updateMany
   */
  export type MagnetPriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MagnetPrices.
     */
    data: XOR<MagnetPriceUpdateManyMutationInput, MagnetPriceUncheckedUpdateManyInput>
    /**
     * Filter which MagnetPrices to update
     */
    where?: MagnetPriceWhereInput
  }

  /**
   * MagnetPrice upsert
   */
  export type MagnetPriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagnetPrice
     */
    select?: MagnetPriceSelect<ExtArgs> | null
    /**
     * The filter to search for the MagnetPrice to update in case it exists.
     */
    where: MagnetPriceWhereUniqueInput
    /**
     * In case the MagnetPrice found by the `where` argument doesn't exist, create a new MagnetPrice with this data.
     */
    create: XOR<MagnetPriceCreateInput, MagnetPriceUncheckedCreateInput>
    /**
     * In case the MagnetPrice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MagnetPriceUpdateInput, MagnetPriceUncheckedUpdateInput>
  }

  /**
   * MagnetPrice delete
   */
  export type MagnetPriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagnetPrice
     */
    select?: MagnetPriceSelect<ExtArgs> | null
    /**
     * Filter which MagnetPrice to delete.
     */
    where: MagnetPriceWhereUniqueInput
  }

  /**
   * MagnetPrice deleteMany
   */
  export type MagnetPriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagnetPrices to delete
     */
    where?: MagnetPriceWhereInput
  }

  /**
   * MagnetPrice without action
   */
  export type MagnetPriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagnetPrice
     */
    select?: MagnetPriceSelect<ExtArgs> | null
  }


  /**
   * Model DeliveryOption
   */

  export type AggregateDeliveryOption = {
    _count: DeliveryOptionCountAggregateOutputType | null
    _avg: DeliveryOptionAvgAggregateOutputType | null
    _sum: DeliveryOptionSumAggregateOutputType | null
    _min: DeliveryOptionMinAggregateOutputType | null
    _max: DeliveryOptionMaxAggregateOutputType | null
  }

  export type DeliveryOptionAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type DeliveryOptionSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type DeliveryOptionMinAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    price: number | null
    description: string | null
    isActive: boolean | null
  }

  export type DeliveryOptionMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    name: string | null
    price: number | null
    description: string | null
    isActive: boolean | null
  }

  export type DeliveryOptionCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    price: number
    description: number
    isActive: number
    _all: number
  }


  export type DeliveryOptionAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type DeliveryOptionSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type DeliveryOptionMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    price?: true
    description?: true
    isActive?: true
  }

  export type DeliveryOptionMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    price?: true
    description?: true
    isActive?: true
  }

  export type DeliveryOptionCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    price?: true
    description?: true
    isActive?: true
    _all?: true
  }

  export type DeliveryOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryOption to aggregate.
     */
    where?: DeliveryOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryOptions to fetch.
     */
    orderBy?: DeliveryOptionOrderByWithRelationInput | DeliveryOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryOptions
    **/
    _count?: true | DeliveryOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryOptionMaxAggregateInputType
  }

  export type GetDeliveryOptionAggregateType<T extends DeliveryOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryOption[P]>
      : GetScalarType<T[P], AggregateDeliveryOption[P]>
  }




  export type DeliveryOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryOptionWhereInput
    orderBy?: DeliveryOptionOrderByWithAggregationInput | DeliveryOptionOrderByWithAggregationInput[]
    by: DeliveryOptionScalarFieldEnum[] | DeliveryOptionScalarFieldEnum
    having?: DeliveryOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryOptionCountAggregateInputType | true
    _avg?: DeliveryOptionAvgAggregateInputType
    _sum?: DeliveryOptionSumAggregateInputType
    _min?: DeliveryOptionMinAggregateInputType
    _max?: DeliveryOptionMaxAggregateInputType
  }

  export type DeliveryOptionGroupByOutputType = {
    id: number
    slug: string
    name: string
    price: number
    description: string | null
    isActive: boolean
    _count: DeliveryOptionCountAggregateOutputType | null
    _avg: DeliveryOptionAvgAggregateOutputType | null
    _sum: DeliveryOptionSumAggregateOutputType | null
    _min: DeliveryOptionMinAggregateOutputType | null
    _max: DeliveryOptionMaxAggregateOutputType | null
  }

  type GetDeliveryOptionGroupByPayload<T extends DeliveryOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryOptionGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryOptionGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["deliveryOption"]>

  export type DeliveryOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    isActive?: boolean
  }, ExtArgs["result"]["deliveryOption"]>

  export type DeliveryOptionSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    price?: boolean
    description?: boolean
    isActive?: boolean
  }


  export type $DeliveryOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryOption"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slug: string
      name: string
      price: number
      description: string | null
      isActive: boolean
    }, ExtArgs["result"]["deliveryOption"]>
    composites: {}
  }

  type DeliveryOptionGetPayload<S extends boolean | null | undefined | DeliveryOptionDefaultArgs> = $Result.GetResult<Prisma.$DeliveryOptionPayload, S>

  type DeliveryOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeliveryOptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeliveryOptionCountAggregateInputType | true
    }

  export interface DeliveryOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryOption'], meta: { name: 'DeliveryOption' } }
    /**
     * Find zero or one DeliveryOption that matches the filter.
     * @param {DeliveryOptionFindUniqueArgs} args - Arguments to find a DeliveryOption
     * @example
     * // Get one DeliveryOption
     * const deliveryOption = await prisma.deliveryOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryOptionFindUniqueArgs>(args: SelectSubset<T, DeliveryOptionFindUniqueArgs<ExtArgs>>): Prisma__DeliveryOptionClient<$Result.GetResult<Prisma.$DeliveryOptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeliveryOption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeliveryOptionFindUniqueOrThrowArgs} args - Arguments to find a DeliveryOption
     * @example
     * // Get one DeliveryOption
     * const deliveryOption = await prisma.deliveryOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryOptionClient<$Result.GetResult<Prisma.$DeliveryOptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeliveryOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryOptionFindFirstArgs} args - Arguments to find a DeliveryOption
     * @example
     * // Get one DeliveryOption
     * const deliveryOption = await prisma.deliveryOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryOptionFindFirstArgs>(args?: SelectSubset<T, DeliveryOptionFindFirstArgs<ExtArgs>>): Prisma__DeliveryOptionClient<$Result.GetResult<Prisma.$DeliveryOptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeliveryOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryOptionFindFirstOrThrowArgs} args - Arguments to find a DeliveryOption
     * @example
     * // Get one DeliveryOption
     * const deliveryOption = await prisma.deliveryOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryOptionClient<$Result.GetResult<Prisma.$DeliveryOptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeliveryOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryOptions
     * const deliveryOptions = await prisma.deliveryOption.findMany()
     * 
     * // Get first 10 DeliveryOptions
     * const deliveryOptions = await prisma.deliveryOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryOptionWithIdOnly = await prisma.deliveryOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryOptionFindManyArgs>(args?: SelectSubset<T, DeliveryOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryOptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeliveryOption.
     * @param {DeliveryOptionCreateArgs} args - Arguments to create a DeliveryOption.
     * @example
     * // Create one DeliveryOption
     * const DeliveryOption = await prisma.deliveryOption.create({
     *   data: {
     *     // ... data to create a DeliveryOption
     *   }
     * })
     * 
     */
    create<T extends DeliveryOptionCreateArgs>(args: SelectSubset<T, DeliveryOptionCreateArgs<ExtArgs>>): Prisma__DeliveryOptionClient<$Result.GetResult<Prisma.$DeliveryOptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeliveryOptions.
     * @param {DeliveryOptionCreateManyArgs} args - Arguments to create many DeliveryOptions.
     * @example
     * // Create many DeliveryOptions
     * const deliveryOption = await prisma.deliveryOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryOptionCreateManyArgs>(args?: SelectSubset<T, DeliveryOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryOptions and returns the data saved in the database.
     * @param {DeliveryOptionCreateManyAndReturnArgs} args - Arguments to create many DeliveryOptions.
     * @example
     * // Create many DeliveryOptions
     * const deliveryOption = await prisma.deliveryOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryOptions and only return the `id`
     * const deliveryOptionWithIdOnly = await prisma.deliveryOption.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryOptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeliveryOption.
     * @param {DeliveryOptionDeleteArgs} args - Arguments to delete one DeliveryOption.
     * @example
     * // Delete one DeliveryOption
     * const DeliveryOption = await prisma.deliveryOption.delete({
     *   where: {
     *     // ... filter to delete one DeliveryOption
     *   }
     * })
     * 
     */
    delete<T extends DeliveryOptionDeleteArgs>(args: SelectSubset<T, DeliveryOptionDeleteArgs<ExtArgs>>): Prisma__DeliveryOptionClient<$Result.GetResult<Prisma.$DeliveryOptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeliveryOption.
     * @param {DeliveryOptionUpdateArgs} args - Arguments to update one DeliveryOption.
     * @example
     * // Update one DeliveryOption
     * const deliveryOption = await prisma.deliveryOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryOptionUpdateArgs>(args: SelectSubset<T, DeliveryOptionUpdateArgs<ExtArgs>>): Prisma__DeliveryOptionClient<$Result.GetResult<Prisma.$DeliveryOptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeliveryOptions.
     * @param {DeliveryOptionDeleteManyArgs} args - Arguments to filter DeliveryOptions to delete.
     * @example
     * // Delete a few DeliveryOptions
     * const { count } = await prisma.deliveryOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryOptionDeleteManyArgs>(args?: SelectSubset<T, DeliveryOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryOptions
     * const deliveryOption = await prisma.deliveryOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryOptionUpdateManyArgs>(args: SelectSubset<T, DeliveryOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryOption.
     * @param {DeliveryOptionUpsertArgs} args - Arguments to update or create a DeliveryOption.
     * @example
     * // Update or create a DeliveryOption
     * const deliveryOption = await prisma.deliveryOption.upsert({
     *   create: {
     *     // ... data to create a DeliveryOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryOption we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryOptionUpsertArgs>(args: SelectSubset<T, DeliveryOptionUpsertArgs<ExtArgs>>): Prisma__DeliveryOptionClient<$Result.GetResult<Prisma.$DeliveryOptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeliveryOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryOptionCountArgs} args - Arguments to filter DeliveryOptions to count.
     * @example
     * // Count the number of DeliveryOptions
     * const count = await prisma.deliveryOption.count({
     *   where: {
     *     // ... the filter for the DeliveryOptions we want to count
     *   }
     * })
    **/
    count<T extends DeliveryOptionCountArgs>(
      args?: Subset<T, DeliveryOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryOptionAggregateArgs>(args: Subset<T, DeliveryOptionAggregateArgs>): Prisma.PrismaPromise<GetDeliveryOptionAggregateType<T>>

    /**
     * Group by DeliveryOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryOptionGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryOption model
   */
  readonly fields: DeliveryOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryOption model
   */ 
  interface DeliveryOptionFieldRefs {
    readonly id: FieldRef<"DeliveryOption", 'Int'>
    readonly slug: FieldRef<"DeliveryOption", 'String'>
    readonly name: FieldRef<"DeliveryOption", 'String'>
    readonly price: FieldRef<"DeliveryOption", 'Float'>
    readonly description: FieldRef<"DeliveryOption", 'String'>
    readonly isActive: FieldRef<"DeliveryOption", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryOption findUnique
   */
  export type DeliveryOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryOption
     */
    select?: DeliveryOptionSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryOption to fetch.
     */
    where: DeliveryOptionWhereUniqueInput
  }

  /**
   * DeliveryOption findUniqueOrThrow
   */
  export type DeliveryOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryOption
     */
    select?: DeliveryOptionSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryOption to fetch.
     */
    where: DeliveryOptionWhereUniqueInput
  }

  /**
   * DeliveryOption findFirst
   */
  export type DeliveryOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryOption
     */
    select?: DeliveryOptionSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryOption to fetch.
     */
    where?: DeliveryOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryOptions to fetch.
     */
    orderBy?: DeliveryOptionOrderByWithRelationInput | DeliveryOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryOptions.
     */
    cursor?: DeliveryOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryOptions.
     */
    distinct?: DeliveryOptionScalarFieldEnum | DeliveryOptionScalarFieldEnum[]
  }

  /**
   * DeliveryOption findFirstOrThrow
   */
  export type DeliveryOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryOption
     */
    select?: DeliveryOptionSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryOption to fetch.
     */
    where?: DeliveryOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryOptions to fetch.
     */
    orderBy?: DeliveryOptionOrderByWithRelationInput | DeliveryOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryOptions.
     */
    cursor?: DeliveryOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryOptions.
     */
    distinct?: DeliveryOptionScalarFieldEnum | DeliveryOptionScalarFieldEnum[]
  }

  /**
   * DeliveryOption findMany
   */
  export type DeliveryOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryOption
     */
    select?: DeliveryOptionSelect<ExtArgs> | null
    /**
     * Filter, which DeliveryOptions to fetch.
     */
    where?: DeliveryOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryOptions to fetch.
     */
    orderBy?: DeliveryOptionOrderByWithRelationInput | DeliveryOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryOptions.
     */
    cursor?: DeliveryOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryOptions.
     */
    skip?: number
    distinct?: DeliveryOptionScalarFieldEnum | DeliveryOptionScalarFieldEnum[]
  }

  /**
   * DeliveryOption create
   */
  export type DeliveryOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryOption
     */
    select?: DeliveryOptionSelect<ExtArgs> | null
    /**
     * The data needed to create a DeliveryOption.
     */
    data: XOR<DeliveryOptionCreateInput, DeliveryOptionUncheckedCreateInput>
  }

  /**
   * DeliveryOption createMany
   */
  export type DeliveryOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryOptions.
     */
    data: DeliveryOptionCreateManyInput | DeliveryOptionCreateManyInput[]
  }

  /**
   * DeliveryOption createManyAndReturn
   */
  export type DeliveryOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryOption
     */
    select?: DeliveryOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeliveryOptions.
     */
    data: DeliveryOptionCreateManyInput | DeliveryOptionCreateManyInput[]
  }

  /**
   * DeliveryOption update
   */
  export type DeliveryOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryOption
     */
    select?: DeliveryOptionSelect<ExtArgs> | null
    /**
     * The data needed to update a DeliveryOption.
     */
    data: XOR<DeliveryOptionUpdateInput, DeliveryOptionUncheckedUpdateInput>
    /**
     * Choose, which DeliveryOption to update.
     */
    where: DeliveryOptionWhereUniqueInput
  }

  /**
   * DeliveryOption updateMany
   */
  export type DeliveryOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryOptions.
     */
    data: XOR<DeliveryOptionUpdateManyMutationInput, DeliveryOptionUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryOptions to update
     */
    where?: DeliveryOptionWhereInput
  }

  /**
   * DeliveryOption upsert
   */
  export type DeliveryOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryOption
     */
    select?: DeliveryOptionSelect<ExtArgs> | null
    /**
     * The filter to search for the DeliveryOption to update in case it exists.
     */
    where: DeliveryOptionWhereUniqueInput
    /**
     * In case the DeliveryOption found by the `where` argument doesn't exist, create a new DeliveryOption with this data.
     */
    create: XOR<DeliveryOptionCreateInput, DeliveryOptionUncheckedCreateInput>
    /**
     * In case the DeliveryOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryOptionUpdateInput, DeliveryOptionUncheckedUpdateInput>
  }

  /**
   * DeliveryOption delete
   */
  export type DeliveryOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryOption
     */
    select?: DeliveryOptionSelect<ExtArgs> | null
    /**
     * Filter which DeliveryOption to delete.
     */
    where: DeliveryOptionWhereUniqueInput
  }

  /**
   * DeliveryOption deleteMany
   */
  export type DeliveryOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryOptions to delete
     */
    where?: DeliveryOptionWhereInput
  }

  /**
   * DeliveryOption without action
   */
  export type DeliveryOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryOption
     */
    select?: DeliveryOptionSelect<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    price: number | null
    stock: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    price: number | null
    stock: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    price: number | null
    images: string | null
    stock: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    price: number | null
    images: string | null
    stock: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    images: number
    stock: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    price?: true
    stock?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    price?: true
    stock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    images?: true
    stock?: true
    isActive?: true
    createdAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    images?: true
    stock?: true
    isActive?: true
    createdAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    images?: true
    stock?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    description: string | null
    price: number
    images: string | null
    stock: number
    isActive: boolean
    createdAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    images?: boolean
    stock?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    images?: boolean
    stock?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    images?: boolean
    stock?: boolean
    isActive?: boolean
    createdAt?: boolean
  }


  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      price: number
      images: string | null
      stock: number
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly images: FieldRef<"Product", 'String'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
  }


  /**
   * Model Translation
   */

  export type AggregateTranslation = {
    _count: TranslationCountAggregateOutputType | null
    _avg: TranslationAvgAggregateOutputType | null
    _sum: TranslationSumAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  export type TranslationAvgAggregateOutputType = {
    id: number | null
  }

  export type TranslationSumAggregateOutputType = {
    id: number | null
  }

  export type TranslationMinAggregateOutputType = {
    id: number | null
    lang: string | null
    key: string | null
    value: string | null
  }

  export type TranslationMaxAggregateOutputType = {
    id: number | null
    lang: string | null
    key: string | null
    value: string | null
  }

  export type TranslationCountAggregateOutputType = {
    id: number
    lang: number
    key: number
    value: number
    _all: number
  }


  export type TranslationAvgAggregateInputType = {
    id?: true
  }

  export type TranslationSumAggregateInputType = {
    id?: true
  }

  export type TranslationMinAggregateInputType = {
    id?: true
    lang?: true
    key?: true
    value?: true
  }

  export type TranslationMaxAggregateInputType = {
    id?: true
    lang?: true
    key?: true
    value?: true
  }

  export type TranslationCountAggregateInputType = {
    id?: true
    lang?: true
    key?: true
    value?: true
    _all?: true
  }

  export type TranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Translation to aggregate.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Translations
    **/
    _count?: true | TranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TranslationMaxAggregateInputType
  }

  export type GetTranslationAggregateType<T extends TranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTranslation[P]>
      : GetScalarType<T[P], AggregateTranslation[P]>
  }




  export type TranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TranslationWhereInput
    orderBy?: TranslationOrderByWithAggregationInput | TranslationOrderByWithAggregationInput[]
    by: TranslationScalarFieldEnum[] | TranslationScalarFieldEnum
    having?: TranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TranslationCountAggregateInputType | true
    _avg?: TranslationAvgAggregateInputType
    _sum?: TranslationSumAggregateInputType
    _min?: TranslationMinAggregateInputType
    _max?: TranslationMaxAggregateInputType
  }

  export type TranslationGroupByOutputType = {
    id: number
    lang: string
    key: string
    value: string
    _count: TranslationCountAggregateOutputType | null
    _avg: TranslationAvgAggregateOutputType | null
    _sum: TranslationSumAggregateOutputType | null
    _min: TranslationMinAggregateOutputType | null
    _max: TranslationMaxAggregateOutputType | null
  }

  type GetTranslationGroupByPayload<T extends TranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TranslationGroupByOutputType[P]>
            : GetScalarType<T[P], TranslationGroupByOutputType[P]>
        }
      >
    >


  export type TranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["translation"]>

  export type TranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["translation"]>

  export type TranslationSelectScalar = {
    id?: boolean
    lang?: boolean
    key?: boolean
    value?: boolean
  }


  export type $TranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Translation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lang: string
      key: string
      value: string
    }, ExtArgs["result"]["translation"]>
    composites: {}
  }

  type TranslationGetPayload<S extends boolean | null | undefined | TranslationDefaultArgs> = $Result.GetResult<Prisma.$TranslationPayload, S>

  type TranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TranslationCountAggregateInputType | true
    }

  export interface TranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Translation'], meta: { name: 'Translation' } }
    /**
     * Find zero or one Translation that matches the filter.
     * @param {TranslationFindUniqueArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TranslationFindUniqueArgs>(args: SelectSubset<T, TranslationFindUniqueArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Translation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TranslationFindUniqueOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, TranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Translation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindFirstArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TranslationFindFirstArgs>(args?: SelectSubset<T, TranslationFindFirstArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Translation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindFirstOrThrowArgs} args - Arguments to find a Translation
     * @example
     * // Get one Translation
     * const translation = await prisma.translation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, TranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Translations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Translations
     * const translations = await prisma.translation.findMany()
     * 
     * // Get first 10 Translations
     * const translations = await prisma.translation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const translationWithIdOnly = await prisma.translation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TranslationFindManyArgs>(args?: SelectSubset<T, TranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Translation.
     * @param {TranslationCreateArgs} args - Arguments to create a Translation.
     * @example
     * // Create one Translation
     * const Translation = await prisma.translation.create({
     *   data: {
     *     // ... data to create a Translation
     *   }
     * })
     * 
     */
    create<T extends TranslationCreateArgs>(args: SelectSubset<T, TranslationCreateArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Translations.
     * @param {TranslationCreateManyArgs} args - Arguments to create many Translations.
     * @example
     * // Create many Translations
     * const translation = await prisma.translation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TranslationCreateManyArgs>(args?: SelectSubset<T, TranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Translations and returns the data saved in the database.
     * @param {TranslationCreateManyAndReturnArgs} args - Arguments to create many Translations.
     * @example
     * // Create many Translations
     * const translation = await prisma.translation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Translations and only return the `id`
     * const translationWithIdOnly = await prisma.translation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, TranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Translation.
     * @param {TranslationDeleteArgs} args - Arguments to delete one Translation.
     * @example
     * // Delete one Translation
     * const Translation = await prisma.translation.delete({
     *   where: {
     *     // ... filter to delete one Translation
     *   }
     * })
     * 
     */
    delete<T extends TranslationDeleteArgs>(args: SelectSubset<T, TranslationDeleteArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Translation.
     * @param {TranslationUpdateArgs} args - Arguments to update one Translation.
     * @example
     * // Update one Translation
     * const translation = await prisma.translation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TranslationUpdateArgs>(args: SelectSubset<T, TranslationUpdateArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Translations.
     * @param {TranslationDeleteManyArgs} args - Arguments to filter Translations to delete.
     * @example
     * // Delete a few Translations
     * const { count } = await prisma.translation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TranslationDeleteManyArgs>(args?: SelectSubset<T, TranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Translations
     * const translation = await prisma.translation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TranslationUpdateManyArgs>(args: SelectSubset<T, TranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Translation.
     * @param {TranslationUpsertArgs} args - Arguments to update or create a Translation.
     * @example
     * // Update or create a Translation
     * const translation = await prisma.translation.upsert({
     *   create: {
     *     // ... data to create a Translation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Translation we want to update
     *   }
     * })
     */
    upsert<T extends TranslationUpsertArgs>(args: SelectSubset<T, TranslationUpsertArgs<ExtArgs>>): Prisma__TranslationClient<$Result.GetResult<Prisma.$TranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Translations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationCountArgs} args - Arguments to filter Translations to count.
     * @example
     * // Count the number of Translations
     * const count = await prisma.translation.count({
     *   where: {
     *     // ... the filter for the Translations we want to count
     *   }
     * })
    **/
    count<T extends TranslationCountArgs>(
      args?: Subset<T, TranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TranslationAggregateArgs>(args: Subset<T, TranslationAggregateArgs>): Prisma.PrismaPromise<GetTranslationAggregateType<T>>

    /**
     * Group by Translation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TranslationGroupByArgs['orderBy'] }
        : { orderBy?: TranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Translation model
   */
  readonly fields: TranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Translation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Translation model
   */ 
  interface TranslationFieldRefs {
    readonly id: FieldRef<"Translation", 'Int'>
    readonly lang: FieldRef<"Translation", 'String'>
    readonly key: FieldRef<"Translation", 'String'>
    readonly value: FieldRef<"Translation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Translation findUnique
   */
  export type TranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation findUniqueOrThrow
   */
  export type TranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation findFirst
   */
  export type TranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation findFirstOrThrow
   */
  export type TranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter, which Translation to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Translations.
     */
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation findMany
   */
  export type TranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter, which Translations to fetch.
     */
    where?: TranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Translations to fetch.
     */
    orderBy?: TranslationOrderByWithRelationInput | TranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Translations.
     */
    cursor?: TranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Translations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Translations.
     */
    skip?: number
    distinct?: TranslationScalarFieldEnum | TranslationScalarFieldEnum[]
  }

  /**
   * Translation create
   */
  export type TranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * The data needed to create a Translation.
     */
    data: XOR<TranslationCreateInput, TranslationUncheckedCreateInput>
  }

  /**
   * Translation createMany
   */
  export type TranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Translations.
     */
    data: TranslationCreateManyInput | TranslationCreateManyInput[]
  }

  /**
   * Translation createManyAndReturn
   */
  export type TranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Translations.
     */
    data: TranslationCreateManyInput | TranslationCreateManyInput[]
  }

  /**
   * Translation update
   */
  export type TranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * The data needed to update a Translation.
     */
    data: XOR<TranslationUpdateInput, TranslationUncheckedUpdateInput>
    /**
     * Choose, which Translation to update.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation updateMany
   */
  export type TranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Translations.
     */
    data: XOR<TranslationUpdateManyMutationInput, TranslationUncheckedUpdateManyInput>
    /**
     * Filter which Translations to update
     */
    where?: TranslationWhereInput
  }

  /**
   * Translation upsert
   */
  export type TranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * The filter to search for the Translation to update in case it exists.
     */
    where: TranslationWhereUniqueInput
    /**
     * In case the Translation found by the `where` argument doesn't exist, create a new Translation with this data.
     */
    create: XOR<TranslationCreateInput, TranslationUncheckedCreateInput>
    /**
     * In case the Translation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TranslationUpdateInput, TranslationUncheckedUpdateInput>
  }

  /**
   * Translation delete
   */
  export type TranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
    /**
     * Filter which Translation to delete.
     */
    where: TranslationWhereUniqueInput
  }

  /**
   * Translation deleteMany
   */
  export type TranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Translations to delete
     */
    where?: TranslationWhereInput
  }

  /**
   * Translation without action
   */
  export type TranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Translation
     */
    select?: TranslationSelect<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    key: string | null
    value: string | null
    description: string | null
  }

  export type SettingMaxAggregateOutputType = {
    key: string | null
    value: string | null
    description: string | null
  }

  export type SettingCountAggregateOutputType = {
    key: number
    value: number
    description: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    key?: true
    value?: true
    description?: true
  }

  export type SettingMaxAggregateInputType = {
    key?: true
    value?: true
    description?: true
  }

  export type SettingCountAggregateInputType = {
    key?: true
    value?: true
    description?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    key: string
    value: string
    description: string | null
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    description?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    description?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    key?: boolean
    value?: boolean
    description?: boolean
  }


  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string
      description: string | null
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const settingWithKeyOnly = await prisma.setting.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `key`
     * const settingWithKeyOnly = await prisma.setting.createManyAndReturn({ 
     *   select: { key: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */ 
  interface SettingFieldRefs {
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'String'>
    readonly description: FieldRef<"Setting", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
  }


  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageAvgAggregateOutputType = {
    id: number | null
  }

  export type PageSumAggregateOutputType = {
    id: number | null
  }

  export type PageMinAggregateOutputType = {
    id: number | null
    lang: string | null
    title: string | null
    slug: string | null
    content: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageMaxAggregateOutputType = {
    id: number | null
    lang: string | null
    title: string | null
    slug: string | null
    content: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    lang: number
    title: number
    slug: number
    content: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageAvgAggregateInputType = {
    id?: true
  }

  export type PageSumAggregateInputType = {
    id?: true
  }

  export type PageMinAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    slug?: true
    content?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    slug?: true
    content?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    lang?: true
    title?: true
    slug?: true
    content?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
        [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }




  export type PageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
    orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
    by: PageScalarFieldEnum[] | PageScalarFieldEnum
    having?: PageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageCountAggregateInputType | true
    _avg?: PageAvgAggregateInputType
    _sum?: PageSumAggregateInputType
    _min?: PageMinAggregateInputType
    _max?: PageMaxAggregateInputType
  }

  export type PageGroupByOutputType = {
    id: number
    lang: string
    title: string
    slug: string
    content: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageGroupByOutputType[P]>
            : GetScalarType<T[P], PageGroupByOutputType[P]>
        }
      >
    >


  export type PageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lang?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectScalar = {
    id?: boolean
    lang?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Page"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lang: string
      title: string
      slug: string
      content: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["page"]>
    composites: {}
  }

  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<Prisma.$PagePayload, S>

  type PageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PageCountAggregateInputType | true
    }

  export interface PageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Page'], meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageFindUniqueArgs>(args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Page that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs>(args: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageFindFirstArgs>(args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs>(args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageFindManyArgs>(args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     * 
     */
    create<T extends PageCreateArgs>(args: SelectSubset<T, PageCreateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pages.
     * @param {PageCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageCreateManyArgs>(args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {PageCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageCreateManyAndReturnArgs>(args?: SelectSubset<T, PageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     * 
     */
    delete<T extends PageDeleteArgs>(args: SelectSubset<T, PageDeleteArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageUpdateArgs>(args: SelectSubset<T, PageUpdateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageDeleteManyArgs>(args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageUpdateManyArgs>(args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
     */
    upsert<T extends PageUpsertArgs>(args: SelectSubset<T, PageUpsertArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAggregateArgs>(args: Subset<T, PageAggregateArgs>): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Page model
   */
  readonly fields: PageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Page model
   */ 
  interface PageFieldRefs {
    readonly id: FieldRef<"Page", 'Int'>
    readonly lang: FieldRef<"Page", 'String'>
    readonly title: FieldRef<"Page", 'String'>
    readonly slug: FieldRef<"Page", 'String'>
    readonly content: FieldRef<"Page", 'String'>
    readonly description: FieldRef<"Page", 'String'>
    readonly isActive: FieldRef<"Page", 'Boolean'>
    readonly createdAt: FieldRef<"Page", 'DateTime'>
    readonly updatedAt: FieldRef<"Page", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter, which Pages to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }

  /**
   * Page createMany
   */
  export type PageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
  }

  /**
   * Page createManyAndReturn
   */
  export type PageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
  }

  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
  }

  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }

  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
  }

  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
  }


  /**
   * Model HelpCategory
   */

  export type AggregateHelpCategory = {
    _count: HelpCategoryCountAggregateOutputType | null
    _avg: HelpCategoryAvgAggregateOutputType | null
    _sum: HelpCategorySumAggregateOutputType | null
    _min: HelpCategoryMinAggregateOutputType | null
    _max: HelpCategoryMaxAggregateOutputType | null
  }

  export type HelpCategoryAvgAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type HelpCategorySumAggregateOutputType = {
    id: number | null
    sortOrder: number | null
  }

  export type HelpCategoryMinAggregateOutputType = {
    id: number | null
    slug: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpCategoryMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpCategoryCountAggregateOutputType = {
    id: number
    slug: number
    sortOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HelpCategoryAvgAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type HelpCategorySumAggregateInputType = {
    id?: true
    sortOrder?: true
  }

  export type HelpCategoryMinAggregateInputType = {
    id?: true
    slug?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpCategoryMaxAggregateInputType = {
    id?: true
    slug?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpCategoryCountAggregateInputType = {
    id?: true
    slug?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HelpCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpCategory to aggregate.
     */
    where?: HelpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategories to fetch.
     */
    orderBy?: HelpCategoryOrderByWithRelationInput | HelpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpCategories
    **/
    _count?: true | HelpCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelpCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelpCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpCategoryMaxAggregateInputType
  }

  export type GetHelpCategoryAggregateType<T extends HelpCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpCategory[P]>
      : GetScalarType<T[P], AggregateHelpCategory[P]>
  }




  export type HelpCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpCategoryWhereInput
    orderBy?: HelpCategoryOrderByWithAggregationInput | HelpCategoryOrderByWithAggregationInput[]
    by: HelpCategoryScalarFieldEnum[] | HelpCategoryScalarFieldEnum
    having?: HelpCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpCategoryCountAggregateInputType | true
    _avg?: HelpCategoryAvgAggregateInputType
    _sum?: HelpCategorySumAggregateInputType
    _min?: HelpCategoryMinAggregateInputType
    _max?: HelpCategoryMaxAggregateInputType
  }

  export type HelpCategoryGroupByOutputType = {
    id: number
    slug: string
    sortOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: HelpCategoryCountAggregateOutputType | null
    _avg: HelpCategoryAvgAggregateOutputType | null
    _sum: HelpCategorySumAggregateOutputType | null
    _min: HelpCategoryMinAggregateOutputType | null
    _max: HelpCategoryMaxAggregateOutputType | null
  }

  type GetHelpCategoryGroupByPayload<T extends HelpCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], HelpCategoryGroupByOutputType[P]>
        }
      >
    >


  export type HelpCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    translations?: boolean | HelpCategory$translationsArgs<ExtArgs>
    articles?: boolean | HelpCategory$articlesArgs<ExtArgs>
    _count?: boolean | HelpCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpCategory"]>

  export type HelpCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["helpCategory"]>

  export type HelpCategorySelectScalar = {
    id?: boolean
    slug?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HelpCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    translations?: boolean | HelpCategory$translationsArgs<ExtArgs>
    articles?: boolean | HelpCategory$articlesArgs<ExtArgs>
    _count?: boolean | HelpCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HelpCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HelpCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpCategory"
    objects: {
      translations: Prisma.$HelpCategoryTranslationPayload<ExtArgs>[]
      articles: Prisma.$HelpArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slug: string
      sortOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["helpCategory"]>
    composites: {}
  }

  type HelpCategoryGetPayload<S extends boolean | null | undefined | HelpCategoryDefaultArgs> = $Result.GetResult<Prisma.$HelpCategoryPayload, S>

  type HelpCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HelpCategoryCountAggregateInputType | true
    }

  export interface HelpCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpCategory'], meta: { name: 'HelpCategory' } }
    /**
     * Find zero or one HelpCategory that matches the filter.
     * @param {HelpCategoryFindUniqueArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpCategoryFindUniqueArgs>(args: SelectSubset<T, HelpCategoryFindUniqueArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HelpCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpCategoryFindUniqueOrThrowArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HelpCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryFindFirstArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpCategoryFindFirstArgs>(args?: SelectSubset<T, HelpCategoryFindFirstArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HelpCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryFindFirstOrThrowArgs} args - Arguments to find a HelpCategory
     * @example
     * // Get one HelpCategory
     * const helpCategory = await prisma.helpCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HelpCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpCategories
     * const helpCategories = await prisma.helpCategory.findMany()
     * 
     * // Get first 10 HelpCategories
     * const helpCategories = await prisma.helpCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpCategoryWithIdOnly = await prisma.helpCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpCategoryFindManyArgs>(args?: SelectSubset<T, HelpCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HelpCategory.
     * @param {HelpCategoryCreateArgs} args - Arguments to create a HelpCategory.
     * @example
     * // Create one HelpCategory
     * const HelpCategory = await prisma.helpCategory.create({
     *   data: {
     *     // ... data to create a HelpCategory
     *   }
     * })
     * 
     */
    create<T extends HelpCategoryCreateArgs>(args: SelectSubset<T, HelpCategoryCreateArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HelpCategories.
     * @param {HelpCategoryCreateManyArgs} args - Arguments to create many HelpCategories.
     * @example
     * // Create many HelpCategories
     * const helpCategory = await prisma.helpCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpCategoryCreateManyArgs>(args?: SelectSubset<T, HelpCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpCategories and returns the data saved in the database.
     * @param {HelpCategoryCreateManyAndReturnArgs} args - Arguments to create many HelpCategories.
     * @example
     * // Create many HelpCategories
     * const helpCategory = await prisma.helpCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpCategories and only return the `id`
     * const helpCategoryWithIdOnly = await prisma.helpCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelpCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, HelpCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HelpCategory.
     * @param {HelpCategoryDeleteArgs} args - Arguments to delete one HelpCategory.
     * @example
     * // Delete one HelpCategory
     * const HelpCategory = await prisma.helpCategory.delete({
     *   where: {
     *     // ... filter to delete one HelpCategory
     *   }
     * })
     * 
     */
    delete<T extends HelpCategoryDeleteArgs>(args: SelectSubset<T, HelpCategoryDeleteArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HelpCategory.
     * @param {HelpCategoryUpdateArgs} args - Arguments to update one HelpCategory.
     * @example
     * // Update one HelpCategory
     * const helpCategory = await prisma.helpCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpCategoryUpdateArgs>(args: SelectSubset<T, HelpCategoryUpdateArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HelpCategories.
     * @param {HelpCategoryDeleteManyArgs} args - Arguments to filter HelpCategories to delete.
     * @example
     * // Delete a few HelpCategories
     * const { count } = await prisma.helpCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpCategoryDeleteManyArgs>(args?: SelectSubset<T, HelpCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpCategories
     * const helpCategory = await prisma.helpCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpCategoryUpdateManyArgs>(args: SelectSubset<T, HelpCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HelpCategory.
     * @param {HelpCategoryUpsertArgs} args - Arguments to update or create a HelpCategory.
     * @example
     * // Update or create a HelpCategory
     * const helpCategory = await prisma.helpCategory.upsert({
     *   create: {
     *     // ... data to create a HelpCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpCategory we want to update
     *   }
     * })
     */
    upsert<T extends HelpCategoryUpsertArgs>(args: SelectSubset<T, HelpCategoryUpsertArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HelpCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryCountArgs} args - Arguments to filter HelpCategories to count.
     * @example
     * // Count the number of HelpCategories
     * const count = await prisma.helpCategory.count({
     *   where: {
     *     // ... the filter for the HelpCategories we want to count
     *   }
     * })
    **/
    count<T extends HelpCategoryCountArgs>(
      args?: Subset<T, HelpCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpCategoryAggregateArgs>(args: Subset<T, HelpCategoryAggregateArgs>): Prisma.PrismaPromise<GetHelpCategoryAggregateType<T>>

    /**
     * Group by HelpCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpCategoryGroupByArgs['orderBy'] }
        : { orderBy?: HelpCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpCategory model
   */
  readonly fields: HelpCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    translations<T extends HelpCategory$translationsArgs<ExtArgs> = {}>(args?: Subset<T, HelpCategory$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpCategoryTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    articles<T extends HelpCategory$articlesArgs<ExtArgs> = {}>(args?: Subset<T, HelpCategory$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpCategory model
   */ 
  interface HelpCategoryFieldRefs {
    readonly id: FieldRef<"HelpCategory", 'Int'>
    readonly slug: FieldRef<"HelpCategory", 'String'>
    readonly sortOrder: FieldRef<"HelpCategory", 'Int'>
    readonly isActive: FieldRef<"HelpCategory", 'Boolean'>
    readonly createdAt: FieldRef<"HelpCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"HelpCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HelpCategory findUnique
   */
  export type HelpCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategory to fetch.
     */
    where: HelpCategoryWhereUniqueInput
  }

  /**
   * HelpCategory findUniqueOrThrow
   */
  export type HelpCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategory to fetch.
     */
    where: HelpCategoryWhereUniqueInput
  }

  /**
   * HelpCategory findFirst
   */
  export type HelpCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategory to fetch.
     */
    where?: HelpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategories to fetch.
     */
    orderBy?: HelpCategoryOrderByWithRelationInput | HelpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpCategories.
     */
    cursor?: HelpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpCategories.
     */
    distinct?: HelpCategoryScalarFieldEnum | HelpCategoryScalarFieldEnum[]
  }

  /**
   * HelpCategory findFirstOrThrow
   */
  export type HelpCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategory to fetch.
     */
    where?: HelpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategories to fetch.
     */
    orderBy?: HelpCategoryOrderByWithRelationInput | HelpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpCategories.
     */
    cursor?: HelpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpCategories.
     */
    distinct?: HelpCategoryScalarFieldEnum | HelpCategoryScalarFieldEnum[]
  }

  /**
   * HelpCategory findMany
   */
  export type HelpCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategories to fetch.
     */
    where?: HelpCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategories to fetch.
     */
    orderBy?: HelpCategoryOrderByWithRelationInput | HelpCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpCategories.
     */
    cursor?: HelpCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategories.
     */
    skip?: number
    distinct?: HelpCategoryScalarFieldEnum | HelpCategoryScalarFieldEnum[]
  }

  /**
   * HelpCategory create
   */
  export type HelpCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpCategory.
     */
    data: XOR<HelpCategoryCreateInput, HelpCategoryUncheckedCreateInput>
  }

  /**
   * HelpCategory createMany
   */
  export type HelpCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpCategories.
     */
    data: HelpCategoryCreateManyInput | HelpCategoryCreateManyInput[]
  }

  /**
   * HelpCategory createManyAndReturn
   */
  export type HelpCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HelpCategories.
     */
    data: HelpCategoryCreateManyInput | HelpCategoryCreateManyInput[]
  }

  /**
   * HelpCategory update
   */
  export type HelpCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpCategory.
     */
    data: XOR<HelpCategoryUpdateInput, HelpCategoryUncheckedUpdateInput>
    /**
     * Choose, which HelpCategory to update.
     */
    where: HelpCategoryWhereUniqueInput
  }

  /**
   * HelpCategory updateMany
   */
  export type HelpCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpCategories.
     */
    data: XOR<HelpCategoryUpdateManyMutationInput, HelpCategoryUncheckedUpdateManyInput>
    /**
     * Filter which HelpCategories to update
     */
    where?: HelpCategoryWhereInput
  }

  /**
   * HelpCategory upsert
   */
  export type HelpCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpCategory to update in case it exists.
     */
    where: HelpCategoryWhereUniqueInput
    /**
     * In case the HelpCategory found by the `where` argument doesn't exist, create a new HelpCategory with this data.
     */
    create: XOR<HelpCategoryCreateInput, HelpCategoryUncheckedCreateInput>
    /**
     * In case the HelpCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpCategoryUpdateInput, HelpCategoryUncheckedUpdateInput>
  }

  /**
   * HelpCategory delete
   */
  export type HelpCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
    /**
     * Filter which HelpCategory to delete.
     */
    where: HelpCategoryWhereUniqueInput
  }

  /**
   * HelpCategory deleteMany
   */
  export type HelpCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpCategories to delete
     */
    where?: HelpCategoryWhereInput
  }

  /**
   * HelpCategory.translations
   */
  export type HelpCategory$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationInclude<ExtArgs> | null
    where?: HelpCategoryTranslationWhereInput
    orderBy?: HelpCategoryTranslationOrderByWithRelationInput | HelpCategoryTranslationOrderByWithRelationInput[]
    cursor?: HelpCategoryTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpCategoryTranslationScalarFieldEnum | HelpCategoryTranslationScalarFieldEnum[]
  }

  /**
   * HelpCategory.articles
   */
  export type HelpCategory$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    where?: HelpArticleWhereInput
    orderBy?: HelpArticleOrderByWithRelationInput | HelpArticleOrderByWithRelationInput[]
    cursor?: HelpArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpArticleScalarFieldEnum | HelpArticleScalarFieldEnum[]
  }

  /**
   * HelpCategory without action
   */
  export type HelpCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategory
     */
    select?: HelpCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryInclude<ExtArgs> | null
  }


  /**
   * Model HelpCategoryTranslation
   */

  export type AggregateHelpCategoryTranslation = {
    _count: HelpCategoryTranslationCountAggregateOutputType | null
    _avg: HelpCategoryTranslationAvgAggregateOutputType | null
    _sum: HelpCategoryTranslationSumAggregateOutputType | null
    _min: HelpCategoryTranslationMinAggregateOutputType | null
    _max: HelpCategoryTranslationMaxAggregateOutputType | null
  }

  export type HelpCategoryTranslationAvgAggregateOutputType = {
    id: number | null
    helpCategoryId: number | null
  }

  export type HelpCategoryTranslationSumAggregateOutputType = {
    id: number | null
    helpCategoryId: number | null
  }

  export type HelpCategoryTranslationMinAggregateOutputType = {
    id: number | null
    helpCategoryId: number | null
    lang: string | null
    name: string | null
  }

  export type HelpCategoryTranslationMaxAggregateOutputType = {
    id: number | null
    helpCategoryId: number | null
    lang: string | null
    name: string | null
  }

  export type HelpCategoryTranslationCountAggregateOutputType = {
    id: number
    helpCategoryId: number
    lang: number
    name: number
    _all: number
  }


  export type HelpCategoryTranslationAvgAggregateInputType = {
    id?: true
    helpCategoryId?: true
  }

  export type HelpCategoryTranslationSumAggregateInputType = {
    id?: true
    helpCategoryId?: true
  }

  export type HelpCategoryTranslationMinAggregateInputType = {
    id?: true
    helpCategoryId?: true
    lang?: true
    name?: true
  }

  export type HelpCategoryTranslationMaxAggregateInputType = {
    id?: true
    helpCategoryId?: true
    lang?: true
    name?: true
  }

  export type HelpCategoryTranslationCountAggregateInputType = {
    id?: true
    helpCategoryId?: true
    lang?: true
    name?: true
    _all?: true
  }

  export type HelpCategoryTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpCategoryTranslation to aggregate.
     */
    where?: HelpCategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategoryTranslations to fetch.
     */
    orderBy?: HelpCategoryTranslationOrderByWithRelationInput | HelpCategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpCategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpCategoryTranslations
    **/
    _count?: true | HelpCategoryTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelpCategoryTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelpCategoryTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpCategoryTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpCategoryTranslationMaxAggregateInputType
  }

  export type GetHelpCategoryTranslationAggregateType<T extends HelpCategoryTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpCategoryTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpCategoryTranslation[P]>
      : GetScalarType<T[P], AggregateHelpCategoryTranslation[P]>
  }




  export type HelpCategoryTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpCategoryTranslationWhereInput
    orderBy?: HelpCategoryTranslationOrderByWithAggregationInput | HelpCategoryTranslationOrderByWithAggregationInput[]
    by: HelpCategoryTranslationScalarFieldEnum[] | HelpCategoryTranslationScalarFieldEnum
    having?: HelpCategoryTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpCategoryTranslationCountAggregateInputType | true
    _avg?: HelpCategoryTranslationAvgAggregateInputType
    _sum?: HelpCategoryTranslationSumAggregateInputType
    _min?: HelpCategoryTranslationMinAggregateInputType
    _max?: HelpCategoryTranslationMaxAggregateInputType
  }

  export type HelpCategoryTranslationGroupByOutputType = {
    id: number
    helpCategoryId: number
    lang: string
    name: string
    _count: HelpCategoryTranslationCountAggregateOutputType | null
    _avg: HelpCategoryTranslationAvgAggregateOutputType | null
    _sum: HelpCategoryTranslationSumAggregateOutputType | null
    _min: HelpCategoryTranslationMinAggregateOutputType | null
    _max: HelpCategoryTranslationMaxAggregateOutputType | null
  }

  type GetHelpCategoryTranslationGroupByPayload<T extends HelpCategoryTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpCategoryTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpCategoryTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpCategoryTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], HelpCategoryTranslationGroupByOutputType[P]>
        }
      >
    >


  export type HelpCategoryTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    helpCategoryId?: boolean
    lang?: boolean
    name?: boolean
    helpCategory?: boolean | HelpCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpCategoryTranslation"]>

  export type HelpCategoryTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    helpCategoryId?: boolean
    lang?: boolean
    name?: boolean
    helpCategory?: boolean | HelpCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpCategoryTranslation"]>

  export type HelpCategoryTranslationSelectScalar = {
    id?: boolean
    helpCategoryId?: boolean
    lang?: boolean
    name?: boolean
  }

  export type HelpCategoryTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpCategory?: boolean | HelpCategoryDefaultArgs<ExtArgs>
  }
  export type HelpCategoryTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpCategory?: boolean | HelpCategoryDefaultArgs<ExtArgs>
  }

  export type $HelpCategoryTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpCategoryTranslation"
    objects: {
      helpCategory: Prisma.$HelpCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      helpCategoryId: number
      lang: string
      name: string
    }, ExtArgs["result"]["helpCategoryTranslation"]>
    composites: {}
  }

  type HelpCategoryTranslationGetPayload<S extends boolean | null | undefined | HelpCategoryTranslationDefaultArgs> = $Result.GetResult<Prisma.$HelpCategoryTranslationPayload, S>

  type HelpCategoryTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpCategoryTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HelpCategoryTranslationCountAggregateInputType | true
    }

  export interface HelpCategoryTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpCategoryTranslation'], meta: { name: 'HelpCategoryTranslation' } }
    /**
     * Find zero or one HelpCategoryTranslation that matches the filter.
     * @param {HelpCategoryTranslationFindUniqueArgs} args - Arguments to find a HelpCategoryTranslation
     * @example
     * // Get one HelpCategoryTranslation
     * const helpCategoryTranslation = await prisma.helpCategoryTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpCategoryTranslationFindUniqueArgs>(args: SelectSubset<T, HelpCategoryTranslationFindUniqueArgs<ExtArgs>>): Prisma__HelpCategoryTranslationClient<$Result.GetResult<Prisma.$HelpCategoryTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HelpCategoryTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpCategoryTranslationFindUniqueOrThrowArgs} args - Arguments to find a HelpCategoryTranslation
     * @example
     * // Get one HelpCategoryTranslation
     * const helpCategoryTranslation = await prisma.helpCategoryTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpCategoryTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpCategoryTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpCategoryTranslationClient<$Result.GetResult<Prisma.$HelpCategoryTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HelpCategoryTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryTranslationFindFirstArgs} args - Arguments to find a HelpCategoryTranslation
     * @example
     * // Get one HelpCategoryTranslation
     * const helpCategoryTranslation = await prisma.helpCategoryTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpCategoryTranslationFindFirstArgs>(args?: SelectSubset<T, HelpCategoryTranslationFindFirstArgs<ExtArgs>>): Prisma__HelpCategoryTranslationClient<$Result.GetResult<Prisma.$HelpCategoryTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HelpCategoryTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryTranslationFindFirstOrThrowArgs} args - Arguments to find a HelpCategoryTranslation
     * @example
     * // Get one HelpCategoryTranslation
     * const helpCategoryTranslation = await prisma.helpCategoryTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpCategoryTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpCategoryTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpCategoryTranslationClient<$Result.GetResult<Prisma.$HelpCategoryTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HelpCategoryTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpCategoryTranslations
     * const helpCategoryTranslations = await prisma.helpCategoryTranslation.findMany()
     * 
     * // Get first 10 HelpCategoryTranslations
     * const helpCategoryTranslations = await prisma.helpCategoryTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpCategoryTranslationWithIdOnly = await prisma.helpCategoryTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpCategoryTranslationFindManyArgs>(args?: SelectSubset<T, HelpCategoryTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpCategoryTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HelpCategoryTranslation.
     * @param {HelpCategoryTranslationCreateArgs} args - Arguments to create a HelpCategoryTranslation.
     * @example
     * // Create one HelpCategoryTranslation
     * const HelpCategoryTranslation = await prisma.helpCategoryTranslation.create({
     *   data: {
     *     // ... data to create a HelpCategoryTranslation
     *   }
     * })
     * 
     */
    create<T extends HelpCategoryTranslationCreateArgs>(args: SelectSubset<T, HelpCategoryTranslationCreateArgs<ExtArgs>>): Prisma__HelpCategoryTranslationClient<$Result.GetResult<Prisma.$HelpCategoryTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HelpCategoryTranslations.
     * @param {HelpCategoryTranslationCreateManyArgs} args - Arguments to create many HelpCategoryTranslations.
     * @example
     * // Create many HelpCategoryTranslations
     * const helpCategoryTranslation = await prisma.helpCategoryTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpCategoryTranslationCreateManyArgs>(args?: SelectSubset<T, HelpCategoryTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpCategoryTranslations and returns the data saved in the database.
     * @param {HelpCategoryTranslationCreateManyAndReturnArgs} args - Arguments to create many HelpCategoryTranslations.
     * @example
     * // Create many HelpCategoryTranslations
     * const helpCategoryTranslation = await prisma.helpCategoryTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpCategoryTranslations and only return the `id`
     * const helpCategoryTranslationWithIdOnly = await prisma.helpCategoryTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelpCategoryTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, HelpCategoryTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpCategoryTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HelpCategoryTranslation.
     * @param {HelpCategoryTranslationDeleteArgs} args - Arguments to delete one HelpCategoryTranslation.
     * @example
     * // Delete one HelpCategoryTranslation
     * const HelpCategoryTranslation = await prisma.helpCategoryTranslation.delete({
     *   where: {
     *     // ... filter to delete one HelpCategoryTranslation
     *   }
     * })
     * 
     */
    delete<T extends HelpCategoryTranslationDeleteArgs>(args: SelectSubset<T, HelpCategoryTranslationDeleteArgs<ExtArgs>>): Prisma__HelpCategoryTranslationClient<$Result.GetResult<Prisma.$HelpCategoryTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HelpCategoryTranslation.
     * @param {HelpCategoryTranslationUpdateArgs} args - Arguments to update one HelpCategoryTranslation.
     * @example
     * // Update one HelpCategoryTranslation
     * const helpCategoryTranslation = await prisma.helpCategoryTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpCategoryTranslationUpdateArgs>(args: SelectSubset<T, HelpCategoryTranslationUpdateArgs<ExtArgs>>): Prisma__HelpCategoryTranslationClient<$Result.GetResult<Prisma.$HelpCategoryTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HelpCategoryTranslations.
     * @param {HelpCategoryTranslationDeleteManyArgs} args - Arguments to filter HelpCategoryTranslations to delete.
     * @example
     * // Delete a few HelpCategoryTranslations
     * const { count } = await prisma.helpCategoryTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpCategoryTranslationDeleteManyArgs>(args?: SelectSubset<T, HelpCategoryTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpCategoryTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpCategoryTranslations
     * const helpCategoryTranslation = await prisma.helpCategoryTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpCategoryTranslationUpdateManyArgs>(args: SelectSubset<T, HelpCategoryTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HelpCategoryTranslation.
     * @param {HelpCategoryTranslationUpsertArgs} args - Arguments to update or create a HelpCategoryTranslation.
     * @example
     * // Update or create a HelpCategoryTranslation
     * const helpCategoryTranslation = await prisma.helpCategoryTranslation.upsert({
     *   create: {
     *     // ... data to create a HelpCategoryTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpCategoryTranslation we want to update
     *   }
     * })
     */
    upsert<T extends HelpCategoryTranslationUpsertArgs>(args: SelectSubset<T, HelpCategoryTranslationUpsertArgs<ExtArgs>>): Prisma__HelpCategoryTranslationClient<$Result.GetResult<Prisma.$HelpCategoryTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HelpCategoryTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryTranslationCountArgs} args - Arguments to filter HelpCategoryTranslations to count.
     * @example
     * // Count the number of HelpCategoryTranslations
     * const count = await prisma.helpCategoryTranslation.count({
     *   where: {
     *     // ... the filter for the HelpCategoryTranslations we want to count
     *   }
     * })
    **/
    count<T extends HelpCategoryTranslationCountArgs>(
      args?: Subset<T, HelpCategoryTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpCategoryTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpCategoryTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpCategoryTranslationAggregateArgs>(args: Subset<T, HelpCategoryTranslationAggregateArgs>): Prisma.PrismaPromise<GetHelpCategoryTranslationAggregateType<T>>

    /**
     * Group by HelpCategoryTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpCategoryTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpCategoryTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpCategoryTranslationGroupByArgs['orderBy'] }
        : { orderBy?: HelpCategoryTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpCategoryTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpCategoryTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpCategoryTranslation model
   */
  readonly fields: HelpCategoryTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpCategoryTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpCategoryTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    helpCategory<T extends HelpCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HelpCategoryDefaultArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpCategoryTranslation model
   */ 
  interface HelpCategoryTranslationFieldRefs {
    readonly id: FieldRef<"HelpCategoryTranslation", 'Int'>
    readonly helpCategoryId: FieldRef<"HelpCategoryTranslation", 'Int'>
    readonly lang: FieldRef<"HelpCategoryTranslation", 'String'>
    readonly name: FieldRef<"HelpCategoryTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HelpCategoryTranslation findUnique
   */
  export type HelpCategoryTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategoryTranslation to fetch.
     */
    where: HelpCategoryTranslationWhereUniqueInput
  }

  /**
   * HelpCategoryTranslation findUniqueOrThrow
   */
  export type HelpCategoryTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategoryTranslation to fetch.
     */
    where: HelpCategoryTranslationWhereUniqueInput
  }

  /**
   * HelpCategoryTranslation findFirst
   */
  export type HelpCategoryTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategoryTranslation to fetch.
     */
    where?: HelpCategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategoryTranslations to fetch.
     */
    orderBy?: HelpCategoryTranslationOrderByWithRelationInput | HelpCategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpCategoryTranslations.
     */
    cursor?: HelpCategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpCategoryTranslations.
     */
    distinct?: HelpCategoryTranslationScalarFieldEnum | HelpCategoryTranslationScalarFieldEnum[]
  }

  /**
   * HelpCategoryTranslation findFirstOrThrow
   */
  export type HelpCategoryTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategoryTranslation to fetch.
     */
    where?: HelpCategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategoryTranslations to fetch.
     */
    orderBy?: HelpCategoryTranslationOrderByWithRelationInput | HelpCategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpCategoryTranslations.
     */
    cursor?: HelpCategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategoryTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpCategoryTranslations.
     */
    distinct?: HelpCategoryTranslationScalarFieldEnum | HelpCategoryTranslationScalarFieldEnum[]
  }

  /**
   * HelpCategoryTranslation findMany
   */
  export type HelpCategoryTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HelpCategoryTranslations to fetch.
     */
    where?: HelpCategoryTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpCategoryTranslations to fetch.
     */
    orderBy?: HelpCategoryTranslationOrderByWithRelationInput | HelpCategoryTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpCategoryTranslations.
     */
    cursor?: HelpCategoryTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpCategoryTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpCategoryTranslations.
     */
    skip?: number
    distinct?: HelpCategoryTranslationScalarFieldEnum | HelpCategoryTranslationScalarFieldEnum[]
  }

  /**
   * HelpCategoryTranslation create
   */
  export type HelpCategoryTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpCategoryTranslation.
     */
    data: XOR<HelpCategoryTranslationCreateInput, HelpCategoryTranslationUncheckedCreateInput>
  }

  /**
   * HelpCategoryTranslation createMany
   */
  export type HelpCategoryTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpCategoryTranslations.
     */
    data: HelpCategoryTranslationCreateManyInput | HelpCategoryTranslationCreateManyInput[]
  }

  /**
   * HelpCategoryTranslation createManyAndReturn
   */
  export type HelpCategoryTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HelpCategoryTranslations.
     */
    data: HelpCategoryTranslationCreateManyInput | HelpCategoryTranslationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelpCategoryTranslation update
   */
  export type HelpCategoryTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpCategoryTranslation.
     */
    data: XOR<HelpCategoryTranslationUpdateInput, HelpCategoryTranslationUncheckedUpdateInput>
    /**
     * Choose, which HelpCategoryTranslation to update.
     */
    where: HelpCategoryTranslationWhereUniqueInput
  }

  /**
   * HelpCategoryTranslation updateMany
   */
  export type HelpCategoryTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpCategoryTranslations.
     */
    data: XOR<HelpCategoryTranslationUpdateManyMutationInput, HelpCategoryTranslationUncheckedUpdateManyInput>
    /**
     * Filter which HelpCategoryTranslations to update
     */
    where?: HelpCategoryTranslationWhereInput
  }

  /**
   * HelpCategoryTranslation upsert
   */
  export type HelpCategoryTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpCategoryTranslation to update in case it exists.
     */
    where: HelpCategoryTranslationWhereUniqueInput
    /**
     * In case the HelpCategoryTranslation found by the `where` argument doesn't exist, create a new HelpCategoryTranslation with this data.
     */
    create: XOR<HelpCategoryTranslationCreateInput, HelpCategoryTranslationUncheckedCreateInput>
    /**
     * In case the HelpCategoryTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpCategoryTranslationUpdateInput, HelpCategoryTranslationUncheckedUpdateInput>
  }

  /**
   * HelpCategoryTranslation delete
   */
  export type HelpCategoryTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationInclude<ExtArgs> | null
    /**
     * Filter which HelpCategoryTranslation to delete.
     */
    where: HelpCategoryTranslationWhereUniqueInput
  }

  /**
   * HelpCategoryTranslation deleteMany
   */
  export type HelpCategoryTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpCategoryTranslations to delete
     */
    where?: HelpCategoryTranslationWhereInput
  }

  /**
   * HelpCategoryTranslation without action
   */
  export type HelpCategoryTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpCategoryTranslation
     */
    select?: HelpCategoryTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpCategoryTranslationInclude<ExtArgs> | null
  }


  /**
   * Model HelpArticle
   */

  export type AggregateHelpArticle = {
    _count: HelpArticleCountAggregateOutputType | null
    _avg: HelpArticleAvgAggregateOutputType | null
    _sum: HelpArticleSumAggregateOutputType | null
    _min: HelpArticleMinAggregateOutputType | null
    _max: HelpArticleMaxAggregateOutputType | null
  }

  export type HelpArticleAvgAggregateOutputType = {
    id: number | null
    helpCategoryId: number | null
    sortOrder: number | null
  }

  export type HelpArticleSumAggregateOutputType = {
    id: number | null
    helpCategoryId: number | null
    sortOrder: number | null
  }

  export type HelpArticleMinAggregateOutputType = {
    id: number | null
    helpCategoryId: number | null
    slug: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpArticleMaxAggregateOutputType = {
    id: number | null
    helpCategoryId: number | null
    slug: string | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HelpArticleCountAggregateOutputType = {
    id: number
    helpCategoryId: number
    slug: number
    sortOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HelpArticleAvgAggregateInputType = {
    id?: true
    helpCategoryId?: true
    sortOrder?: true
  }

  export type HelpArticleSumAggregateInputType = {
    id?: true
    helpCategoryId?: true
    sortOrder?: true
  }

  export type HelpArticleMinAggregateInputType = {
    id?: true
    helpCategoryId?: true
    slug?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpArticleMaxAggregateInputType = {
    id?: true
    helpCategoryId?: true
    slug?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HelpArticleCountAggregateInputType = {
    id?: true
    helpCategoryId?: true
    slug?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HelpArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpArticle to aggregate.
     */
    where?: HelpArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticles to fetch.
     */
    orderBy?: HelpArticleOrderByWithRelationInput | HelpArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpArticles
    **/
    _count?: true | HelpArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelpArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelpArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpArticleMaxAggregateInputType
  }

  export type GetHelpArticleAggregateType<T extends HelpArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpArticle[P]>
      : GetScalarType<T[P], AggregateHelpArticle[P]>
  }




  export type HelpArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpArticleWhereInput
    orderBy?: HelpArticleOrderByWithAggregationInput | HelpArticleOrderByWithAggregationInput[]
    by: HelpArticleScalarFieldEnum[] | HelpArticleScalarFieldEnum
    having?: HelpArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpArticleCountAggregateInputType | true
    _avg?: HelpArticleAvgAggregateInputType
    _sum?: HelpArticleSumAggregateInputType
    _min?: HelpArticleMinAggregateInputType
    _max?: HelpArticleMaxAggregateInputType
  }

  export type HelpArticleGroupByOutputType = {
    id: number
    helpCategoryId: number
    slug: string
    sortOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: HelpArticleCountAggregateOutputType | null
    _avg: HelpArticleAvgAggregateOutputType | null
    _sum: HelpArticleSumAggregateOutputType | null
    _min: HelpArticleMinAggregateOutputType | null
    _max: HelpArticleMaxAggregateOutputType | null
  }

  type GetHelpArticleGroupByPayload<T extends HelpArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpArticleGroupByOutputType[P]>
            : GetScalarType<T[P], HelpArticleGroupByOutputType[P]>
        }
      >
    >


  export type HelpArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    helpCategoryId?: boolean
    slug?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    helpCategory?: boolean | HelpCategoryDefaultArgs<ExtArgs>
    translations?: boolean | HelpArticle$translationsArgs<ExtArgs>
    _count?: boolean | HelpArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpArticle"]>

  export type HelpArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    helpCategoryId?: boolean
    slug?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    helpCategory?: boolean | HelpCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpArticle"]>

  export type HelpArticleSelectScalar = {
    id?: boolean
    helpCategoryId?: boolean
    slug?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HelpArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpCategory?: boolean | HelpCategoryDefaultArgs<ExtArgs>
    translations?: boolean | HelpArticle$translationsArgs<ExtArgs>
    _count?: boolean | HelpArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HelpArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpCategory?: boolean | HelpCategoryDefaultArgs<ExtArgs>
  }

  export type $HelpArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpArticle"
    objects: {
      helpCategory: Prisma.$HelpCategoryPayload<ExtArgs>
      translations: Prisma.$HelpArticleTranslationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      helpCategoryId: number
      slug: string
      sortOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["helpArticle"]>
    composites: {}
  }

  type HelpArticleGetPayload<S extends boolean | null | undefined | HelpArticleDefaultArgs> = $Result.GetResult<Prisma.$HelpArticlePayload, S>

  type HelpArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HelpArticleCountAggregateInputType | true
    }

  export interface HelpArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpArticle'], meta: { name: 'HelpArticle' } }
    /**
     * Find zero or one HelpArticle that matches the filter.
     * @param {HelpArticleFindUniqueArgs} args - Arguments to find a HelpArticle
     * @example
     * // Get one HelpArticle
     * const helpArticle = await prisma.helpArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpArticleFindUniqueArgs>(args: SelectSubset<T, HelpArticleFindUniqueArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HelpArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpArticleFindUniqueOrThrowArgs} args - Arguments to find a HelpArticle
     * @example
     * // Get one HelpArticle
     * const helpArticle = await prisma.helpArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HelpArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleFindFirstArgs} args - Arguments to find a HelpArticle
     * @example
     * // Get one HelpArticle
     * const helpArticle = await prisma.helpArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpArticleFindFirstArgs>(args?: SelectSubset<T, HelpArticleFindFirstArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HelpArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleFindFirstOrThrowArgs} args - Arguments to find a HelpArticle
     * @example
     * // Get one HelpArticle
     * const helpArticle = await prisma.helpArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HelpArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpArticles
     * const helpArticles = await prisma.helpArticle.findMany()
     * 
     * // Get first 10 HelpArticles
     * const helpArticles = await prisma.helpArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpArticleWithIdOnly = await prisma.helpArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpArticleFindManyArgs>(args?: SelectSubset<T, HelpArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HelpArticle.
     * @param {HelpArticleCreateArgs} args - Arguments to create a HelpArticle.
     * @example
     * // Create one HelpArticle
     * const HelpArticle = await prisma.helpArticle.create({
     *   data: {
     *     // ... data to create a HelpArticle
     *   }
     * })
     * 
     */
    create<T extends HelpArticleCreateArgs>(args: SelectSubset<T, HelpArticleCreateArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HelpArticles.
     * @param {HelpArticleCreateManyArgs} args - Arguments to create many HelpArticles.
     * @example
     * // Create many HelpArticles
     * const helpArticle = await prisma.helpArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpArticleCreateManyArgs>(args?: SelectSubset<T, HelpArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpArticles and returns the data saved in the database.
     * @param {HelpArticleCreateManyAndReturnArgs} args - Arguments to create many HelpArticles.
     * @example
     * // Create many HelpArticles
     * const helpArticle = await prisma.helpArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpArticles and only return the `id`
     * const helpArticleWithIdOnly = await prisma.helpArticle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelpArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, HelpArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HelpArticle.
     * @param {HelpArticleDeleteArgs} args - Arguments to delete one HelpArticle.
     * @example
     * // Delete one HelpArticle
     * const HelpArticle = await prisma.helpArticle.delete({
     *   where: {
     *     // ... filter to delete one HelpArticle
     *   }
     * })
     * 
     */
    delete<T extends HelpArticleDeleteArgs>(args: SelectSubset<T, HelpArticleDeleteArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HelpArticle.
     * @param {HelpArticleUpdateArgs} args - Arguments to update one HelpArticle.
     * @example
     * // Update one HelpArticle
     * const helpArticle = await prisma.helpArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpArticleUpdateArgs>(args: SelectSubset<T, HelpArticleUpdateArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HelpArticles.
     * @param {HelpArticleDeleteManyArgs} args - Arguments to filter HelpArticles to delete.
     * @example
     * // Delete a few HelpArticles
     * const { count } = await prisma.helpArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpArticleDeleteManyArgs>(args?: SelectSubset<T, HelpArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpArticles
     * const helpArticle = await prisma.helpArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpArticleUpdateManyArgs>(args: SelectSubset<T, HelpArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HelpArticle.
     * @param {HelpArticleUpsertArgs} args - Arguments to update or create a HelpArticle.
     * @example
     * // Update or create a HelpArticle
     * const helpArticle = await prisma.helpArticle.upsert({
     *   create: {
     *     // ... data to create a HelpArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpArticle we want to update
     *   }
     * })
     */
    upsert<T extends HelpArticleUpsertArgs>(args: SelectSubset<T, HelpArticleUpsertArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HelpArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleCountArgs} args - Arguments to filter HelpArticles to count.
     * @example
     * // Count the number of HelpArticles
     * const count = await prisma.helpArticle.count({
     *   where: {
     *     // ... the filter for the HelpArticles we want to count
     *   }
     * })
    **/
    count<T extends HelpArticleCountArgs>(
      args?: Subset<T, HelpArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpArticleAggregateArgs>(args: Subset<T, HelpArticleAggregateArgs>): Prisma.PrismaPromise<GetHelpArticleAggregateType<T>>

    /**
     * Group by HelpArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpArticleGroupByArgs['orderBy'] }
        : { orderBy?: HelpArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpArticle model
   */
  readonly fields: HelpArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    helpCategory<T extends HelpCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HelpCategoryDefaultArgs<ExtArgs>>): Prisma__HelpCategoryClient<$Result.GetResult<Prisma.$HelpCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    translations<T extends HelpArticle$translationsArgs<ExtArgs> = {}>(args?: Subset<T, HelpArticle$translationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpArticleTranslationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpArticle model
   */ 
  interface HelpArticleFieldRefs {
    readonly id: FieldRef<"HelpArticle", 'Int'>
    readonly helpCategoryId: FieldRef<"HelpArticle", 'Int'>
    readonly slug: FieldRef<"HelpArticle", 'String'>
    readonly sortOrder: FieldRef<"HelpArticle", 'Int'>
    readonly isActive: FieldRef<"HelpArticle", 'Boolean'>
    readonly createdAt: FieldRef<"HelpArticle", 'DateTime'>
    readonly updatedAt: FieldRef<"HelpArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HelpArticle findUnique
   */
  export type HelpArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticle to fetch.
     */
    where: HelpArticleWhereUniqueInput
  }

  /**
   * HelpArticle findUniqueOrThrow
   */
  export type HelpArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticle to fetch.
     */
    where: HelpArticleWhereUniqueInput
  }

  /**
   * HelpArticle findFirst
   */
  export type HelpArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticle to fetch.
     */
    where?: HelpArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticles to fetch.
     */
    orderBy?: HelpArticleOrderByWithRelationInput | HelpArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpArticles.
     */
    cursor?: HelpArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpArticles.
     */
    distinct?: HelpArticleScalarFieldEnum | HelpArticleScalarFieldEnum[]
  }

  /**
   * HelpArticle findFirstOrThrow
   */
  export type HelpArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticle to fetch.
     */
    where?: HelpArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticles to fetch.
     */
    orderBy?: HelpArticleOrderByWithRelationInput | HelpArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpArticles.
     */
    cursor?: HelpArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpArticles.
     */
    distinct?: HelpArticleScalarFieldEnum | HelpArticleScalarFieldEnum[]
  }

  /**
   * HelpArticle findMany
   */
  export type HelpArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticles to fetch.
     */
    where?: HelpArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticles to fetch.
     */
    orderBy?: HelpArticleOrderByWithRelationInput | HelpArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpArticles.
     */
    cursor?: HelpArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticles.
     */
    skip?: number
    distinct?: HelpArticleScalarFieldEnum | HelpArticleScalarFieldEnum[]
  }

  /**
   * HelpArticle create
   */
  export type HelpArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpArticle.
     */
    data: XOR<HelpArticleCreateInput, HelpArticleUncheckedCreateInput>
  }

  /**
   * HelpArticle createMany
   */
  export type HelpArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpArticles.
     */
    data: HelpArticleCreateManyInput | HelpArticleCreateManyInput[]
  }

  /**
   * HelpArticle createManyAndReturn
   */
  export type HelpArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HelpArticles.
     */
    data: HelpArticleCreateManyInput | HelpArticleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelpArticle update
   */
  export type HelpArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpArticle.
     */
    data: XOR<HelpArticleUpdateInput, HelpArticleUncheckedUpdateInput>
    /**
     * Choose, which HelpArticle to update.
     */
    where: HelpArticleWhereUniqueInput
  }

  /**
   * HelpArticle updateMany
   */
  export type HelpArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpArticles.
     */
    data: XOR<HelpArticleUpdateManyMutationInput, HelpArticleUncheckedUpdateManyInput>
    /**
     * Filter which HelpArticles to update
     */
    where?: HelpArticleWhereInput
  }

  /**
   * HelpArticle upsert
   */
  export type HelpArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpArticle to update in case it exists.
     */
    where: HelpArticleWhereUniqueInput
    /**
     * In case the HelpArticle found by the `where` argument doesn't exist, create a new HelpArticle with this data.
     */
    create: XOR<HelpArticleCreateInput, HelpArticleUncheckedCreateInput>
    /**
     * In case the HelpArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpArticleUpdateInput, HelpArticleUncheckedUpdateInput>
  }

  /**
   * HelpArticle delete
   */
  export type HelpArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
    /**
     * Filter which HelpArticle to delete.
     */
    where: HelpArticleWhereUniqueInput
  }

  /**
   * HelpArticle deleteMany
   */
  export type HelpArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpArticles to delete
     */
    where?: HelpArticleWhereInput
  }

  /**
   * HelpArticle.translations
   */
  export type HelpArticle$translationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationInclude<ExtArgs> | null
    where?: HelpArticleTranslationWhereInput
    orderBy?: HelpArticleTranslationOrderByWithRelationInput | HelpArticleTranslationOrderByWithRelationInput[]
    cursor?: HelpArticleTranslationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HelpArticleTranslationScalarFieldEnum | HelpArticleTranslationScalarFieldEnum[]
  }

  /**
   * HelpArticle without action
   */
  export type HelpArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticle
     */
    select?: HelpArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleInclude<ExtArgs> | null
  }


  /**
   * Model HelpArticleTranslation
   */

  export type AggregateHelpArticleTranslation = {
    _count: HelpArticleTranslationCountAggregateOutputType | null
    _avg: HelpArticleTranslationAvgAggregateOutputType | null
    _sum: HelpArticleTranslationSumAggregateOutputType | null
    _min: HelpArticleTranslationMinAggregateOutputType | null
    _max: HelpArticleTranslationMaxAggregateOutputType | null
  }

  export type HelpArticleTranslationAvgAggregateOutputType = {
    id: number | null
    helpArticleId: number | null
  }

  export type HelpArticleTranslationSumAggregateOutputType = {
    id: number | null
    helpArticleId: number | null
  }

  export type HelpArticleTranslationMinAggregateOutputType = {
    id: number | null
    helpArticleId: number | null
    lang: string | null
    title: string | null
    content: string | null
  }

  export type HelpArticleTranslationMaxAggregateOutputType = {
    id: number | null
    helpArticleId: number | null
    lang: string | null
    title: string | null
    content: string | null
  }

  export type HelpArticleTranslationCountAggregateOutputType = {
    id: number
    helpArticleId: number
    lang: number
    title: number
    content: number
    _all: number
  }


  export type HelpArticleTranslationAvgAggregateInputType = {
    id?: true
    helpArticleId?: true
  }

  export type HelpArticleTranslationSumAggregateInputType = {
    id?: true
    helpArticleId?: true
  }

  export type HelpArticleTranslationMinAggregateInputType = {
    id?: true
    helpArticleId?: true
    lang?: true
    title?: true
    content?: true
  }

  export type HelpArticleTranslationMaxAggregateInputType = {
    id?: true
    helpArticleId?: true
    lang?: true
    title?: true
    content?: true
  }

  export type HelpArticleTranslationCountAggregateInputType = {
    id?: true
    helpArticleId?: true
    lang?: true
    title?: true
    content?: true
    _all?: true
  }

  export type HelpArticleTranslationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpArticleTranslation to aggregate.
     */
    where?: HelpArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticleTranslations to fetch.
     */
    orderBy?: HelpArticleTranslationOrderByWithRelationInput | HelpArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HelpArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HelpArticleTranslations
    **/
    _count?: true | HelpArticleTranslationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HelpArticleTranslationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HelpArticleTranslationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HelpArticleTranslationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HelpArticleTranslationMaxAggregateInputType
  }

  export type GetHelpArticleTranslationAggregateType<T extends HelpArticleTranslationAggregateArgs> = {
        [P in keyof T & keyof AggregateHelpArticleTranslation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHelpArticleTranslation[P]>
      : GetScalarType<T[P], AggregateHelpArticleTranslation[P]>
  }




  export type HelpArticleTranslationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HelpArticleTranslationWhereInput
    orderBy?: HelpArticleTranslationOrderByWithAggregationInput | HelpArticleTranslationOrderByWithAggregationInput[]
    by: HelpArticleTranslationScalarFieldEnum[] | HelpArticleTranslationScalarFieldEnum
    having?: HelpArticleTranslationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HelpArticleTranslationCountAggregateInputType | true
    _avg?: HelpArticleTranslationAvgAggregateInputType
    _sum?: HelpArticleTranslationSumAggregateInputType
    _min?: HelpArticleTranslationMinAggregateInputType
    _max?: HelpArticleTranslationMaxAggregateInputType
  }

  export type HelpArticleTranslationGroupByOutputType = {
    id: number
    helpArticleId: number
    lang: string
    title: string
    content: string
    _count: HelpArticleTranslationCountAggregateOutputType | null
    _avg: HelpArticleTranslationAvgAggregateOutputType | null
    _sum: HelpArticleTranslationSumAggregateOutputType | null
    _min: HelpArticleTranslationMinAggregateOutputType | null
    _max: HelpArticleTranslationMaxAggregateOutputType | null
  }

  type GetHelpArticleTranslationGroupByPayload<T extends HelpArticleTranslationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HelpArticleTranslationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HelpArticleTranslationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HelpArticleTranslationGroupByOutputType[P]>
            : GetScalarType<T[P], HelpArticleTranslationGroupByOutputType[P]>
        }
      >
    >


  export type HelpArticleTranslationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    helpArticleId?: boolean
    lang?: boolean
    title?: boolean
    content?: boolean
    helpArticle?: boolean | HelpArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpArticleTranslation"]>

  export type HelpArticleTranslationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    helpArticleId?: boolean
    lang?: boolean
    title?: boolean
    content?: boolean
    helpArticle?: boolean | HelpArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["helpArticleTranslation"]>

  export type HelpArticleTranslationSelectScalar = {
    id?: boolean
    helpArticleId?: boolean
    lang?: boolean
    title?: boolean
    content?: boolean
  }

  export type HelpArticleTranslationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpArticle?: boolean | HelpArticleDefaultArgs<ExtArgs>
  }
  export type HelpArticleTranslationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    helpArticle?: boolean | HelpArticleDefaultArgs<ExtArgs>
  }

  export type $HelpArticleTranslationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HelpArticleTranslation"
    objects: {
      helpArticle: Prisma.$HelpArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      helpArticleId: number
      lang: string
      title: string
      content: string
    }, ExtArgs["result"]["helpArticleTranslation"]>
    composites: {}
  }

  type HelpArticleTranslationGetPayload<S extends boolean | null | undefined | HelpArticleTranslationDefaultArgs> = $Result.GetResult<Prisma.$HelpArticleTranslationPayload, S>

  type HelpArticleTranslationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HelpArticleTranslationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HelpArticleTranslationCountAggregateInputType | true
    }

  export interface HelpArticleTranslationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HelpArticleTranslation'], meta: { name: 'HelpArticleTranslation' } }
    /**
     * Find zero or one HelpArticleTranslation that matches the filter.
     * @param {HelpArticleTranslationFindUniqueArgs} args - Arguments to find a HelpArticleTranslation
     * @example
     * // Get one HelpArticleTranslation
     * const helpArticleTranslation = await prisma.helpArticleTranslation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HelpArticleTranslationFindUniqueArgs>(args: SelectSubset<T, HelpArticleTranslationFindUniqueArgs<ExtArgs>>): Prisma__HelpArticleTranslationClient<$Result.GetResult<Prisma.$HelpArticleTranslationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HelpArticleTranslation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HelpArticleTranslationFindUniqueOrThrowArgs} args - Arguments to find a HelpArticleTranslation
     * @example
     * // Get one HelpArticleTranslation
     * const helpArticleTranslation = await prisma.helpArticleTranslation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HelpArticleTranslationFindUniqueOrThrowArgs>(args: SelectSubset<T, HelpArticleTranslationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HelpArticleTranslationClient<$Result.GetResult<Prisma.$HelpArticleTranslationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HelpArticleTranslation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleTranslationFindFirstArgs} args - Arguments to find a HelpArticleTranslation
     * @example
     * // Get one HelpArticleTranslation
     * const helpArticleTranslation = await prisma.helpArticleTranslation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HelpArticleTranslationFindFirstArgs>(args?: SelectSubset<T, HelpArticleTranslationFindFirstArgs<ExtArgs>>): Prisma__HelpArticleTranslationClient<$Result.GetResult<Prisma.$HelpArticleTranslationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HelpArticleTranslation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleTranslationFindFirstOrThrowArgs} args - Arguments to find a HelpArticleTranslation
     * @example
     * // Get one HelpArticleTranslation
     * const helpArticleTranslation = await prisma.helpArticleTranslation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HelpArticleTranslationFindFirstOrThrowArgs>(args?: SelectSubset<T, HelpArticleTranslationFindFirstOrThrowArgs<ExtArgs>>): Prisma__HelpArticleTranslationClient<$Result.GetResult<Prisma.$HelpArticleTranslationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HelpArticleTranslations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleTranslationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HelpArticleTranslations
     * const helpArticleTranslations = await prisma.helpArticleTranslation.findMany()
     * 
     * // Get first 10 HelpArticleTranslations
     * const helpArticleTranslations = await prisma.helpArticleTranslation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const helpArticleTranslationWithIdOnly = await prisma.helpArticleTranslation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HelpArticleTranslationFindManyArgs>(args?: SelectSubset<T, HelpArticleTranslationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpArticleTranslationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HelpArticleTranslation.
     * @param {HelpArticleTranslationCreateArgs} args - Arguments to create a HelpArticleTranslation.
     * @example
     * // Create one HelpArticleTranslation
     * const HelpArticleTranslation = await prisma.helpArticleTranslation.create({
     *   data: {
     *     // ... data to create a HelpArticleTranslation
     *   }
     * })
     * 
     */
    create<T extends HelpArticleTranslationCreateArgs>(args: SelectSubset<T, HelpArticleTranslationCreateArgs<ExtArgs>>): Prisma__HelpArticleTranslationClient<$Result.GetResult<Prisma.$HelpArticleTranslationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HelpArticleTranslations.
     * @param {HelpArticleTranslationCreateManyArgs} args - Arguments to create many HelpArticleTranslations.
     * @example
     * // Create many HelpArticleTranslations
     * const helpArticleTranslation = await prisma.helpArticleTranslation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HelpArticleTranslationCreateManyArgs>(args?: SelectSubset<T, HelpArticleTranslationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HelpArticleTranslations and returns the data saved in the database.
     * @param {HelpArticleTranslationCreateManyAndReturnArgs} args - Arguments to create many HelpArticleTranslations.
     * @example
     * // Create many HelpArticleTranslations
     * const helpArticleTranslation = await prisma.helpArticleTranslation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HelpArticleTranslations and only return the `id`
     * const helpArticleTranslationWithIdOnly = await prisma.helpArticleTranslation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HelpArticleTranslationCreateManyAndReturnArgs>(args?: SelectSubset<T, HelpArticleTranslationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HelpArticleTranslationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HelpArticleTranslation.
     * @param {HelpArticleTranslationDeleteArgs} args - Arguments to delete one HelpArticleTranslation.
     * @example
     * // Delete one HelpArticleTranslation
     * const HelpArticleTranslation = await prisma.helpArticleTranslation.delete({
     *   where: {
     *     // ... filter to delete one HelpArticleTranslation
     *   }
     * })
     * 
     */
    delete<T extends HelpArticleTranslationDeleteArgs>(args: SelectSubset<T, HelpArticleTranslationDeleteArgs<ExtArgs>>): Prisma__HelpArticleTranslationClient<$Result.GetResult<Prisma.$HelpArticleTranslationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HelpArticleTranslation.
     * @param {HelpArticleTranslationUpdateArgs} args - Arguments to update one HelpArticleTranslation.
     * @example
     * // Update one HelpArticleTranslation
     * const helpArticleTranslation = await prisma.helpArticleTranslation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HelpArticleTranslationUpdateArgs>(args: SelectSubset<T, HelpArticleTranslationUpdateArgs<ExtArgs>>): Prisma__HelpArticleTranslationClient<$Result.GetResult<Prisma.$HelpArticleTranslationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HelpArticleTranslations.
     * @param {HelpArticleTranslationDeleteManyArgs} args - Arguments to filter HelpArticleTranslations to delete.
     * @example
     * // Delete a few HelpArticleTranslations
     * const { count } = await prisma.helpArticleTranslation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HelpArticleTranslationDeleteManyArgs>(args?: SelectSubset<T, HelpArticleTranslationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HelpArticleTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleTranslationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HelpArticleTranslations
     * const helpArticleTranslation = await prisma.helpArticleTranslation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HelpArticleTranslationUpdateManyArgs>(args: SelectSubset<T, HelpArticleTranslationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HelpArticleTranslation.
     * @param {HelpArticleTranslationUpsertArgs} args - Arguments to update or create a HelpArticleTranslation.
     * @example
     * // Update or create a HelpArticleTranslation
     * const helpArticleTranslation = await prisma.helpArticleTranslation.upsert({
     *   create: {
     *     // ... data to create a HelpArticleTranslation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HelpArticleTranslation we want to update
     *   }
     * })
     */
    upsert<T extends HelpArticleTranslationUpsertArgs>(args: SelectSubset<T, HelpArticleTranslationUpsertArgs<ExtArgs>>): Prisma__HelpArticleTranslationClient<$Result.GetResult<Prisma.$HelpArticleTranslationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HelpArticleTranslations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleTranslationCountArgs} args - Arguments to filter HelpArticleTranslations to count.
     * @example
     * // Count the number of HelpArticleTranslations
     * const count = await prisma.helpArticleTranslation.count({
     *   where: {
     *     // ... the filter for the HelpArticleTranslations we want to count
     *   }
     * })
    **/
    count<T extends HelpArticleTranslationCountArgs>(
      args?: Subset<T, HelpArticleTranslationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HelpArticleTranslationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HelpArticleTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleTranslationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HelpArticleTranslationAggregateArgs>(args: Subset<T, HelpArticleTranslationAggregateArgs>): Prisma.PrismaPromise<GetHelpArticleTranslationAggregateType<T>>

    /**
     * Group by HelpArticleTranslation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HelpArticleTranslationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HelpArticleTranslationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HelpArticleTranslationGroupByArgs['orderBy'] }
        : { orderBy?: HelpArticleTranslationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HelpArticleTranslationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHelpArticleTranslationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HelpArticleTranslation model
   */
  readonly fields: HelpArticleTranslationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HelpArticleTranslation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HelpArticleTranslationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    helpArticle<T extends HelpArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HelpArticleDefaultArgs<ExtArgs>>): Prisma__HelpArticleClient<$Result.GetResult<Prisma.$HelpArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HelpArticleTranslation model
   */ 
  interface HelpArticleTranslationFieldRefs {
    readonly id: FieldRef<"HelpArticleTranslation", 'Int'>
    readonly helpArticleId: FieldRef<"HelpArticleTranslation", 'Int'>
    readonly lang: FieldRef<"HelpArticleTranslation", 'String'>
    readonly title: FieldRef<"HelpArticleTranslation", 'String'>
    readonly content: FieldRef<"HelpArticleTranslation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HelpArticleTranslation findUnique
   */
  export type HelpArticleTranslationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticleTranslation to fetch.
     */
    where: HelpArticleTranslationWhereUniqueInput
  }

  /**
   * HelpArticleTranslation findUniqueOrThrow
   */
  export type HelpArticleTranslationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticleTranslation to fetch.
     */
    where: HelpArticleTranslationWhereUniqueInput
  }

  /**
   * HelpArticleTranslation findFirst
   */
  export type HelpArticleTranslationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticleTranslation to fetch.
     */
    where?: HelpArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticleTranslations to fetch.
     */
    orderBy?: HelpArticleTranslationOrderByWithRelationInput | HelpArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpArticleTranslations.
     */
    cursor?: HelpArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpArticleTranslations.
     */
    distinct?: HelpArticleTranslationScalarFieldEnum | HelpArticleTranslationScalarFieldEnum[]
  }

  /**
   * HelpArticleTranslation findFirstOrThrow
   */
  export type HelpArticleTranslationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticleTranslation to fetch.
     */
    where?: HelpArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticleTranslations to fetch.
     */
    orderBy?: HelpArticleTranslationOrderByWithRelationInput | HelpArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HelpArticleTranslations.
     */
    cursor?: HelpArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticleTranslations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HelpArticleTranslations.
     */
    distinct?: HelpArticleTranslationScalarFieldEnum | HelpArticleTranslationScalarFieldEnum[]
  }

  /**
   * HelpArticleTranslation findMany
   */
  export type HelpArticleTranslationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter, which HelpArticleTranslations to fetch.
     */
    where?: HelpArticleTranslationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HelpArticleTranslations to fetch.
     */
    orderBy?: HelpArticleTranslationOrderByWithRelationInput | HelpArticleTranslationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HelpArticleTranslations.
     */
    cursor?: HelpArticleTranslationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HelpArticleTranslations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HelpArticleTranslations.
     */
    skip?: number
    distinct?: HelpArticleTranslationScalarFieldEnum | HelpArticleTranslationScalarFieldEnum[]
  }

  /**
   * HelpArticleTranslation create
   */
  export type HelpArticleTranslationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationInclude<ExtArgs> | null
    /**
     * The data needed to create a HelpArticleTranslation.
     */
    data: XOR<HelpArticleTranslationCreateInput, HelpArticleTranslationUncheckedCreateInput>
  }

  /**
   * HelpArticleTranslation createMany
   */
  export type HelpArticleTranslationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HelpArticleTranslations.
     */
    data: HelpArticleTranslationCreateManyInput | HelpArticleTranslationCreateManyInput[]
  }

  /**
   * HelpArticleTranslation createManyAndReturn
   */
  export type HelpArticleTranslationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HelpArticleTranslations.
     */
    data: HelpArticleTranslationCreateManyInput | HelpArticleTranslationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HelpArticleTranslation update
   */
  export type HelpArticleTranslationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationInclude<ExtArgs> | null
    /**
     * The data needed to update a HelpArticleTranslation.
     */
    data: XOR<HelpArticleTranslationUpdateInput, HelpArticleTranslationUncheckedUpdateInput>
    /**
     * Choose, which HelpArticleTranslation to update.
     */
    where: HelpArticleTranslationWhereUniqueInput
  }

  /**
   * HelpArticleTranslation updateMany
   */
  export type HelpArticleTranslationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HelpArticleTranslations.
     */
    data: XOR<HelpArticleTranslationUpdateManyMutationInput, HelpArticleTranslationUncheckedUpdateManyInput>
    /**
     * Filter which HelpArticleTranslations to update
     */
    where?: HelpArticleTranslationWhereInput
  }

  /**
   * HelpArticleTranslation upsert
   */
  export type HelpArticleTranslationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationInclude<ExtArgs> | null
    /**
     * The filter to search for the HelpArticleTranslation to update in case it exists.
     */
    where: HelpArticleTranslationWhereUniqueInput
    /**
     * In case the HelpArticleTranslation found by the `where` argument doesn't exist, create a new HelpArticleTranslation with this data.
     */
    create: XOR<HelpArticleTranslationCreateInput, HelpArticleTranslationUncheckedCreateInput>
    /**
     * In case the HelpArticleTranslation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HelpArticleTranslationUpdateInput, HelpArticleTranslationUncheckedUpdateInput>
  }

  /**
   * HelpArticleTranslation delete
   */
  export type HelpArticleTranslationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationInclude<ExtArgs> | null
    /**
     * Filter which HelpArticleTranslation to delete.
     */
    where: HelpArticleTranslationWhereUniqueInput
  }

  /**
   * HelpArticleTranslation deleteMany
   */
  export type HelpArticleTranslationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HelpArticleTranslations to delete
     */
    where?: HelpArticleTranslationWhereInput
  }

  /**
   * HelpArticleTranslation without action
   */
  export type HelpArticleTranslationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HelpArticleTranslation
     */
    select?: HelpArticleTranslationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HelpArticleTranslationInclude<ExtArgs> | null
  }


  /**
   * Model OrderSequence
   */

  export type AggregateOrderSequence = {
    _count: OrderSequenceCountAggregateOutputType | null
    _avg: OrderSequenceAvgAggregateOutputType | null
    _sum: OrderSequenceSumAggregateOutputType | null
    _min: OrderSequenceMinAggregateOutputType | null
    _max: OrderSequenceMaxAggregateOutputType | null
  }

  export type OrderSequenceAvgAggregateOutputType = {
    id: number | null
    currentValue: number | null
  }

  export type OrderSequenceSumAggregateOutputType = {
    id: number | null
    currentValue: number | null
  }

  export type OrderSequenceMinAggregateOutputType = {
    id: number | null
    currentValue: number | null
  }

  export type OrderSequenceMaxAggregateOutputType = {
    id: number | null
    currentValue: number | null
  }

  export type OrderSequenceCountAggregateOutputType = {
    id: number
    currentValue: number
    _all: number
  }


  export type OrderSequenceAvgAggregateInputType = {
    id?: true
    currentValue?: true
  }

  export type OrderSequenceSumAggregateInputType = {
    id?: true
    currentValue?: true
  }

  export type OrderSequenceMinAggregateInputType = {
    id?: true
    currentValue?: true
  }

  export type OrderSequenceMaxAggregateInputType = {
    id?: true
    currentValue?: true
  }

  export type OrderSequenceCountAggregateInputType = {
    id?: true
    currentValue?: true
    _all?: true
  }

  export type OrderSequenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderSequence to aggregate.
     */
    where?: OrderSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSequences to fetch.
     */
    orderBy?: OrderSequenceOrderByWithRelationInput | OrderSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderSequences
    **/
    _count?: true | OrderSequenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderSequenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSequenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderSequenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderSequenceMaxAggregateInputType
  }

  export type GetOrderSequenceAggregateType<T extends OrderSequenceAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderSequence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderSequence[P]>
      : GetScalarType<T[P], AggregateOrderSequence[P]>
  }




  export type OrderSequenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderSequenceWhereInput
    orderBy?: OrderSequenceOrderByWithAggregationInput | OrderSequenceOrderByWithAggregationInput[]
    by: OrderSequenceScalarFieldEnum[] | OrderSequenceScalarFieldEnum
    having?: OrderSequenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderSequenceCountAggregateInputType | true
    _avg?: OrderSequenceAvgAggregateInputType
    _sum?: OrderSequenceSumAggregateInputType
    _min?: OrderSequenceMinAggregateInputType
    _max?: OrderSequenceMaxAggregateInputType
  }

  export type OrderSequenceGroupByOutputType = {
    id: number
    currentValue: number
    _count: OrderSequenceCountAggregateOutputType | null
    _avg: OrderSequenceAvgAggregateOutputType | null
    _sum: OrderSequenceSumAggregateOutputType | null
    _min: OrderSequenceMinAggregateOutputType | null
    _max: OrderSequenceMaxAggregateOutputType | null
  }

  type GetOrderSequenceGroupByPayload<T extends OrderSequenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderSequenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderSequenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderSequenceGroupByOutputType[P]>
            : GetScalarType<T[P], OrderSequenceGroupByOutputType[P]>
        }
      >
    >


  export type OrderSequenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentValue?: boolean
  }, ExtArgs["result"]["orderSequence"]>

  export type OrderSequenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    currentValue?: boolean
  }, ExtArgs["result"]["orderSequence"]>

  export type OrderSequenceSelectScalar = {
    id?: boolean
    currentValue?: boolean
  }


  export type $OrderSequencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderSequence"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      currentValue: number
    }, ExtArgs["result"]["orderSequence"]>
    composites: {}
  }

  type OrderSequenceGetPayload<S extends boolean | null | undefined | OrderSequenceDefaultArgs> = $Result.GetResult<Prisma.$OrderSequencePayload, S>

  type OrderSequenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderSequenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderSequenceCountAggregateInputType | true
    }

  export interface OrderSequenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderSequence'], meta: { name: 'OrderSequence' } }
    /**
     * Find zero or one OrderSequence that matches the filter.
     * @param {OrderSequenceFindUniqueArgs} args - Arguments to find a OrderSequence
     * @example
     * // Get one OrderSequence
     * const orderSequence = await prisma.orderSequence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderSequenceFindUniqueArgs>(args: SelectSubset<T, OrderSequenceFindUniqueArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderSequence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderSequenceFindUniqueOrThrowArgs} args - Arguments to find a OrderSequence
     * @example
     * // Get one OrderSequence
     * const orderSequence = await prisma.orderSequence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderSequenceFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderSequenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderSequence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceFindFirstArgs} args - Arguments to find a OrderSequence
     * @example
     * // Get one OrderSequence
     * const orderSequence = await prisma.orderSequence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderSequenceFindFirstArgs>(args?: SelectSubset<T, OrderSequenceFindFirstArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderSequence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceFindFirstOrThrowArgs} args - Arguments to find a OrderSequence
     * @example
     * // Get one OrderSequence
     * const orderSequence = await prisma.orderSequence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderSequenceFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderSequenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderSequences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderSequences
     * const orderSequences = await prisma.orderSequence.findMany()
     * 
     * // Get first 10 OrderSequences
     * const orderSequences = await prisma.orderSequence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderSequenceWithIdOnly = await prisma.orderSequence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderSequenceFindManyArgs>(args?: SelectSubset<T, OrderSequenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderSequence.
     * @param {OrderSequenceCreateArgs} args - Arguments to create a OrderSequence.
     * @example
     * // Create one OrderSequence
     * const OrderSequence = await prisma.orderSequence.create({
     *   data: {
     *     // ... data to create a OrderSequence
     *   }
     * })
     * 
     */
    create<T extends OrderSequenceCreateArgs>(args: SelectSubset<T, OrderSequenceCreateArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderSequences.
     * @param {OrderSequenceCreateManyArgs} args - Arguments to create many OrderSequences.
     * @example
     * // Create many OrderSequences
     * const orderSequence = await prisma.orderSequence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderSequenceCreateManyArgs>(args?: SelectSubset<T, OrderSequenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderSequences and returns the data saved in the database.
     * @param {OrderSequenceCreateManyAndReturnArgs} args - Arguments to create many OrderSequences.
     * @example
     * // Create many OrderSequences
     * const orderSequence = await prisma.orderSequence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderSequences and only return the `id`
     * const orderSequenceWithIdOnly = await prisma.orderSequence.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderSequenceCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderSequenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderSequence.
     * @param {OrderSequenceDeleteArgs} args - Arguments to delete one OrderSequence.
     * @example
     * // Delete one OrderSequence
     * const OrderSequence = await prisma.orderSequence.delete({
     *   where: {
     *     // ... filter to delete one OrderSequence
     *   }
     * })
     * 
     */
    delete<T extends OrderSequenceDeleteArgs>(args: SelectSubset<T, OrderSequenceDeleteArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderSequence.
     * @param {OrderSequenceUpdateArgs} args - Arguments to update one OrderSequence.
     * @example
     * // Update one OrderSequence
     * const orderSequence = await prisma.orderSequence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderSequenceUpdateArgs>(args: SelectSubset<T, OrderSequenceUpdateArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderSequences.
     * @param {OrderSequenceDeleteManyArgs} args - Arguments to filter OrderSequences to delete.
     * @example
     * // Delete a few OrderSequences
     * const { count } = await prisma.orderSequence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderSequenceDeleteManyArgs>(args?: SelectSubset<T, OrderSequenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderSequences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderSequences
     * const orderSequence = await prisma.orderSequence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderSequenceUpdateManyArgs>(args: SelectSubset<T, OrderSequenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderSequence.
     * @param {OrderSequenceUpsertArgs} args - Arguments to update or create a OrderSequence.
     * @example
     * // Update or create a OrderSequence
     * const orderSequence = await prisma.orderSequence.upsert({
     *   create: {
     *     // ... data to create a OrderSequence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderSequence we want to update
     *   }
     * })
     */
    upsert<T extends OrderSequenceUpsertArgs>(args: SelectSubset<T, OrderSequenceUpsertArgs<ExtArgs>>): Prisma__OrderSequenceClient<$Result.GetResult<Prisma.$OrderSequencePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderSequences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceCountArgs} args - Arguments to filter OrderSequences to count.
     * @example
     * // Count the number of OrderSequences
     * const count = await prisma.orderSequence.count({
     *   where: {
     *     // ... the filter for the OrderSequences we want to count
     *   }
     * })
    **/
    count<T extends OrderSequenceCountArgs>(
      args?: Subset<T, OrderSequenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderSequenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderSequence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderSequenceAggregateArgs>(args: Subset<T, OrderSequenceAggregateArgs>): Prisma.PrismaPromise<GetOrderSequenceAggregateType<T>>

    /**
     * Group by OrderSequence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSequenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderSequenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderSequenceGroupByArgs['orderBy'] }
        : { orderBy?: OrderSequenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderSequenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderSequenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderSequence model
   */
  readonly fields: OrderSequenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderSequence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderSequenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderSequence model
   */ 
  interface OrderSequenceFieldRefs {
    readonly id: FieldRef<"OrderSequence", 'Int'>
    readonly currentValue: FieldRef<"OrderSequence", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrderSequence findUnique
   */
  export type OrderSequenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Filter, which OrderSequence to fetch.
     */
    where: OrderSequenceWhereUniqueInput
  }

  /**
   * OrderSequence findUniqueOrThrow
   */
  export type OrderSequenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Filter, which OrderSequence to fetch.
     */
    where: OrderSequenceWhereUniqueInput
  }

  /**
   * OrderSequence findFirst
   */
  export type OrderSequenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Filter, which OrderSequence to fetch.
     */
    where?: OrderSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSequences to fetch.
     */
    orderBy?: OrderSequenceOrderByWithRelationInput | OrderSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderSequences.
     */
    cursor?: OrderSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderSequences.
     */
    distinct?: OrderSequenceScalarFieldEnum | OrderSequenceScalarFieldEnum[]
  }

  /**
   * OrderSequence findFirstOrThrow
   */
  export type OrderSequenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Filter, which OrderSequence to fetch.
     */
    where?: OrderSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSequences to fetch.
     */
    orderBy?: OrderSequenceOrderByWithRelationInput | OrderSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderSequences.
     */
    cursor?: OrderSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSequences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderSequences.
     */
    distinct?: OrderSequenceScalarFieldEnum | OrderSequenceScalarFieldEnum[]
  }

  /**
   * OrderSequence findMany
   */
  export type OrderSequenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Filter, which OrderSequences to fetch.
     */
    where?: OrderSequenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSequences to fetch.
     */
    orderBy?: OrderSequenceOrderByWithRelationInput | OrderSequenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderSequences.
     */
    cursor?: OrderSequenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSequences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSequences.
     */
    skip?: number
    distinct?: OrderSequenceScalarFieldEnum | OrderSequenceScalarFieldEnum[]
  }

  /**
   * OrderSequence create
   */
  export type OrderSequenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * The data needed to create a OrderSequence.
     */
    data?: XOR<OrderSequenceCreateInput, OrderSequenceUncheckedCreateInput>
  }

  /**
   * OrderSequence createMany
   */
  export type OrderSequenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderSequences.
     */
    data: OrderSequenceCreateManyInput | OrderSequenceCreateManyInput[]
  }

  /**
   * OrderSequence createManyAndReturn
   */
  export type OrderSequenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderSequences.
     */
    data: OrderSequenceCreateManyInput | OrderSequenceCreateManyInput[]
  }

  /**
   * OrderSequence update
   */
  export type OrderSequenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * The data needed to update a OrderSequence.
     */
    data: XOR<OrderSequenceUpdateInput, OrderSequenceUncheckedUpdateInput>
    /**
     * Choose, which OrderSequence to update.
     */
    where: OrderSequenceWhereUniqueInput
  }

  /**
   * OrderSequence updateMany
   */
  export type OrderSequenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderSequences.
     */
    data: XOR<OrderSequenceUpdateManyMutationInput, OrderSequenceUncheckedUpdateManyInput>
    /**
     * Filter which OrderSequences to update
     */
    where?: OrderSequenceWhereInput
  }

  /**
   * OrderSequence upsert
   */
  export type OrderSequenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * The filter to search for the OrderSequence to update in case it exists.
     */
    where: OrderSequenceWhereUniqueInput
    /**
     * In case the OrderSequence found by the `where` argument doesn't exist, create a new OrderSequence with this data.
     */
    create: XOR<OrderSequenceCreateInput, OrderSequenceUncheckedCreateInput>
    /**
     * In case the OrderSequence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderSequenceUpdateInput, OrderSequenceUncheckedUpdateInput>
  }

  /**
   * OrderSequence delete
   */
  export type OrderSequenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
    /**
     * Filter which OrderSequence to delete.
     */
    where: OrderSequenceWhereUniqueInput
  }

  /**
   * OrderSequence deleteMany
   */
  export type OrderSequenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderSequences to delete
     */
    where?: OrderSequenceWhereInput
  }

  /**
   * OrderSequence without action
   */
  export type OrderSequenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSequence
     */
    select?: OrderSequenceSelect<ExtArgs> | null
  }


  /**
   * Model NPSender
   */

  export type AggregateNPSender = {
    _count: NPSenderCountAggregateOutputType | null
    _avg: NPSenderAvgAggregateOutputType | null
    _sum: NPSenderSumAggregateOutputType | null
    _min: NPSenderMinAggregateOutputType | null
    _max: NPSenderMaxAggregateOutputType | null
  }

  export type NPSenderAvgAggregateOutputType = {
    id: number | null
  }

  export type NPSenderSumAggregateOutputType = {
    id: number | null
  }

  export type NPSenderMinAggregateOutputType = {
    id: number | null
    name: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    cityRef: string | null
    cityName: string | null
    warehouseRef: string | null
    warehouseName: string | null
    createdAt: Date | null
  }

  export type NPSenderMaxAggregateOutputType = {
    id: number | null
    name: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    cityRef: string | null
    cityName: string | null
    warehouseRef: string | null
    warehouseName: string | null
    createdAt: Date | null
  }

  export type NPSenderCountAggregateOutputType = {
    id: number
    name: number
    firstName: number
    lastName: number
    phone: number
    cityRef: number
    cityName: number
    warehouseRef: number
    warehouseName: number
    createdAt: number
    _all: number
  }


  export type NPSenderAvgAggregateInputType = {
    id?: true
  }

  export type NPSenderSumAggregateInputType = {
    id?: true
  }

  export type NPSenderMinAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    phone?: true
    cityRef?: true
    cityName?: true
    warehouseRef?: true
    warehouseName?: true
    createdAt?: true
  }

  export type NPSenderMaxAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    phone?: true
    cityRef?: true
    cityName?: true
    warehouseRef?: true
    warehouseName?: true
    createdAt?: true
  }

  export type NPSenderCountAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    phone?: true
    cityRef?: true
    cityName?: true
    warehouseRef?: true
    warehouseName?: true
    createdAt?: true
    _all?: true
  }

  export type NPSenderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPSender to aggregate.
     */
    where?: NPSenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPSenders to fetch.
     */
    orderBy?: NPSenderOrderByWithRelationInput | NPSenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NPSenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPSenders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPSenders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NPSenders
    **/
    _count?: true | NPSenderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NPSenderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NPSenderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NPSenderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NPSenderMaxAggregateInputType
  }

  export type GetNPSenderAggregateType<T extends NPSenderAggregateArgs> = {
        [P in keyof T & keyof AggregateNPSender]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNPSender[P]>
      : GetScalarType<T[P], AggregateNPSender[P]>
  }




  export type NPSenderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPSenderWhereInput
    orderBy?: NPSenderOrderByWithAggregationInput | NPSenderOrderByWithAggregationInput[]
    by: NPSenderScalarFieldEnum[] | NPSenderScalarFieldEnum
    having?: NPSenderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NPSenderCountAggregateInputType | true
    _avg?: NPSenderAvgAggregateInputType
    _sum?: NPSenderSumAggregateInputType
    _min?: NPSenderMinAggregateInputType
    _max?: NPSenderMaxAggregateInputType
  }

  export type NPSenderGroupByOutputType = {
    id: number
    name: string
    firstName: string | null
    lastName: string | null
    phone: string
    cityRef: string
    cityName: string
    warehouseRef: string
    warehouseName: string
    createdAt: Date
    _count: NPSenderCountAggregateOutputType | null
    _avg: NPSenderAvgAggregateOutputType | null
    _sum: NPSenderSumAggregateOutputType | null
    _min: NPSenderMinAggregateOutputType | null
    _max: NPSenderMaxAggregateOutputType | null
  }

  type GetNPSenderGroupByPayload<T extends NPSenderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NPSenderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NPSenderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NPSenderGroupByOutputType[P]>
            : GetScalarType<T[P], NPSenderGroupByOutputType[P]>
        }
      >
    >


  export type NPSenderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    cityRef?: boolean
    cityName?: boolean
    warehouseRef?: boolean
    warehouseName?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["nPSender"]>

  export type NPSenderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    cityRef?: boolean
    cityName?: boolean
    warehouseRef?: boolean
    warehouseName?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["nPSender"]>

  export type NPSenderSelectScalar = {
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    cityRef?: boolean
    cityName?: boolean
    warehouseRef?: boolean
    warehouseName?: boolean
    createdAt?: boolean
  }


  export type $NPSenderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NPSender"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      firstName: string | null
      lastName: string | null
      phone: string
      cityRef: string
      cityName: string
      warehouseRef: string
      warehouseName: string
      createdAt: Date
    }, ExtArgs["result"]["nPSender"]>
    composites: {}
  }

  type NPSenderGetPayload<S extends boolean | null | undefined | NPSenderDefaultArgs> = $Result.GetResult<Prisma.$NPSenderPayload, S>

  type NPSenderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NPSenderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NPSenderCountAggregateInputType | true
    }

  export interface NPSenderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NPSender'], meta: { name: 'NPSender' } }
    /**
     * Find zero or one NPSender that matches the filter.
     * @param {NPSenderFindUniqueArgs} args - Arguments to find a NPSender
     * @example
     * // Get one NPSender
     * const nPSender = await prisma.nPSender.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NPSenderFindUniqueArgs>(args: SelectSubset<T, NPSenderFindUniqueArgs<ExtArgs>>): Prisma__NPSenderClient<$Result.GetResult<Prisma.$NPSenderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NPSender that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NPSenderFindUniqueOrThrowArgs} args - Arguments to find a NPSender
     * @example
     * // Get one NPSender
     * const nPSender = await prisma.nPSender.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NPSenderFindUniqueOrThrowArgs>(args: SelectSubset<T, NPSenderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NPSenderClient<$Result.GetResult<Prisma.$NPSenderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NPSender that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPSenderFindFirstArgs} args - Arguments to find a NPSender
     * @example
     * // Get one NPSender
     * const nPSender = await prisma.nPSender.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NPSenderFindFirstArgs>(args?: SelectSubset<T, NPSenderFindFirstArgs<ExtArgs>>): Prisma__NPSenderClient<$Result.GetResult<Prisma.$NPSenderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NPSender that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPSenderFindFirstOrThrowArgs} args - Arguments to find a NPSender
     * @example
     * // Get one NPSender
     * const nPSender = await prisma.nPSender.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NPSenderFindFirstOrThrowArgs>(args?: SelectSubset<T, NPSenderFindFirstOrThrowArgs<ExtArgs>>): Prisma__NPSenderClient<$Result.GetResult<Prisma.$NPSenderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NPSenders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPSenderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NPSenders
     * const nPSenders = await prisma.nPSender.findMany()
     * 
     * // Get first 10 NPSenders
     * const nPSenders = await prisma.nPSender.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nPSenderWithIdOnly = await prisma.nPSender.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NPSenderFindManyArgs>(args?: SelectSubset<T, NPSenderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPSenderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NPSender.
     * @param {NPSenderCreateArgs} args - Arguments to create a NPSender.
     * @example
     * // Create one NPSender
     * const NPSender = await prisma.nPSender.create({
     *   data: {
     *     // ... data to create a NPSender
     *   }
     * })
     * 
     */
    create<T extends NPSenderCreateArgs>(args: SelectSubset<T, NPSenderCreateArgs<ExtArgs>>): Prisma__NPSenderClient<$Result.GetResult<Prisma.$NPSenderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NPSenders.
     * @param {NPSenderCreateManyArgs} args - Arguments to create many NPSenders.
     * @example
     * // Create many NPSenders
     * const nPSender = await prisma.nPSender.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NPSenderCreateManyArgs>(args?: SelectSubset<T, NPSenderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NPSenders and returns the data saved in the database.
     * @param {NPSenderCreateManyAndReturnArgs} args - Arguments to create many NPSenders.
     * @example
     * // Create many NPSenders
     * const nPSender = await prisma.nPSender.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NPSenders and only return the `id`
     * const nPSenderWithIdOnly = await prisma.nPSender.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NPSenderCreateManyAndReturnArgs>(args?: SelectSubset<T, NPSenderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPSenderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NPSender.
     * @param {NPSenderDeleteArgs} args - Arguments to delete one NPSender.
     * @example
     * // Delete one NPSender
     * const NPSender = await prisma.nPSender.delete({
     *   where: {
     *     // ... filter to delete one NPSender
     *   }
     * })
     * 
     */
    delete<T extends NPSenderDeleteArgs>(args: SelectSubset<T, NPSenderDeleteArgs<ExtArgs>>): Prisma__NPSenderClient<$Result.GetResult<Prisma.$NPSenderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NPSender.
     * @param {NPSenderUpdateArgs} args - Arguments to update one NPSender.
     * @example
     * // Update one NPSender
     * const nPSender = await prisma.nPSender.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NPSenderUpdateArgs>(args: SelectSubset<T, NPSenderUpdateArgs<ExtArgs>>): Prisma__NPSenderClient<$Result.GetResult<Prisma.$NPSenderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NPSenders.
     * @param {NPSenderDeleteManyArgs} args - Arguments to filter NPSenders to delete.
     * @example
     * // Delete a few NPSenders
     * const { count } = await prisma.nPSender.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NPSenderDeleteManyArgs>(args?: SelectSubset<T, NPSenderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPSenders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPSenderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NPSenders
     * const nPSender = await prisma.nPSender.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NPSenderUpdateManyArgs>(args: SelectSubset<T, NPSenderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NPSender.
     * @param {NPSenderUpsertArgs} args - Arguments to update or create a NPSender.
     * @example
     * // Update or create a NPSender
     * const nPSender = await prisma.nPSender.upsert({
     *   create: {
     *     // ... data to create a NPSender
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NPSender we want to update
     *   }
     * })
     */
    upsert<T extends NPSenderUpsertArgs>(args: SelectSubset<T, NPSenderUpsertArgs<ExtArgs>>): Prisma__NPSenderClient<$Result.GetResult<Prisma.$NPSenderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NPSenders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPSenderCountArgs} args - Arguments to filter NPSenders to count.
     * @example
     * // Count the number of NPSenders
     * const count = await prisma.nPSender.count({
     *   where: {
     *     // ... the filter for the NPSenders we want to count
     *   }
     * })
    **/
    count<T extends NPSenderCountArgs>(
      args?: Subset<T, NPSenderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NPSenderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NPSender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPSenderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NPSenderAggregateArgs>(args: Subset<T, NPSenderAggregateArgs>): Prisma.PrismaPromise<GetNPSenderAggregateType<T>>

    /**
     * Group by NPSender.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPSenderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NPSenderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NPSenderGroupByArgs['orderBy'] }
        : { orderBy?: NPSenderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NPSenderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNPSenderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NPSender model
   */
  readonly fields: NPSenderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NPSender.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NPSenderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NPSender model
   */ 
  interface NPSenderFieldRefs {
    readonly id: FieldRef<"NPSender", 'Int'>
    readonly name: FieldRef<"NPSender", 'String'>
    readonly firstName: FieldRef<"NPSender", 'String'>
    readonly lastName: FieldRef<"NPSender", 'String'>
    readonly phone: FieldRef<"NPSender", 'String'>
    readonly cityRef: FieldRef<"NPSender", 'String'>
    readonly cityName: FieldRef<"NPSender", 'String'>
    readonly warehouseRef: FieldRef<"NPSender", 'String'>
    readonly warehouseName: FieldRef<"NPSender", 'String'>
    readonly createdAt: FieldRef<"NPSender", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NPSender findUnique
   */
  export type NPSenderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPSender
     */
    select?: NPSenderSelect<ExtArgs> | null
    /**
     * Filter, which NPSender to fetch.
     */
    where: NPSenderWhereUniqueInput
  }

  /**
   * NPSender findUniqueOrThrow
   */
  export type NPSenderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPSender
     */
    select?: NPSenderSelect<ExtArgs> | null
    /**
     * Filter, which NPSender to fetch.
     */
    where: NPSenderWhereUniqueInput
  }

  /**
   * NPSender findFirst
   */
  export type NPSenderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPSender
     */
    select?: NPSenderSelect<ExtArgs> | null
    /**
     * Filter, which NPSender to fetch.
     */
    where?: NPSenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPSenders to fetch.
     */
    orderBy?: NPSenderOrderByWithRelationInput | NPSenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPSenders.
     */
    cursor?: NPSenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPSenders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPSenders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPSenders.
     */
    distinct?: NPSenderScalarFieldEnum | NPSenderScalarFieldEnum[]
  }

  /**
   * NPSender findFirstOrThrow
   */
  export type NPSenderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPSender
     */
    select?: NPSenderSelect<ExtArgs> | null
    /**
     * Filter, which NPSender to fetch.
     */
    where?: NPSenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPSenders to fetch.
     */
    orderBy?: NPSenderOrderByWithRelationInput | NPSenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPSenders.
     */
    cursor?: NPSenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPSenders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPSenders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPSenders.
     */
    distinct?: NPSenderScalarFieldEnum | NPSenderScalarFieldEnum[]
  }

  /**
   * NPSender findMany
   */
  export type NPSenderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPSender
     */
    select?: NPSenderSelect<ExtArgs> | null
    /**
     * Filter, which NPSenders to fetch.
     */
    where?: NPSenderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPSenders to fetch.
     */
    orderBy?: NPSenderOrderByWithRelationInput | NPSenderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NPSenders.
     */
    cursor?: NPSenderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPSenders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPSenders.
     */
    skip?: number
    distinct?: NPSenderScalarFieldEnum | NPSenderScalarFieldEnum[]
  }

  /**
   * NPSender create
   */
  export type NPSenderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPSender
     */
    select?: NPSenderSelect<ExtArgs> | null
    /**
     * The data needed to create a NPSender.
     */
    data: XOR<NPSenderCreateInput, NPSenderUncheckedCreateInput>
  }

  /**
   * NPSender createMany
   */
  export type NPSenderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NPSenders.
     */
    data: NPSenderCreateManyInput | NPSenderCreateManyInput[]
  }

  /**
   * NPSender createManyAndReturn
   */
  export type NPSenderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPSender
     */
    select?: NPSenderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NPSenders.
     */
    data: NPSenderCreateManyInput | NPSenderCreateManyInput[]
  }

  /**
   * NPSender update
   */
  export type NPSenderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPSender
     */
    select?: NPSenderSelect<ExtArgs> | null
    /**
     * The data needed to update a NPSender.
     */
    data: XOR<NPSenderUpdateInput, NPSenderUncheckedUpdateInput>
    /**
     * Choose, which NPSender to update.
     */
    where: NPSenderWhereUniqueInput
  }

  /**
   * NPSender updateMany
   */
  export type NPSenderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NPSenders.
     */
    data: XOR<NPSenderUpdateManyMutationInput, NPSenderUncheckedUpdateManyInput>
    /**
     * Filter which NPSenders to update
     */
    where?: NPSenderWhereInput
  }

  /**
   * NPSender upsert
   */
  export type NPSenderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPSender
     */
    select?: NPSenderSelect<ExtArgs> | null
    /**
     * The filter to search for the NPSender to update in case it exists.
     */
    where: NPSenderWhereUniqueInput
    /**
     * In case the NPSender found by the `where` argument doesn't exist, create a new NPSender with this data.
     */
    create: XOR<NPSenderCreateInput, NPSenderUncheckedCreateInput>
    /**
     * In case the NPSender was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NPSenderUpdateInput, NPSenderUncheckedUpdateInput>
  }

  /**
   * NPSender delete
   */
  export type NPSenderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPSender
     */
    select?: NPSenderSelect<ExtArgs> | null
    /**
     * Filter which NPSender to delete.
     */
    where: NPSenderWhereUniqueInput
  }

  /**
   * NPSender deleteMany
   */
  export type NPSenderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPSenders to delete
     */
    where?: NPSenderWhereInput
  }

  /**
   * NPSender without action
   */
  export type NPSenderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPSender
     */
    select?: NPSenderSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    status: 'status',
    totalAmount: 'totalAmount',
    customerName: 'customerName',
    customerFirstName: 'customerFirstName',
    customerLastName: 'customerLastName',
    customerPhone: 'customerPhone',
    customerEmail: 'customerEmail',
    deliveryAddress: 'deliveryAddress',
    deliveryMethod: 'deliveryMethod',
    recipientCityRef: 'recipientCityRef',
    recipientWarehouseRef: 'recipientWarehouseRef',
    ttnNumber: 'ttnNumber',
    ttnRef: 'ttnRef',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    type: 'type',
    name: 'name',
    quantity: 'quantity',
    price: 'price',
    subtotal: 'subtotal',
    size: 'size',
    paper: 'paper',
    options: 'options',
    files: 'files',
    createdAt: 'createdAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const PrintSizeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    widthMm: 'widthMm',
    heightMm: 'heightMm',
    basePrice: 'basePrice',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type PrintSizeScalarFieldEnum = (typeof PrintSizeScalarFieldEnum)[keyof typeof PrintSizeScalarFieldEnum]


  export const QuantityTierScalarFieldEnum: {
    id: 'id',
    label: 'label',
    minQuantity: 'minQuantity',
    sortOrder: 'sortOrder',
    isActive: 'isActive'
  };

  export type QuantityTierScalarFieldEnum = (typeof QuantityTierScalarFieldEnum)[keyof typeof QuantityTierScalarFieldEnum]


  export const VolumeDiscountScalarFieldEnum: {
    id: 'id',
    printSizeId: 'printSizeId',
    tierId: 'tierId',
    minQuantity: 'minQuantity',
    price: 'price'
  };

  export type VolumeDiscountScalarFieldEnum = (typeof VolumeDiscountScalarFieldEnum)[keyof typeof VolumeDiscountScalarFieldEnum]


  export const GiftThresholdScalarFieldEnum: {
    id: 'id',
    minAmount: 'minAmount',
    giftName: 'giftName',
    isActive: 'isActive'
  };

  export type GiftThresholdScalarFieldEnum = (typeof GiftThresholdScalarFieldEnum)[keyof typeof GiftThresholdScalarFieldEnum]


  export const PaperTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    isActive: 'isActive'
  };

  export type PaperTypeScalarFieldEnum = (typeof PaperTypeScalarFieldEnum)[keyof typeof PaperTypeScalarFieldEnum]


  export const PrintOptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    priceType: 'priceType',
    price: 'price',
    isActive: 'isActive'
  };

  export type PrintOptionScalarFieldEnum = (typeof PrintOptionScalarFieldEnum)[keyof typeof PrintOptionScalarFieldEnum]


  export const MagnetPriceScalarFieldEnum: {
    id: 'id',
    sizeSlug: 'sizeSlug',
    price: 'price',
    isActive: 'isActive'
  };

  export type MagnetPriceScalarFieldEnum = (typeof MagnetPriceScalarFieldEnum)[keyof typeof MagnetPriceScalarFieldEnum]


  export const DeliveryOptionScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    price: 'price',
    description: 'description',
    isActive: 'isActive'
  };

  export type DeliveryOptionScalarFieldEnum = (typeof DeliveryOptionScalarFieldEnum)[keyof typeof DeliveryOptionScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    images: 'images',
    stock: 'stock',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const TranslationScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    key: 'key',
    value: 'value'
  };

  export type TranslationScalarFieldEnum = (typeof TranslationScalarFieldEnum)[keyof typeof TranslationScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    key: 'key',
    value: 'value',
    description: 'description'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const PageScalarFieldEnum: {
    id: 'id',
    lang: 'lang',
    title: 'title',
    slug: 'slug',
    content: 'content',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


  export const HelpCategoryScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HelpCategoryScalarFieldEnum = (typeof HelpCategoryScalarFieldEnum)[keyof typeof HelpCategoryScalarFieldEnum]


  export const HelpCategoryTranslationScalarFieldEnum: {
    id: 'id',
    helpCategoryId: 'helpCategoryId',
    lang: 'lang',
    name: 'name'
  };

  export type HelpCategoryTranslationScalarFieldEnum = (typeof HelpCategoryTranslationScalarFieldEnum)[keyof typeof HelpCategoryTranslationScalarFieldEnum]


  export const HelpArticleScalarFieldEnum: {
    id: 'id',
    helpCategoryId: 'helpCategoryId',
    slug: 'slug',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HelpArticleScalarFieldEnum = (typeof HelpArticleScalarFieldEnum)[keyof typeof HelpArticleScalarFieldEnum]


  export const HelpArticleTranslationScalarFieldEnum: {
    id: 'id',
    helpArticleId: 'helpArticleId',
    lang: 'lang',
    title: 'title',
    content: 'content'
  };

  export type HelpArticleTranslationScalarFieldEnum = (typeof HelpArticleTranslationScalarFieldEnum)[keyof typeof HelpArticleTranslationScalarFieldEnum]


  export const OrderSequenceScalarFieldEnum: {
    id: 'id',
    currentValue: 'currentValue'
  };

  export type OrderSequenceScalarFieldEnum = (typeof OrderSequenceScalarFieldEnum)[keyof typeof OrderSequenceScalarFieldEnum]


  export const NPSenderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    cityRef: 'cityRef',
    cityName: 'cityName',
    warehouseRef: 'warehouseRef',
    warehouseName: 'warehouseName',
    createdAt: 'createdAt'
  };

  export type NPSenderScalarFieldEnum = (typeof NPSenderScalarFieldEnum)[keyof typeof NPSenderScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    orderNumber?: StringFilter<"Order"> | string
    status?: StringFilter<"Order"> | string
    totalAmount?: FloatFilter<"Order"> | number
    customerName?: StringNullableFilter<"Order"> | string | null
    customerFirstName?: StringNullableFilter<"Order"> | string | null
    customerLastName?: StringNullableFilter<"Order"> | string | null
    customerPhone?: StringNullableFilter<"Order"> | string | null
    customerEmail?: StringNullableFilter<"Order"> | string | null
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    deliveryMethod?: StringFilter<"Order"> | string
    recipientCityRef?: StringNullableFilter<"Order"> | string | null
    recipientWarehouseRef?: StringNullableFilter<"Order"> | string | null
    ttnNumber?: StringNullableFilter<"Order"> | string | null
    ttnRef?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    items?: OrderItemListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    customerName?: SortOrderInput | SortOrder
    customerFirstName?: SortOrderInput | SortOrder
    customerLastName?: SortOrderInput | SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrder
    recipientCityRef?: SortOrderInput | SortOrder
    recipientWarehouseRef?: SortOrderInput | SortOrder
    ttnNumber?: SortOrderInput | SortOrder
    ttnRef?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: OrderItemOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderNumber?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    status?: StringFilter<"Order"> | string
    totalAmount?: FloatFilter<"Order"> | number
    customerName?: StringNullableFilter<"Order"> | string | null
    customerFirstName?: StringNullableFilter<"Order"> | string | null
    customerLastName?: StringNullableFilter<"Order"> | string | null
    customerPhone?: StringNullableFilter<"Order"> | string | null
    customerEmail?: StringNullableFilter<"Order"> | string | null
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    deliveryMethod?: StringFilter<"Order"> | string
    recipientCityRef?: StringNullableFilter<"Order"> | string | null
    recipientWarehouseRef?: StringNullableFilter<"Order"> | string | null
    ttnNumber?: StringNullableFilter<"Order"> | string | null
    ttnRef?: StringNullableFilter<"Order"> | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    items?: OrderItemListRelationFilter
  }, "id" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    customerName?: SortOrderInput | SortOrder
    customerFirstName?: SortOrderInput | SortOrder
    customerLastName?: SortOrderInput | SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerEmail?: SortOrderInput | SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    deliveryMethod?: SortOrder
    recipientCityRef?: SortOrderInput | SortOrder
    recipientWarehouseRef?: SortOrderInput | SortOrder
    ttnNumber?: SortOrderInput | SortOrder
    ttnRef?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    status?: StringWithAggregatesFilter<"Order"> | string
    totalAmount?: FloatWithAggregatesFilter<"Order"> | number
    customerName?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerFirstName?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerLastName?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerPhone?: StringNullableWithAggregatesFilter<"Order"> | string | null
    customerEmail?: StringNullableWithAggregatesFilter<"Order"> | string | null
    deliveryAddress?: StringNullableWithAggregatesFilter<"Order"> | string | null
    deliveryMethod?: StringWithAggregatesFilter<"Order"> | string
    recipientCityRef?: StringNullableWithAggregatesFilter<"Order"> | string | null
    recipientWarehouseRef?: StringNullableWithAggregatesFilter<"Order"> | string | null
    ttnNumber?: StringNullableWithAggregatesFilter<"Order"> | string | null
    ttnRef?: StringNullableWithAggregatesFilter<"Order"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    type?: StringFilter<"OrderItem"> | string
    name?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    subtotal?: FloatFilter<"OrderItem"> | number
    size?: StringNullableFilter<"OrderItem"> | string | null
    paper?: StringNullableFilter<"OrderItem"> | string | null
    options?: StringNullableFilter<"OrderItem"> | string | null
    files?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    subtotal?: SortOrder
    size?: SortOrderInput | SortOrder
    paper?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    files?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: IntFilter<"OrderItem"> | number
    type?: StringFilter<"OrderItem"> | string
    name?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    subtotal?: FloatFilter<"OrderItem"> | number
    size?: StringNullableFilter<"OrderItem"> | string | null
    paper?: StringNullableFilter<"OrderItem"> | string | null
    options?: StringNullableFilter<"OrderItem"> | string | null
    files?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    subtotal?: SortOrder
    size?: SortOrderInput | SortOrder
    paper?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    files?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    type?: StringWithAggregatesFilter<"OrderItem"> | string
    name?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    price?: FloatWithAggregatesFilter<"OrderItem"> | number
    subtotal?: FloatWithAggregatesFilter<"OrderItem"> | number
    size?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    paper?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    options?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    files?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type PrintSizeWhereInput = {
    AND?: PrintSizeWhereInput | PrintSizeWhereInput[]
    OR?: PrintSizeWhereInput[]
    NOT?: PrintSizeWhereInput | PrintSizeWhereInput[]
    id?: IntFilter<"PrintSize"> | number
    name?: StringFilter<"PrintSize"> | string
    slug?: StringFilter<"PrintSize"> | string
    widthMm?: FloatNullableFilter<"PrintSize"> | number | null
    heightMm?: FloatNullableFilter<"PrintSize"> | number | null
    basePrice?: FloatFilter<"PrintSize"> | number
    sortOrder?: IntFilter<"PrintSize"> | number
    isActive?: BoolFilter<"PrintSize"> | boolean
    createdAt?: DateTimeFilter<"PrintSize"> | Date | string
    discounts?: VolumeDiscountListRelationFilter
  }

  export type PrintSizeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    widthMm?: SortOrderInput | SortOrder
    heightMm?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    discounts?: VolumeDiscountOrderByRelationAggregateInput
  }

  export type PrintSizeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: PrintSizeWhereInput | PrintSizeWhereInput[]
    OR?: PrintSizeWhereInput[]
    NOT?: PrintSizeWhereInput | PrintSizeWhereInput[]
    name?: StringFilter<"PrintSize"> | string
    widthMm?: FloatNullableFilter<"PrintSize"> | number | null
    heightMm?: FloatNullableFilter<"PrintSize"> | number | null
    basePrice?: FloatFilter<"PrintSize"> | number
    sortOrder?: IntFilter<"PrintSize"> | number
    isActive?: BoolFilter<"PrintSize"> | boolean
    createdAt?: DateTimeFilter<"PrintSize"> | Date | string
    discounts?: VolumeDiscountListRelationFilter
  }, "id" | "slug">

  export type PrintSizeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    widthMm?: SortOrderInput | SortOrder
    heightMm?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: PrintSizeCountOrderByAggregateInput
    _avg?: PrintSizeAvgOrderByAggregateInput
    _max?: PrintSizeMaxOrderByAggregateInput
    _min?: PrintSizeMinOrderByAggregateInput
    _sum?: PrintSizeSumOrderByAggregateInput
  }

  export type PrintSizeScalarWhereWithAggregatesInput = {
    AND?: PrintSizeScalarWhereWithAggregatesInput | PrintSizeScalarWhereWithAggregatesInput[]
    OR?: PrintSizeScalarWhereWithAggregatesInput[]
    NOT?: PrintSizeScalarWhereWithAggregatesInput | PrintSizeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrintSize"> | number
    name?: StringWithAggregatesFilter<"PrintSize"> | string
    slug?: StringWithAggregatesFilter<"PrintSize"> | string
    widthMm?: FloatNullableWithAggregatesFilter<"PrintSize"> | number | null
    heightMm?: FloatNullableWithAggregatesFilter<"PrintSize"> | number | null
    basePrice?: FloatWithAggregatesFilter<"PrintSize"> | number
    sortOrder?: IntWithAggregatesFilter<"PrintSize"> | number
    isActive?: BoolWithAggregatesFilter<"PrintSize"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PrintSize"> | Date | string
  }

  export type QuantityTierWhereInput = {
    AND?: QuantityTierWhereInput | QuantityTierWhereInput[]
    OR?: QuantityTierWhereInput[]
    NOT?: QuantityTierWhereInput | QuantityTierWhereInput[]
    id?: IntFilter<"QuantityTier"> | number
    label?: StringFilter<"QuantityTier"> | string
    minQuantity?: IntFilter<"QuantityTier"> | number
    sortOrder?: IntFilter<"QuantityTier"> | number
    isActive?: BoolFilter<"QuantityTier"> | boolean
    discounts?: VolumeDiscountListRelationFilter
  }

  export type QuantityTierOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    minQuantity?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    discounts?: VolumeDiscountOrderByRelationAggregateInput
  }

  export type QuantityTierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuantityTierWhereInput | QuantityTierWhereInput[]
    OR?: QuantityTierWhereInput[]
    NOT?: QuantityTierWhereInput | QuantityTierWhereInput[]
    label?: StringFilter<"QuantityTier"> | string
    minQuantity?: IntFilter<"QuantityTier"> | number
    sortOrder?: IntFilter<"QuantityTier"> | number
    isActive?: BoolFilter<"QuantityTier"> | boolean
    discounts?: VolumeDiscountListRelationFilter
  }, "id">

  export type QuantityTierOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    minQuantity?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    _count?: QuantityTierCountOrderByAggregateInput
    _avg?: QuantityTierAvgOrderByAggregateInput
    _max?: QuantityTierMaxOrderByAggregateInput
    _min?: QuantityTierMinOrderByAggregateInput
    _sum?: QuantityTierSumOrderByAggregateInput
  }

  export type QuantityTierScalarWhereWithAggregatesInput = {
    AND?: QuantityTierScalarWhereWithAggregatesInput | QuantityTierScalarWhereWithAggregatesInput[]
    OR?: QuantityTierScalarWhereWithAggregatesInput[]
    NOT?: QuantityTierScalarWhereWithAggregatesInput | QuantityTierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuantityTier"> | number
    label?: StringWithAggregatesFilter<"QuantityTier"> | string
    minQuantity?: IntWithAggregatesFilter<"QuantityTier"> | number
    sortOrder?: IntWithAggregatesFilter<"QuantityTier"> | number
    isActive?: BoolWithAggregatesFilter<"QuantityTier"> | boolean
  }

  export type VolumeDiscountWhereInput = {
    AND?: VolumeDiscountWhereInput | VolumeDiscountWhereInput[]
    OR?: VolumeDiscountWhereInput[]
    NOT?: VolumeDiscountWhereInput | VolumeDiscountWhereInput[]
    id?: IntFilter<"VolumeDiscount"> | number
    printSizeId?: IntFilter<"VolumeDiscount"> | number
    tierId?: IntNullableFilter<"VolumeDiscount"> | number | null
    minQuantity?: IntFilter<"VolumeDiscount"> | number
    price?: FloatFilter<"VolumeDiscount"> | number
    printSize?: XOR<PrintSizeRelationFilter, PrintSizeWhereInput>
    tier?: XOR<QuantityTierNullableRelationFilter, QuantityTierWhereInput> | null
  }

  export type VolumeDiscountOrderByWithRelationInput = {
    id?: SortOrder
    printSizeId?: SortOrder
    tierId?: SortOrderInput | SortOrder
    minQuantity?: SortOrder
    price?: SortOrder
    printSize?: PrintSizeOrderByWithRelationInput
    tier?: QuantityTierOrderByWithRelationInput
  }

  export type VolumeDiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VolumeDiscountWhereInput | VolumeDiscountWhereInput[]
    OR?: VolumeDiscountWhereInput[]
    NOT?: VolumeDiscountWhereInput | VolumeDiscountWhereInput[]
    printSizeId?: IntFilter<"VolumeDiscount"> | number
    tierId?: IntNullableFilter<"VolumeDiscount"> | number | null
    minQuantity?: IntFilter<"VolumeDiscount"> | number
    price?: FloatFilter<"VolumeDiscount"> | number
    printSize?: XOR<PrintSizeRelationFilter, PrintSizeWhereInput>
    tier?: XOR<QuantityTierNullableRelationFilter, QuantityTierWhereInput> | null
  }, "id">

  export type VolumeDiscountOrderByWithAggregationInput = {
    id?: SortOrder
    printSizeId?: SortOrder
    tierId?: SortOrderInput | SortOrder
    minQuantity?: SortOrder
    price?: SortOrder
    _count?: VolumeDiscountCountOrderByAggregateInput
    _avg?: VolumeDiscountAvgOrderByAggregateInput
    _max?: VolumeDiscountMaxOrderByAggregateInput
    _min?: VolumeDiscountMinOrderByAggregateInput
    _sum?: VolumeDiscountSumOrderByAggregateInput
  }

  export type VolumeDiscountScalarWhereWithAggregatesInput = {
    AND?: VolumeDiscountScalarWhereWithAggregatesInput | VolumeDiscountScalarWhereWithAggregatesInput[]
    OR?: VolumeDiscountScalarWhereWithAggregatesInput[]
    NOT?: VolumeDiscountScalarWhereWithAggregatesInput | VolumeDiscountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"VolumeDiscount"> | number
    printSizeId?: IntWithAggregatesFilter<"VolumeDiscount"> | number
    tierId?: IntNullableWithAggregatesFilter<"VolumeDiscount"> | number | null
    minQuantity?: IntWithAggregatesFilter<"VolumeDiscount"> | number
    price?: FloatWithAggregatesFilter<"VolumeDiscount"> | number
  }

  export type GiftThresholdWhereInput = {
    AND?: GiftThresholdWhereInput | GiftThresholdWhereInput[]
    OR?: GiftThresholdWhereInput[]
    NOT?: GiftThresholdWhereInput | GiftThresholdWhereInput[]
    id?: IntFilter<"GiftThreshold"> | number
    minAmount?: FloatFilter<"GiftThreshold"> | number
    giftName?: StringFilter<"GiftThreshold"> | string
    isActive?: BoolFilter<"GiftThreshold"> | boolean
  }

  export type GiftThresholdOrderByWithRelationInput = {
    id?: SortOrder
    minAmount?: SortOrder
    giftName?: SortOrder
    isActive?: SortOrder
  }

  export type GiftThresholdWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GiftThresholdWhereInput | GiftThresholdWhereInput[]
    OR?: GiftThresholdWhereInput[]
    NOT?: GiftThresholdWhereInput | GiftThresholdWhereInput[]
    minAmount?: FloatFilter<"GiftThreshold"> | number
    giftName?: StringFilter<"GiftThreshold"> | string
    isActive?: BoolFilter<"GiftThreshold"> | boolean
  }, "id">

  export type GiftThresholdOrderByWithAggregationInput = {
    id?: SortOrder
    minAmount?: SortOrder
    giftName?: SortOrder
    isActive?: SortOrder
    _count?: GiftThresholdCountOrderByAggregateInput
    _avg?: GiftThresholdAvgOrderByAggregateInput
    _max?: GiftThresholdMaxOrderByAggregateInput
    _min?: GiftThresholdMinOrderByAggregateInput
    _sum?: GiftThresholdSumOrderByAggregateInput
  }

  export type GiftThresholdScalarWhereWithAggregatesInput = {
    AND?: GiftThresholdScalarWhereWithAggregatesInput | GiftThresholdScalarWhereWithAggregatesInput[]
    OR?: GiftThresholdScalarWhereWithAggregatesInput[]
    NOT?: GiftThresholdScalarWhereWithAggregatesInput | GiftThresholdScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"GiftThreshold"> | number
    minAmount?: FloatWithAggregatesFilter<"GiftThreshold"> | number
    giftName?: StringWithAggregatesFilter<"GiftThreshold"> | string
    isActive?: BoolWithAggregatesFilter<"GiftThreshold"> | boolean
  }

  export type PaperTypeWhereInput = {
    AND?: PaperTypeWhereInput | PaperTypeWhereInput[]
    OR?: PaperTypeWhereInput[]
    NOT?: PaperTypeWhereInput | PaperTypeWhereInput[]
    id?: IntFilter<"PaperType"> | number
    name?: StringFilter<"PaperType"> | string
    slug?: StringFilter<"PaperType"> | string
    description?: StringNullableFilter<"PaperType"> | string | null
    isActive?: BoolFilter<"PaperType"> | boolean
  }

  export type PaperTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
  }

  export type PaperTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: PaperTypeWhereInput | PaperTypeWhereInput[]
    OR?: PaperTypeWhereInput[]
    NOT?: PaperTypeWhereInput | PaperTypeWhereInput[]
    name?: StringFilter<"PaperType"> | string
    description?: StringNullableFilter<"PaperType"> | string | null
    isActive?: BoolFilter<"PaperType"> | boolean
  }, "id" | "slug">

  export type PaperTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: PaperTypeCountOrderByAggregateInput
    _avg?: PaperTypeAvgOrderByAggregateInput
    _max?: PaperTypeMaxOrderByAggregateInput
    _min?: PaperTypeMinOrderByAggregateInput
    _sum?: PaperTypeSumOrderByAggregateInput
  }

  export type PaperTypeScalarWhereWithAggregatesInput = {
    AND?: PaperTypeScalarWhereWithAggregatesInput | PaperTypeScalarWhereWithAggregatesInput[]
    OR?: PaperTypeScalarWhereWithAggregatesInput[]
    NOT?: PaperTypeScalarWhereWithAggregatesInput | PaperTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaperType"> | number
    name?: StringWithAggregatesFilter<"PaperType"> | string
    slug?: StringWithAggregatesFilter<"PaperType"> | string
    description?: StringNullableWithAggregatesFilter<"PaperType"> | string | null
    isActive?: BoolWithAggregatesFilter<"PaperType"> | boolean
  }

  export type PrintOptionWhereInput = {
    AND?: PrintOptionWhereInput | PrintOptionWhereInput[]
    OR?: PrintOptionWhereInput[]
    NOT?: PrintOptionWhereInput | PrintOptionWhereInput[]
    id?: IntFilter<"PrintOption"> | number
    name?: StringFilter<"PrintOption"> | string
    slug?: StringFilter<"PrintOption"> | string
    priceType?: StringFilter<"PrintOption"> | string
    price?: FloatFilter<"PrintOption"> | number
    isActive?: BoolFilter<"PrintOption"> | boolean
  }

  export type PrintOptionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
  }

  export type PrintOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: PrintOptionWhereInput | PrintOptionWhereInput[]
    OR?: PrintOptionWhereInput[]
    NOT?: PrintOptionWhereInput | PrintOptionWhereInput[]
    name?: StringFilter<"PrintOption"> | string
    priceType?: StringFilter<"PrintOption"> | string
    price?: FloatFilter<"PrintOption"> | number
    isActive?: BoolFilter<"PrintOption"> | boolean
  }, "id" | "slug">

  export type PrintOptionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    _count?: PrintOptionCountOrderByAggregateInput
    _avg?: PrintOptionAvgOrderByAggregateInput
    _max?: PrintOptionMaxOrderByAggregateInput
    _min?: PrintOptionMinOrderByAggregateInput
    _sum?: PrintOptionSumOrderByAggregateInput
  }

  export type PrintOptionScalarWhereWithAggregatesInput = {
    AND?: PrintOptionScalarWhereWithAggregatesInput | PrintOptionScalarWhereWithAggregatesInput[]
    OR?: PrintOptionScalarWhereWithAggregatesInput[]
    NOT?: PrintOptionScalarWhereWithAggregatesInput | PrintOptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PrintOption"> | number
    name?: StringWithAggregatesFilter<"PrintOption"> | string
    slug?: StringWithAggregatesFilter<"PrintOption"> | string
    priceType?: StringWithAggregatesFilter<"PrintOption"> | string
    price?: FloatWithAggregatesFilter<"PrintOption"> | number
    isActive?: BoolWithAggregatesFilter<"PrintOption"> | boolean
  }

  export type MagnetPriceWhereInput = {
    AND?: MagnetPriceWhereInput | MagnetPriceWhereInput[]
    OR?: MagnetPriceWhereInput[]
    NOT?: MagnetPriceWhereInput | MagnetPriceWhereInput[]
    id?: IntFilter<"MagnetPrice"> | number
    sizeSlug?: StringFilter<"MagnetPrice"> | string
    price?: FloatFilter<"MagnetPrice"> | number
    isActive?: BoolFilter<"MagnetPrice"> | boolean
  }

  export type MagnetPriceOrderByWithRelationInput = {
    id?: SortOrder
    sizeSlug?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
  }

  export type MagnetPriceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MagnetPriceWhereInput | MagnetPriceWhereInput[]
    OR?: MagnetPriceWhereInput[]
    NOT?: MagnetPriceWhereInput | MagnetPriceWhereInput[]
    sizeSlug?: StringFilter<"MagnetPrice"> | string
    price?: FloatFilter<"MagnetPrice"> | number
    isActive?: BoolFilter<"MagnetPrice"> | boolean
  }, "id">

  export type MagnetPriceOrderByWithAggregationInput = {
    id?: SortOrder
    sizeSlug?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
    _count?: MagnetPriceCountOrderByAggregateInput
    _avg?: MagnetPriceAvgOrderByAggregateInput
    _max?: MagnetPriceMaxOrderByAggregateInput
    _min?: MagnetPriceMinOrderByAggregateInput
    _sum?: MagnetPriceSumOrderByAggregateInput
  }

  export type MagnetPriceScalarWhereWithAggregatesInput = {
    AND?: MagnetPriceScalarWhereWithAggregatesInput | MagnetPriceScalarWhereWithAggregatesInput[]
    OR?: MagnetPriceScalarWhereWithAggregatesInput[]
    NOT?: MagnetPriceScalarWhereWithAggregatesInput | MagnetPriceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MagnetPrice"> | number
    sizeSlug?: StringWithAggregatesFilter<"MagnetPrice"> | string
    price?: FloatWithAggregatesFilter<"MagnetPrice"> | number
    isActive?: BoolWithAggregatesFilter<"MagnetPrice"> | boolean
  }

  export type DeliveryOptionWhereInput = {
    AND?: DeliveryOptionWhereInput | DeliveryOptionWhereInput[]
    OR?: DeliveryOptionWhereInput[]
    NOT?: DeliveryOptionWhereInput | DeliveryOptionWhereInput[]
    id?: IntFilter<"DeliveryOption"> | number
    slug?: StringFilter<"DeliveryOption"> | string
    name?: StringFilter<"DeliveryOption"> | string
    price?: FloatFilter<"DeliveryOption"> | number
    description?: StringNullableFilter<"DeliveryOption"> | string | null
    isActive?: BoolFilter<"DeliveryOption"> | boolean
  }

  export type DeliveryOptionOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
  }

  export type DeliveryOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: DeliveryOptionWhereInput | DeliveryOptionWhereInput[]
    OR?: DeliveryOptionWhereInput[]
    NOT?: DeliveryOptionWhereInput | DeliveryOptionWhereInput[]
    name?: StringFilter<"DeliveryOption"> | string
    price?: FloatFilter<"DeliveryOption"> | number
    description?: StringNullableFilter<"DeliveryOption"> | string | null
    isActive?: BoolFilter<"DeliveryOption"> | boolean
  }, "id" | "slug">

  export type DeliveryOptionOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: DeliveryOptionCountOrderByAggregateInput
    _avg?: DeliveryOptionAvgOrderByAggregateInput
    _max?: DeliveryOptionMaxOrderByAggregateInput
    _min?: DeliveryOptionMinOrderByAggregateInput
    _sum?: DeliveryOptionSumOrderByAggregateInput
  }

  export type DeliveryOptionScalarWhereWithAggregatesInput = {
    AND?: DeliveryOptionScalarWhereWithAggregatesInput | DeliveryOptionScalarWhereWithAggregatesInput[]
    OR?: DeliveryOptionScalarWhereWithAggregatesInput[]
    NOT?: DeliveryOptionScalarWhereWithAggregatesInput | DeliveryOptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeliveryOption"> | number
    slug?: StringWithAggregatesFilter<"DeliveryOption"> | string
    name?: StringWithAggregatesFilter<"DeliveryOption"> | string
    price?: FloatWithAggregatesFilter<"DeliveryOption"> | number
    description?: StringNullableWithAggregatesFilter<"DeliveryOption"> | string | null
    isActive?: BoolWithAggregatesFilter<"DeliveryOption"> | boolean
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    images?: StringNullableFilter<"Product"> | string | null
    stock?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    images?: SortOrderInput | SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    images?: StringNullableFilter<"Product"> | string | null
    stock?: IntFilter<"Product"> | number
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    images?: SortOrderInput | SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: FloatWithAggregatesFilter<"Product"> | number
    images?: StringNullableWithAggregatesFilter<"Product"> | string | null
    stock?: IntWithAggregatesFilter<"Product"> | number
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type TranslationWhereInput = {
    AND?: TranslationWhereInput | TranslationWhereInput[]
    OR?: TranslationWhereInput[]
    NOT?: TranslationWhereInput | TranslationWhereInput[]
    id?: IntFilter<"Translation"> | number
    lang?: StringFilter<"Translation"> | string
    key?: StringFilter<"Translation"> | string
    value?: StringFilter<"Translation"> | string
  }

  export type TranslationOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type TranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    lang_key?: TranslationLangKeyCompoundUniqueInput
    AND?: TranslationWhereInput | TranslationWhereInput[]
    OR?: TranslationWhereInput[]
    NOT?: TranslationWhereInput | TranslationWhereInput[]
    lang?: StringFilter<"Translation"> | string
    key?: StringFilter<"Translation"> | string
    value?: StringFilter<"Translation"> | string
  }, "id" | "lang_key">

  export type TranslationOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: TranslationCountOrderByAggregateInput
    _avg?: TranslationAvgOrderByAggregateInput
    _max?: TranslationMaxOrderByAggregateInput
    _min?: TranslationMinOrderByAggregateInput
    _sum?: TranslationSumOrderByAggregateInput
  }

  export type TranslationScalarWhereWithAggregatesInput = {
    AND?: TranslationScalarWhereWithAggregatesInput | TranslationScalarWhereWithAggregatesInput[]
    OR?: TranslationScalarWhereWithAggregatesInput[]
    NOT?: TranslationScalarWhereWithAggregatesInput | TranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Translation"> | number
    lang?: StringWithAggregatesFilter<"Translation"> | string
    key?: StringWithAggregatesFilter<"Translation"> | string
    value?: StringWithAggregatesFilter<"Translation"> | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
  }

  export type SettingOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    value?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
  }, "key">

  export type SettingOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: StringWithAggregatesFilter<"Setting"> | string
    description?: StringNullableWithAggregatesFilter<"Setting"> | string | null
  }

  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: IntFilter<"Page"> | number
    lang?: StringFilter<"Page"> | string
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    content?: StringFilter<"Page"> | string
    description?: StringNullableFilter<"Page"> | string | null
    isActive?: BoolFilter<"Page"> | boolean
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug_lang?: PageSlugLangCompoundUniqueInput
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    lang?: StringFilter<"Page"> | string
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    content?: StringFilter<"Page"> | string
    description?: StringNullableFilter<"Page"> | string | null
    isActive?: BoolFilter<"Page"> | boolean
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
  }, "id" | "slug_lang">

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _avg?: PageAvgOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
    _sum?: PageSumOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Page"> | number
    lang?: StringWithAggregatesFilter<"Page"> | string
    title?: StringWithAggregatesFilter<"Page"> | string
    slug?: StringWithAggregatesFilter<"Page"> | string
    content?: StringWithAggregatesFilter<"Page"> | string
    description?: StringNullableWithAggregatesFilter<"Page"> | string | null
    isActive?: BoolWithAggregatesFilter<"Page"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
  }

  export type HelpCategoryWhereInput = {
    AND?: HelpCategoryWhereInput | HelpCategoryWhereInput[]
    OR?: HelpCategoryWhereInput[]
    NOT?: HelpCategoryWhereInput | HelpCategoryWhereInput[]
    id?: IntFilter<"HelpCategory"> | number
    slug?: StringFilter<"HelpCategory"> | string
    sortOrder?: IntFilter<"HelpCategory"> | number
    isActive?: BoolFilter<"HelpCategory"> | boolean
    createdAt?: DateTimeFilter<"HelpCategory"> | Date | string
    updatedAt?: DateTimeFilter<"HelpCategory"> | Date | string
    translations?: HelpCategoryTranslationListRelationFilter
    articles?: HelpArticleListRelationFilter
  }

  export type HelpCategoryOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    translations?: HelpCategoryTranslationOrderByRelationAggregateInput
    articles?: HelpArticleOrderByRelationAggregateInput
  }

  export type HelpCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: HelpCategoryWhereInput | HelpCategoryWhereInput[]
    OR?: HelpCategoryWhereInput[]
    NOT?: HelpCategoryWhereInput | HelpCategoryWhereInput[]
    sortOrder?: IntFilter<"HelpCategory"> | number
    isActive?: BoolFilter<"HelpCategory"> | boolean
    createdAt?: DateTimeFilter<"HelpCategory"> | Date | string
    updatedAt?: DateTimeFilter<"HelpCategory"> | Date | string
    translations?: HelpCategoryTranslationListRelationFilter
    articles?: HelpArticleListRelationFilter
  }, "id" | "slug">

  export type HelpCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HelpCategoryCountOrderByAggregateInput
    _avg?: HelpCategoryAvgOrderByAggregateInput
    _max?: HelpCategoryMaxOrderByAggregateInput
    _min?: HelpCategoryMinOrderByAggregateInput
    _sum?: HelpCategorySumOrderByAggregateInput
  }

  export type HelpCategoryScalarWhereWithAggregatesInput = {
    AND?: HelpCategoryScalarWhereWithAggregatesInput | HelpCategoryScalarWhereWithAggregatesInput[]
    OR?: HelpCategoryScalarWhereWithAggregatesInput[]
    NOT?: HelpCategoryScalarWhereWithAggregatesInput | HelpCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HelpCategory"> | number
    slug?: StringWithAggregatesFilter<"HelpCategory"> | string
    sortOrder?: IntWithAggregatesFilter<"HelpCategory"> | number
    isActive?: BoolWithAggregatesFilter<"HelpCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"HelpCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HelpCategory"> | Date | string
  }

  export type HelpCategoryTranslationWhereInput = {
    AND?: HelpCategoryTranslationWhereInput | HelpCategoryTranslationWhereInput[]
    OR?: HelpCategoryTranslationWhereInput[]
    NOT?: HelpCategoryTranslationWhereInput | HelpCategoryTranslationWhereInput[]
    id?: IntFilter<"HelpCategoryTranslation"> | number
    helpCategoryId?: IntFilter<"HelpCategoryTranslation"> | number
    lang?: StringFilter<"HelpCategoryTranslation"> | string
    name?: StringFilter<"HelpCategoryTranslation"> | string
    helpCategory?: XOR<HelpCategoryRelationFilter, HelpCategoryWhereInput>
  }

  export type HelpCategoryTranslationOrderByWithRelationInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    helpCategory?: HelpCategoryOrderByWithRelationInput
  }

  export type HelpCategoryTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    helpCategoryId_lang?: HelpCategoryTranslationHelpCategoryIdLangCompoundUniqueInput
    AND?: HelpCategoryTranslationWhereInput | HelpCategoryTranslationWhereInput[]
    OR?: HelpCategoryTranslationWhereInput[]
    NOT?: HelpCategoryTranslationWhereInput | HelpCategoryTranslationWhereInput[]
    helpCategoryId?: IntFilter<"HelpCategoryTranslation"> | number
    lang?: StringFilter<"HelpCategoryTranslation"> | string
    name?: StringFilter<"HelpCategoryTranslation"> | string
    helpCategory?: XOR<HelpCategoryRelationFilter, HelpCategoryWhereInput>
  }, "id" | "helpCategoryId_lang">

  export type HelpCategoryTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    _count?: HelpCategoryTranslationCountOrderByAggregateInput
    _avg?: HelpCategoryTranslationAvgOrderByAggregateInput
    _max?: HelpCategoryTranslationMaxOrderByAggregateInput
    _min?: HelpCategoryTranslationMinOrderByAggregateInput
    _sum?: HelpCategoryTranslationSumOrderByAggregateInput
  }

  export type HelpCategoryTranslationScalarWhereWithAggregatesInput = {
    AND?: HelpCategoryTranslationScalarWhereWithAggregatesInput | HelpCategoryTranslationScalarWhereWithAggregatesInput[]
    OR?: HelpCategoryTranslationScalarWhereWithAggregatesInput[]
    NOT?: HelpCategoryTranslationScalarWhereWithAggregatesInput | HelpCategoryTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HelpCategoryTranslation"> | number
    helpCategoryId?: IntWithAggregatesFilter<"HelpCategoryTranslation"> | number
    lang?: StringWithAggregatesFilter<"HelpCategoryTranslation"> | string
    name?: StringWithAggregatesFilter<"HelpCategoryTranslation"> | string
  }

  export type HelpArticleWhereInput = {
    AND?: HelpArticleWhereInput | HelpArticleWhereInput[]
    OR?: HelpArticleWhereInput[]
    NOT?: HelpArticleWhereInput | HelpArticleWhereInput[]
    id?: IntFilter<"HelpArticle"> | number
    helpCategoryId?: IntFilter<"HelpArticle"> | number
    slug?: StringFilter<"HelpArticle"> | string
    sortOrder?: IntFilter<"HelpArticle"> | number
    isActive?: BoolFilter<"HelpArticle"> | boolean
    createdAt?: DateTimeFilter<"HelpArticle"> | Date | string
    updatedAt?: DateTimeFilter<"HelpArticle"> | Date | string
    helpCategory?: XOR<HelpCategoryRelationFilter, HelpCategoryWhereInput>
    translations?: HelpArticleTranslationListRelationFilter
  }

  export type HelpArticleOrderByWithRelationInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    slug?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    helpCategory?: HelpCategoryOrderByWithRelationInput
    translations?: HelpArticleTranslationOrderByRelationAggregateInput
  }

  export type HelpArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: HelpArticleWhereInput | HelpArticleWhereInput[]
    OR?: HelpArticleWhereInput[]
    NOT?: HelpArticleWhereInput | HelpArticleWhereInput[]
    helpCategoryId?: IntFilter<"HelpArticle"> | number
    sortOrder?: IntFilter<"HelpArticle"> | number
    isActive?: BoolFilter<"HelpArticle"> | boolean
    createdAt?: DateTimeFilter<"HelpArticle"> | Date | string
    updatedAt?: DateTimeFilter<"HelpArticle"> | Date | string
    helpCategory?: XOR<HelpCategoryRelationFilter, HelpCategoryWhereInput>
    translations?: HelpArticleTranslationListRelationFilter
  }, "id" | "slug">

  export type HelpArticleOrderByWithAggregationInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    slug?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HelpArticleCountOrderByAggregateInput
    _avg?: HelpArticleAvgOrderByAggregateInput
    _max?: HelpArticleMaxOrderByAggregateInput
    _min?: HelpArticleMinOrderByAggregateInput
    _sum?: HelpArticleSumOrderByAggregateInput
  }

  export type HelpArticleScalarWhereWithAggregatesInput = {
    AND?: HelpArticleScalarWhereWithAggregatesInput | HelpArticleScalarWhereWithAggregatesInput[]
    OR?: HelpArticleScalarWhereWithAggregatesInput[]
    NOT?: HelpArticleScalarWhereWithAggregatesInput | HelpArticleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HelpArticle"> | number
    helpCategoryId?: IntWithAggregatesFilter<"HelpArticle"> | number
    slug?: StringWithAggregatesFilter<"HelpArticle"> | string
    sortOrder?: IntWithAggregatesFilter<"HelpArticle"> | number
    isActive?: BoolWithAggregatesFilter<"HelpArticle"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"HelpArticle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HelpArticle"> | Date | string
  }

  export type HelpArticleTranslationWhereInput = {
    AND?: HelpArticleTranslationWhereInput | HelpArticleTranslationWhereInput[]
    OR?: HelpArticleTranslationWhereInput[]
    NOT?: HelpArticleTranslationWhereInput | HelpArticleTranslationWhereInput[]
    id?: IntFilter<"HelpArticleTranslation"> | number
    helpArticleId?: IntFilter<"HelpArticleTranslation"> | number
    lang?: StringFilter<"HelpArticleTranslation"> | string
    title?: StringFilter<"HelpArticleTranslation"> | string
    content?: StringFilter<"HelpArticleTranslation"> | string
    helpArticle?: XOR<HelpArticleRelationFilter, HelpArticleWhereInput>
  }

  export type HelpArticleTranslationOrderByWithRelationInput = {
    id?: SortOrder
    helpArticleId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    helpArticle?: HelpArticleOrderByWithRelationInput
  }

  export type HelpArticleTranslationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    helpArticleId_lang?: HelpArticleTranslationHelpArticleIdLangCompoundUniqueInput
    AND?: HelpArticleTranslationWhereInput | HelpArticleTranslationWhereInput[]
    OR?: HelpArticleTranslationWhereInput[]
    NOT?: HelpArticleTranslationWhereInput | HelpArticleTranslationWhereInput[]
    helpArticleId?: IntFilter<"HelpArticleTranslation"> | number
    lang?: StringFilter<"HelpArticleTranslation"> | string
    title?: StringFilter<"HelpArticleTranslation"> | string
    content?: StringFilter<"HelpArticleTranslation"> | string
    helpArticle?: XOR<HelpArticleRelationFilter, HelpArticleWhereInput>
  }, "id" | "helpArticleId_lang">

  export type HelpArticleTranslationOrderByWithAggregationInput = {
    id?: SortOrder
    helpArticleId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
    _count?: HelpArticleTranslationCountOrderByAggregateInput
    _avg?: HelpArticleTranslationAvgOrderByAggregateInput
    _max?: HelpArticleTranslationMaxOrderByAggregateInput
    _min?: HelpArticleTranslationMinOrderByAggregateInput
    _sum?: HelpArticleTranslationSumOrderByAggregateInput
  }

  export type HelpArticleTranslationScalarWhereWithAggregatesInput = {
    AND?: HelpArticleTranslationScalarWhereWithAggregatesInput | HelpArticleTranslationScalarWhereWithAggregatesInput[]
    OR?: HelpArticleTranslationScalarWhereWithAggregatesInput[]
    NOT?: HelpArticleTranslationScalarWhereWithAggregatesInput | HelpArticleTranslationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HelpArticleTranslation"> | number
    helpArticleId?: IntWithAggregatesFilter<"HelpArticleTranslation"> | number
    lang?: StringWithAggregatesFilter<"HelpArticleTranslation"> | string
    title?: StringWithAggregatesFilter<"HelpArticleTranslation"> | string
    content?: StringWithAggregatesFilter<"HelpArticleTranslation"> | string
  }

  export type OrderSequenceWhereInput = {
    AND?: OrderSequenceWhereInput | OrderSequenceWhereInput[]
    OR?: OrderSequenceWhereInput[]
    NOT?: OrderSequenceWhereInput | OrderSequenceWhereInput[]
    id?: IntFilter<"OrderSequence"> | number
    currentValue?: IntFilter<"OrderSequence"> | number
  }

  export type OrderSequenceOrderByWithRelationInput = {
    id?: SortOrder
    currentValue?: SortOrder
  }

  export type OrderSequenceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderSequenceWhereInput | OrderSequenceWhereInput[]
    OR?: OrderSequenceWhereInput[]
    NOT?: OrderSequenceWhereInput | OrderSequenceWhereInput[]
    currentValue?: IntFilter<"OrderSequence"> | number
  }, "id">

  export type OrderSequenceOrderByWithAggregationInput = {
    id?: SortOrder
    currentValue?: SortOrder
    _count?: OrderSequenceCountOrderByAggregateInput
    _avg?: OrderSequenceAvgOrderByAggregateInput
    _max?: OrderSequenceMaxOrderByAggregateInput
    _min?: OrderSequenceMinOrderByAggregateInput
    _sum?: OrderSequenceSumOrderByAggregateInput
  }

  export type OrderSequenceScalarWhereWithAggregatesInput = {
    AND?: OrderSequenceScalarWhereWithAggregatesInput | OrderSequenceScalarWhereWithAggregatesInput[]
    OR?: OrderSequenceScalarWhereWithAggregatesInput[]
    NOT?: OrderSequenceScalarWhereWithAggregatesInput | OrderSequenceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderSequence"> | number
    currentValue?: IntWithAggregatesFilter<"OrderSequence"> | number
  }

  export type NPSenderWhereInput = {
    AND?: NPSenderWhereInput | NPSenderWhereInput[]
    OR?: NPSenderWhereInput[]
    NOT?: NPSenderWhereInput | NPSenderWhereInput[]
    id?: IntFilter<"NPSender"> | number
    name?: StringFilter<"NPSender"> | string
    firstName?: StringNullableFilter<"NPSender"> | string | null
    lastName?: StringNullableFilter<"NPSender"> | string | null
    phone?: StringFilter<"NPSender"> | string
    cityRef?: StringFilter<"NPSender"> | string
    cityName?: StringFilter<"NPSender"> | string
    warehouseRef?: StringFilter<"NPSender"> | string
    warehouseName?: StringFilter<"NPSender"> | string
    createdAt?: DateTimeFilter<"NPSender"> | Date | string
  }

  export type NPSenderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrder
    cityRef?: SortOrder
    cityName?: SortOrder
    warehouseRef?: SortOrder
    warehouseName?: SortOrder
    createdAt?: SortOrder
  }

  export type NPSenderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NPSenderWhereInput | NPSenderWhereInput[]
    OR?: NPSenderWhereInput[]
    NOT?: NPSenderWhereInput | NPSenderWhereInput[]
    name?: StringFilter<"NPSender"> | string
    firstName?: StringNullableFilter<"NPSender"> | string | null
    lastName?: StringNullableFilter<"NPSender"> | string | null
    phone?: StringFilter<"NPSender"> | string
    cityRef?: StringFilter<"NPSender"> | string
    cityName?: StringFilter<"NPSender"> | string
    warehouseRef?: StringFilter<"NPSender"> | string
    warehouseName?: StringFilter<"NPSender"> | string
    createdAt?: DateTimeFilter<"NPSender"> | Date | string
  }, "id">

  export type NPSenderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    phone?: SortOrder
    cityRef?: SortOrder
    cityName?: SortOrder
    warehouseRef?: SortOrder
    warehouseName?: SortOrder
    createdAt?: SortOrder
    _count?: NPSenderCountOrderByAggregateInput
    _avg?: NPSenderAvgOrderByAggregateInput
    _max?: NPSenderMaxOrderByAggregateInput
    _min?: NPSenderMinOrderByAggregateInput
    _sum?: NPSenderSumOrderByAggregateInput
  }

  export type NPSenderScalarWhereWithAggregatesInput = {
    AND?: NPSenderScalarWhereWithAggregatesInput | NPSenderScalarWhereWithAggregatesInput[]
    OR?: NPSenderScalarWhereWithAggregatesInput[]
    NOT?: NPSenderScalarWhereWithAggregatesInput | NPSenderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NPSender"> | number
    name?: StringWithAggregatesFilter<"NPSender"> | string
    firstName?: StringNullableWithAggregatesFilter<"NPSender"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"NPSender"> | string | null
    phone?: StringWithAggregatesFilter<"NPSender"> | string
    cityRef?: StringWithAggregatesFilter<"NPSender"> | string
    cityName?: StringWithAggregatesFilter<"NPSender"> | string
    warehouseRef?: StringWithAggregatesFilter<"NPSender"> | string
    warehouseName?: StringWithAggregatesFilter<"NPSender"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NPSender"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    role?: string
    name?: string | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    orderNumber: string
    status?: string
    totalAmount?: number
    customerName?: string | null
    customerFirstName?: string | null
    customerLastName?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    deliveryAddress?: string | null
    deliveryMethod?: string
    recipientCityRef?: string | null
    recipientWarehouseRef?: string | null
    ttnNumber?: string | null
    ttnRef?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    orderNumber: string
    status?: string
    totalAmount?: number
    customerName?: string | null
    customerFirstName?: string | null
    customerLastName?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    deliveryAddress?: string | null
    deliveryMethod?: string
    recipientCityRef?: string | null
    recipientWarehouseRef?: string | null
    ttnNumber?: string | null
    ttnRef?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLastName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: StringFieldUpdateOperationsInput | string
    recipientCityRef?: NullableStringFieldUpdateOperationsInput | string | null
    recipientWarehouseRef?: NullableStringFieldUpdateOperationsInput | string | null
    ttnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ttnRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLastName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: StringFieldUpdateOperationsInput | string
    recipientCityRef?: NullableStringFieldUpdateOperationsInput | string | null
    recipientWarehouseRef?: NullableStringFieldUpdateOperationsInput | string | null
    ttnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ttnRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    orderNumber: string
    status?: string
    totalAmount?: number
    customerName?: string | null
    customerFirstName?: string | null
    customerLastName?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    deliveryAddress?: string | null
    deliveryMethod?: string
    recipientCityRef?: string | null
    recipientWarehouseRef?: string | null
    ttnNumber?: string | null
    ttnRef?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLastName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: StringFieldUpdateOperationsInput | string
    recipientCityRef?: NullableStringFieldUpdateOperationsInput | string | null
    recipientWarehouseRef?: NullableStringFieldUpdateOperationsInput | string | null
    ttnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ttnRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLastName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: StringFieldUpdateOperationsInput | string
    recipientCityRef?: NullableStringFieldUpdateOperationsInput | string | null
    recipientWarehouseRef?: NullableStringFieldUpdateOperationsInput | string | null
    ttnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ttnRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    type: string
    name: string
    quantity: number
    price: number
    subtotal: number
    size?: string | null
    paper?: string | null
    options?: string | null
    files?: string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    type: string
    name: string
    quantity: number
    price: number
    subtotal: number
    size?: string | null
    paper?: string | null
    options?: string | null
    files?: string | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    paper?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableStringFieldUpdateOperationsInput | string | null
    files?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    paper?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableStringFieldUpdateOperationsInput | string | null
    files?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderId: number
    type: string
    name: string
    quantity: number
    price: number
    subtotal: number
    size?: string | null
    paper?: string | null
    options?: string | null
    files?: string | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    paper?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableStringFieldUpdateOperationsInput | string | null
    files?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    paper?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableStringFieldUpdateOperationsInput | string | null
    files?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrintSizeCreateInput = {
    name: string
    slug: string
    widthMm?: number | null
    heightMm?: number | null
    basePrice: number
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    discounts?: VolumeDiscountCreateNestedManyWithoutPrintSizeInput
  }

  export type PrintSizeUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    widthMm?: number | null
    heightMm?: number | null
    basePrice: number
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    discounts?: VolumeDiscountUncheckedCreateNestedManyWithoutPrintSizeInput
  }

  export type PrintSizeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    widthMm?: NullableFloatFieldUpdateOperationsInput | number | null
    heightMm?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discounts?: VolumeDiscountUpdateManyWithoutPrintSizeNestedInput
  }

  export type PrintSizeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    widthMm?: NullableFloatFieldUpdateOperationsInput | number | null
    heightMm?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discounts?: VolumeDiscountUncheckedUpdateManyWithoutPrintSizeNestedInput
  }

  export type PrintSizeCreateManyInput = {
    id?: number
    name: string
    slug: string
    widthMm?: number | null
    heightMm?: number | null
    basePrice: number
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PrintSizeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    widthMm?: NullableFloatFieldUpdateOperationsInput | number | null
    heightMm?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrintSizeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    widthMm?: NullableFloatFieldUpdateOperationsInput | number | null
    heightMm?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuantityTierCreateInput = {
    label: string
    minQuantity: number
    sortOrder?: number
    isActive?: boolean
    discounts?: VolumeDiscountCreateNestedManyWithoutTierInput
  }

  export type QuantityTierUncheckedCreateInput = {
    id?: number
    label: string
    minQuantity: number
    sortOrder?: number
    isActive?: boolean
    discounts?: VolumeDiscountUncheckedCreateNestedManyWithoutTierInput
  }

  export type QuantityTierUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    minQuantity?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    discounts?: VolumeDiscountUpdateManyWithoutTierNestedInput
  }

  export type QuantityTierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    minQuantity?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    discounts?: VolumeDiscountUncheckedUpdateManyWithoutTierNestedInput
  }

  export type QuantityTierCreateManyInput = {
    id?: number
    label: string
    minQuantity: number
    sortOrder?: number
    isActive?: boolean
  }

  export type QuantityTierUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    minQuantity?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuantityTierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    minQuantity?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VolumeDiscountCreateInput = {
    minQuantity: number
    price: number
    printSize: PrintSizeCreateNestedOneWithoutDiscountsInput
    tier?: QuantityTierCreateNestedOneWithoutDiscountsInput
  }

  export type VolumeDiscountUncheckedCreateInput = {
    id?: number
    printSizeId: number
    tierId?: number | null
    minQuantity: number
    price: number
  }

  export type VolumeDiscountUpdateInput = {
    minQuantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    printSize?: PrintSizeUpdateOneRequiredWithoutDiscountsNestedInput
    tier?: QuantityTierUpdateOneWithoutDiscountsNestedInput
  }

  export type VolumeDiscountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    printSizeId?: IntFieldUpdateOperationsInput | number
    tierId?: NullableIntFieldUpdateOperationsInput | number | null
    minQuantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type VolumeDiscountCreateManyInput = {
    id?: number
    printSizeId: number
    tierId?: number | null
    minQuantity: number
    price: number
  }

  export type VolumeDiscountUpdateManyMutationInput = {
    minQuantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type VolumeDiscountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    printSizeId?: IntFieldUpdateOperationsInput | number
    tierId?: NullableIntFieldUpdateOperationsInput | number | null
    minQuantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type GiftThresholdCreateInput = {
    minAmount: number
    giftName: string
    isActive?: boolean
  }

  export type GiftThresholdUncheckedCreateInput = {
    id?: number
    minAmount: number
    giftName: string
    isActive?: boolean
  }

  export type GiftThresholdUpdateInput = {
    minAmount?: FloatFieldUpdateOperationsInput | number
    giftName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GiftThresholdUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minAmount?: FloatFieldUpdateOperationsInput | number
    giftName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GiftThresholdCreateManyInput = {
    id?: number
    minAmount: number
    giftName: string
    isActive?: boolean
  }

  export type GiftThresholdUpdateManyMutationInput = {
    minAmount?: FloatFieldUpdateOperationsInput | number
    giftName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GiftThresholdUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    minAmount?: FloatFieldUpdateOperationsInput | number
    giftName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaperTypeCreateInput = {
    name: string
    slug: string
    description?: string | null
    isActive?: boolean
  }

  export type PaperTypeUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    isActive?: boolean
  }

  export type PaperTypeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaperTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaperTypeCreateManyInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    isActive?: boolean
  }

  export type PaperTypeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaperTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrintOptionCreateInput = {
    name: string
    slug: string
    priceType: string
    price: number
    isActive?: boolean
  }

  export type PrintOptionUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    priceType: string
    price: number
    isActive?: boolean
  }

  export type PrintOptionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    priceType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrintOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    priceType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrintOptionCreateManyInput = {
    id?: number
    name: string
    slug: string
    priceType: string
    price: number
    isActive?: boolean
  }

  export type PrintOptionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    priceType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PrintOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    priceType?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MagnetPriceCreateInput = {
    sizeSlug: string
    price: number
    isActive?: boolean
  }

  export type MagnetPriceUncheckedCreateInput = {
    id?: number
    sizeSlug: string
    price: number
    isActive?: boolean
  }

  export type MagnetPriceUpdateInput = {
    sizeSlug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MagnetPriceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sizeSlug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MagnetPriceCreateManyInput = {
    id?: number
    sizeSlug: string
    price: number
    isActive?: boolean
  }

  export type MagnetPriceUpdateManyMutationInput = {
    sizeSlug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MagnetPriceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sizeSlug?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DeliveryOptionCreateInput = {
    slug: string
    name: string
    price: number
    description?: string | null
    isActive?: boolean
  }

  export type DeliveryOptionUncheckedCreateInput = {
    id?: number
    slug: string
    name: string
    price: number
    description?: string | null
    isActive?: boolean
  }

  export type DeliveryOptionUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DeliveryOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DeliveryOptionCreateManyInput = {
    id?: number
    slug: string
    name: string
    price: number
    description?: string | null
    isActive?: boolean
  }

  export type DeliveryOptionUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DeliveryOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProductCreateInput = {
    name: string
    description?: string | null
    price: number
    images?: string | null
    stock?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    price: number
    images?: string | null
    stock?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    price: number
    images?: string | null
    stock?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    images?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TranslationCreateInput = {
    lang: string
    key: string
    value: string
  }

  export type TranslationUncheckedCreateInput = {
    id?: number
    lang: string
    key: string
    value: string
  }

  export type TranslationUpdateInput = {
    lang?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TranslationCreateManyInput = {
    id?: number
    lang: string
    key: string
    value: string
  }

  export type TranslationUpdateManyMutationInput = {
    lang?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type TranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type SettingCreateInput = {
    key: string
    value: string
    description?: string | null
  }

  export type SettingUncheckedCreateInput = {
    key: string
    value: string
    description?: string | null
  }

  export type SettingUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingCreateManyInput = {
    key: string
    value: string
    description?: string | null
  }

  export type SettingUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SettingUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PageCreateInput = {
    lang?: string
    title: string
    slug: string
    content: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUncheckedCreateInput = {
    id?: number
    lang?: string
    title: string
    slug: string
    content: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateManyInput = {
    id?: number
    lang?: string
    title: string
    slug: string
    content: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateManyMutationInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCategoryCreateInput = {
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: HelpCategoryTranslationCreateNestedManyWithoutHelpCategoryInput
    articles?: HelpArticleCreateNestedManyWithoutHelpCategoryInput
  }

  export type HelpCategoryUncheckedCreateInput = {
    id?: number
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: HelpCategoryTranslationUncheckedCreateNestedManyWithoutHelpCategoryInput
    articles?: HelpArticleUncheckedCreateNestedManyWithoutHelpCategoryInput
  }

  export type HelpCategoryUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: HelpCategoryTranslationUpdateManyWithoutHelpCategoryNestedInput
    articles?: HelpArticleUpdateManyWithoutHelpCategoryNestedInput
  }

  export type HelpCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: HelpCategoryTranslationUncheckedUpdateManyWithoutHelpCategoryNestedInput
    articles?: HelpArticleUncheckedUpdateManyWithoutHelpCategoryNestedInput
  }

  export type HelpCategoryCreateManyInput = {
    id?: number
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpCategoryUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpCategoryTranslationCreateInput = {
    lang: string
    name: string
    helpCategory: HelpCategoryCreateNestedOneWithoutTranslationsInput
  }

  export type HelpCategoryTranslationUncheckedCreateInput = {
    id?: number
    helpCategoryId: number
    lang: string
    name: string
  }

  export type HelpCategoryTranslationUpdateInput = {
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    helpCategory?: HelpCategoryUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type HelpCategoryTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    helpCategoryId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HelpCategoryTranslationCreateManyInput = {
    id?: number
    helpCategoryId: number
    lang: string
    name: string
  }

  export type HelpCategoryTranslationUpdateManyMutationInput = {
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HelpCategoryTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    helpCategoryId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HelpArticleCreateInput = {
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    helpCategory: HelpCategoryCreateNestedOneWithoutArticlesInput
    translations?: HelpArticleTranslationCreateNestedManyWithoutHelpArticleInput
  }

  export type HelpArticleUncheckedCreateInput = {
    id?: number
    helpCategoryId: number
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: HelpArticleTranslationUncheckedCreateNestedManyWithoutHelpArticleInput
  }

  export type HelpArticleUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpCategory?: HelpCategoryUpdateOneRequiredWithoutArticlesNestedInput
    translations?: HelpArticleTranslationUpdateManyWithoutHelpArticleNestedInput
  }

  export type HelpArticleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    helpCategoryId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: HelpArticleTranslationUncheckedUpdateManyWithoutHelpArticleNestedInput
  }

  export type HelpArticleCreateManyInput = {
    id?: number
    helpCategoryId: number
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpArticleUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpArticleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    helpCategoryId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpArticleTranslationCreateInput = {
    lang: string
    title: string
    content: string
    helpArticle: HelpArticleCreateNestedOneWithoutTranslationsInput
  }

  export type HelpArticleTranslationUncheckedCreateInput = {
    id?: number
    helpArticleId: number
    lang: string
    title: string
    content: string
  }

  export type HelpArticleTranslationUpdateInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    helpArticle?: HelpArticleUpdateOneRequiredWithoutTranslationsNestedInput
  }

  export type HelpArticleTranslationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    helpArticleId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type HelpArticleTranslationCreateManyInput = {
    id?: number
    helpArticleId: number
    lang: string
    title: string
    content: string
  }

  export type HelpArticleTranslationUpdateManyMutationInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type HelpArticleTranslationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    helpArticleId?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type OrderSequenceCreateInput = {
    currentValue?: number
  }

  export type OrderSequenceUncheckedCreateInput = {
    id?: number
    currentValue?: number
  }

  export type OrderSequenceUpdateInput = {
    currentValue?: IntFieldUpdateOperationsInput | number
  }

  export type OrderSequenceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentValue?: IntFieldUpdateOperationsInput | number
  }

  export type OrderSequenceCreateManyInput = {
    id?: number
    currentValue?: number
  }

  export type OrderSequenceUpdateManyMutationInput = {
    currentValue?: IntFieldUpdateOperationsInput | number
  }

  export type OrderSequenceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    currentValue?: IntFieldUpdateOperationsInput | number
  }

  export type NPSenderCreateInput = {
    name: string
    firstName?: string | null
    lastName?: string | null
    phone: string
    cityRef: string
    cityName: string
    warehouseRef: string
    warehouseName: string
    createdAt?: Date | string
  }

  export type NPSenderUncheckedCreateInput = {
    id?: number
    name: string
    firstName?: string | null
    lastName?: string | null
    phone: string
    cityRef: string
    cityName: string
    warehouseRef: string
    warehouseName: string
    createdAt?: Date | string
  }

  export type NPSenderUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    cityRef?: StringFieldUpdateOperationsInput | string
    cityName?: StringFieldUpdateOperationsInput | string
    warehouseRef?: StringFieldUpdateOperationsInput | string
    warehouseName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPSenderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    cityRef?: StringFieldUpdateOperationsInput | string
    cityName?: StringFieldUpdateOperationsInput | string
    warehouseRef?: StringFieldUpdateOperationsInput | string
    warehouseName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPSenderCreateManyInput = {
    id?: number
    name: string
    firstName?: string | null
    lastName?: string | null
    phone: string
    cityRef: string
    cityName: string
    warehouseRef: string
    warehouseName: string
    createdAt?: Date | string
  }

  export type NPSenderUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    cityRef?: StringFieldUpdateOperationsInput | string
    cityName?: StringFieldUpdateOperationsInput | string
    warehouseRef?: StringFieldUpdateOperationsInput | string
    warehouseName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPSenderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    cityRef?: StringFieldUpdateOperationsInput | string
    cityName?: StringFieldUpdateOperationsInput | string
    warehouseRef?: StringFieldUpdateOperationsInput | string
    warehouseName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    customerName?: SortOrder
    customerFirstName?: SortOrder
    customerLastName?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    deliveryAddress?: SortOrder
    deliveryMethod?: SortOrder
    recipientCityRef?: SortOrder
    recipientWarehouseRef?: SortOrder
    ttnNumber?: SortOrder
    ttnRef?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    customerName?: SortOrder
    customerFirstName?: SortOrder
    customerLastName?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    deliveryAddress?: SortOrder
    deliveryMethod?: SortOrder
    recipientCityRef?: SortOrder
    recipientWarehouseRef?: SortOrder
    ttnNumber?: SortOrder
    ttnRef?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    customerName?: SortOrder
    customerFirstName?: SortOrder
    customerLastName?: SortOrder
    customerPhone?: SortOrder
    customerEmail?: SortOrder
    deliveryAddress?: SortOrder
    deliveryMethod?: SortOrder
    recipientCityRef?: SortOrder
    recipientWarehouseRef?: SortOrder
    ttnNumber?: SortOrder
    ttnRef?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    subtotal?: SortOrder
    size?: SortOrder
    paper?: SortOrder
    options?: SortOrder
    files?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    subtotal?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    subtotal?: SortOrder
    size?: SortOrder
    paper?: SortOrder
    options?: SortOrder
    files?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    subtotal?: SortOrder
    size?: SortOrder
    paper?: SortOrder
    options?: SortOrder
    files?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    subtotal?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type VolumeDiscountListRelationFilter = {
    every?: VolumeDiscountWhereInput
    some?: VolumeDiscountWhereInput
    none?: VolumeDiscountWhereInput
  }

  export type VolumeDiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrintSizeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    widthMm?: SortOrder
    heightMm?: SortOrder
    basePrice?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PrintSizeAvgOrderByAggregateInput = {
    id?: SortOrder
    widthMm?: SortOrder
    heightMm?: SortOrder
    basePrice?: SortOrder
    sortOrder?: SortOrder
  }

  export type PrintSizeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    widthMm?: SortOrder
    heightMm?: SortOrder
    basePrice?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PrintSizeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    widthMm?: SortOrder
    heightMm?: SortOrder
    basePrice?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type PrintSizeSumOrderByAggregateInput = {
    id?: SortOrder
    widthMm?: SortOrder
    heightMm?: SortOrder
    basePrice?: SortOrder
    sortOrder?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type QuantityTierCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    minQuantity?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
  }

  export type QuantityTierAvgOrderByAggregateInput = {
    id?: SortOrder
    minQuantity?: SortOrder
    sortOrder?: SortOrder
  }

  export type QuantityTierMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    minQuantity?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
  }

  export type QuantityTierMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    minQuantity?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
  }

  export type QuantityTierSumOrderByAggregateInput = {
    id?: SortOrder
    minQuantity?: SortOrder
    sortOrder?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PrintSizeRelationFilter = {
    is?: PrintSizeWhereInput
    isNot?: PrintSizeWhereInput
  }

  export type QuantityTierNullableRelationFilter = {
    is?: QuantityTierWhereInput | null
    isNot?: QuantityTierWhereInput | null
  }

  export type VolumeDiscountCountOrderByAggregateInput = {
    id?: SortOrder
    printSizeId?: SortOrder
    tierId?: SortOrder
    minQuantity?: SortOrder
    price?: SortOrder
  }

  export type VolumeDiscountAvgOrderByAggregateInput = {
    id?: SortOrder
    printSizeId?: SortOrder
    tierId?: SortOrder
    minQuantity?: SortOrder
    price?: SortOrder
  }

  export type VolumeDiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    printSizeId?: SortOrder
    tierId?: SortOrder
    minQuantity?: SortOrder
    price?: SortOrder
  }

  export type VolumeDiscountMinOrderByAggregateInput = {
    id?: SortOrder
    printSizeId?: SortOrder
    tierId?: SortOrder
    minQuantity?: SortOrder
    price?: SortOrder
  }

  export type VolumeDiscountSumOrderByAggregateInput = {
    id?: SortOrder
    printSizeId?: SortOrder
    tierId?: SortOrder
    minQuantity?: SortOrder
    price?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type GiftThresholdCountOrderByAggregateInput = {
    id?: SortOrder
    minAmount?: SortOrder
    giftName?: SortOrder
    isActive?: SortOrder
  }

  export type GiftThresholdAvgOrderByAggregateInput = {
    id?: SortOrder
    minAmount?: SortOrder
  }

  export type GiftThresholdMaxOrderByAggregateInput = {
    id?: SortOrder
    minAmount?: SortOrder
    giftName?: SortOrder
    isActive?: SortOrder
  }

  export type GiftThresholdMinOrderByAggregateInput = {
    id?: SortOrder
    minAmount?: SortOrder
    giftName?: SortOrder
    isActive?: SortOrder
  }

  export type GiftThresholdSumOrderByAggregateInput = {
    id?: SortOrder
    minAmount?: SortOrder
  }

  export type PaperTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type PaperTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PaperTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type PaperTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type PaperTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PrintOptionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
  }

  export type PrintOptionAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type PrintOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
  }

  export type PrintOptionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    priceType?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
  }

  export type PrintOptionSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type MagnetPriceCountOrderByAggregateInput = {
    id?: SortOrder
    sizeSlug?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
  }

  export type MagnetPriceAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type MagnetPriceMaxOrderByAggregateInput = {
    id?: SortOrder
    sizeSlug?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
  }

  export type MagnetPriceMinOrderByAggregateInput = {
    id?: SortOrder
    sizeSlug?: SortOrder
    price?: SortOrder
    isActive?: SortOrder
  }

  export type MagnetPriceSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type DeliveryOptionCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type DeliveryOptionAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type DeliveryOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type DeliveryOptionMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    price?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
  }

  export type DeliveryOptionSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    images?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    images?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    images?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
  }

  export type TranslationLangKeyCompoundUniqueInput = {
    lang: string
    key: string
  }

  export type TranslationCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type TranslationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type TranslationMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type TranslationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type PageSlugLangCompoundUniqueInput = {
    slug: string
    lang: string
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HelpCategoryTranslationListRelationFilter = {
    every?: HelpCategoryTranslationWhereInput
    some?: HelpCategoryTranslationWhereInput
    none?: HelpCategoryTranslationWhereInput
  }

  export type HelpArticleListRelationFilter = {
    every?: HelpArticleWhereInput
    some?: HelpArticleWhereInput
    none?: HelpArticleWhereInput
  }

  export type HelpCategoryTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelpArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelpCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type HelpCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpCategorySumOrderByAggregateInput = {
    id?: SortOrder
    sortOrder?: SortOrder
  }

  export type HelpCategoryRelationFilter = {
    is?: HelpCategoryWhereInput
    isNot?: HelpCategoryWhereInput
  }

  export type HelpCategoryTranslationHelpCategoryIdLangCompoundUniqueInput = {
    helpCategoryId: number
    lang: string
  }

  export type HelpCategoryTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
  }

  export type HelpCategoryTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
  }

  export type HelpCategoryTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
  }

  export type HelpCategoryTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
  }

  export type HelpCategoryTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
  }

  export type HelpArticleTranslationListRelationFilter = {
    every?: HelpArticleTranslationWhereInput
    some?: HelpArticleTranslationWhereInput
    none?: HelpArticleTranslationWhereInput
  }

  export type HelpArticleTranslationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HelpArticleCountOrderByAggregateInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    slug?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpArticleAvgOrderByAggregateInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    sortOrder?: SortOrder
  }

  export type HelpArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    slug?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpArticleMinOrderByAggregateInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    slug?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HelpArticleSumOrderByAggregateInput = {
    id?: SortOrder
    helpCategoryId?: SortOrder
    sortOrder?: SortOrder
  }

  export type HelpArticleRelationFilter = {
    is?: HelpArticleWhereInput
    isNot?: HelpArticleWhereInput
  }

  export type HelpArticleTranslationHelpArticleIdLangCompoundUniqueInput = {
    helpArticleId: number
    lang: string
  }

  export type HelpArticleTranslationCountOrderByAggregateInput = {
    id?: SortOrder
    helpArticleId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
  }

  export type HelpArticleTranslationAvgOrderByAggregateInput = {
    id?: SortOrder
    helpArticleId?: SortOrder
  }

  export type HelpArticleTranslationMaxOrderByAggregateInput = {
    id?: SortOrder
    helpArticleId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
  }

  export type HelpArticleTranslationMinOrderByAggregateInput = {
    id?: SortOrder
    helpArticleId?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    content?: SortOrder
  }

  export type HelpArticleTranslationSumOrderByAggregateInput = {
    id?: SortOrder
    helpArticleId?: SortOrder
  }

  export type OrderSequenceCountOrderByAggregateInput = {
    id?: SortOrder
    currentValue?: SortOrder
  }

  export type OrderSequenceAvgOrderByAggregateInput = {
    id?: SortOrder
    currentValue?: SortOrder
  }

  export type OrderSequenceMaxOrderByAggregateInput = {
    id?: SortOrder
    currentValue?: SortOrder
  }

  export type OrderSequenceMinOrderByAggregateInput = {
    id?: SortOrder
    currentValue?: SortOrder
  }

  export type OrderSequenceSumOrderByAggregateInput = {
    id?: SortOrder
    currentValue?: SortOrder
  }

  export type NPSenderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    cityRef?: SortOrder
    cityName?: SortOrder
    warehouseRef?: SortOrder
    warehouseName?: SortOrder
    createdAt?: SortOrder
  }

  export type NPSenderAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NPSenderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    cityRef?: SortOrder
    cityName?: SortOrder
    warehouseRef?: SortOrder
    warehouseName?: SortOrder
    createdAt?: SortOrder
  }

  export type NPSenderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    cityRef?: SortOrder
    cityName?: SortOrder
    warehouseRef?: SortOrder
    warehouseName?: SortOrder
    createdAt?: SortOrder
  }

  export type NPSenderSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type VolumeDiscountCreateNestedManyWithoutPrintSizeInput = {
    create?: XOR<VolumeDiscountCreateWithoutPrintSizeInput, VolumeDiscountUncheckedCreateWithoutPrintSizeInput> | VolumeDiscountCreateWithoutPrintSizeInput[] | VolumeDiscountUncheckedCreateWithoutPrintSizeInput[]
    connectOrCreate?: VolumeDiscountCreateOrConnectWithoutPrintSizeInput | VolumeDiscountCreateOrConnectWithoutPrintSizeInput[]
    createMany?: VolumeDiscountCreateManyPrintSizeInputEnvelope
    connect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
  }

  export type VolumeDiscountUncheckedCreateNestedManyWithoutPrintSizeInput = {
    create?: XOR<VolumeDiscountCreateWithoutPrintSizeInput, VolumeDiscountUncheckedCreateWithoutPrintSizeInput> | VolumeDiscountCreateWithoutPrintSizeInput[] | VolumeDiscountUncheckedCreateWithoutPrintSizeInput[]
    connectOrCreate?: VolumeDiscountCreateOrConnectWithoutPrintSizeInput | VolumeDiscountCreateOrConnectWithoutPrintSizeInput[]
    createMany?: VolumeDiscountCreateManyPrintSizeInputEnvelope
    connect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type VolumeDiscountUpdateManyWithoutPrintSizeNestedInput = {
    create?: XOR<VolumeDiscountCreateWithoutPrintSizeInput, VolumeDiscountUncheckedCreateWithoutPrintSizeInput> | VolumeDiscountCreateWithoutPrintSizeInput[] | VolumeDiscountUncheckedCreateWithoutPrintSizeInput[]
    connectOrCreate?: VolumeDiscountCreateOrConnectWithoutPrintSizeInput | VolumeDiscountCreateOrConnectWithoutPrintSizeInput[]
    upsert?: VolumeDiscountUpsertWithWhereUniqueWithoutPrintSizeInput | VolumeDiscountUpsertWithWhereUniqueWithoutPrintSizeInput[]
    createMany?: VolumeDiscountCreateManyPrintSizeInputEnvelope
    set?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    disconnect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    delete?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    connect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    update?: VolumeDiscountUpdateWithWhereUniqueWithoutPrintSizeInput | VolumeDiscountUpdateWithWhereUniqueWithoutPrintSizeInput[]
    updateMany?: VolumeDiscountUpdateManyWithWhereWithoutPrintSizeInput | VolumeDiscountUpdateManyWithWhereWithoutPrintSizeInput[]
    deleteMany?: VolumeDiscountScalarWhereInput | VolumeDiscountScalarWhereInput[]
  }

  export type VolumeDiscountUncheckedUpdateManyWithoutPrintSizeNestedInput = {
    create?: XOR<VolumeDiscountCreateWithoutPrintSizeInput, VolumeDiscountUncheckedCreateWithoutPrintSizeInput> | VolumeDiscountCreateWithoutPrintSizeInput[] | VolumeDiscountUncheckedCreateWithoutPrintSizeInput[]
    connectOrCreate?: VolumeDiscountCreateOrConnectWithoutPrintSizeInput | VolumeDiscountCreateOrConnectWithoutPrintSizeInput[]
    upsert?: VolumeDiscountUpsertWithWhereUniqueWithoutPrintSizeInput | VolumeDiscountUpsertWithWhereUniqueWithoutPrintSizeInput[]
    createMany?: VolumeDiscountCreateManyPrintSizeInputEnvelope
    set?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    disconnect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    delete?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    connect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    update?: VolumeDiscountUpdateWithWhereUniqueWithoutPrintSizeInput | VolumeDiscountUpdateWithWhereUniqueWithoutPrintSizeInput[]
    updateMany?: VolumeDiscountUpdateManyWithWhereWithoutPrintSizeInput | VolumeDiscountUpdateManyWithWhereWithoutPrintSizeInput[]
    deleteMany?: VolumeDiscountScalarWhereInput | VolumeDiscountScalarWhereInput[]
  }

  export type VolumeDiscountCreateNestedManyWithoutTierInput = {
    create?: XOR<VolumeDiscountCreateWithoutTierInput, VolumeDiscountUncheckedCreateWithoutTierInput> | VolumeDiscountCreateWithoutTierInput[] | VolumeDiscountUncheckedCreateWithoutTierInput[]
    connectOrCreate?: VolumeDiscountCreateOrConnectWithoutTierInput | VolumeDiscountCreateOrConnectWithoutTierInput[]
    createMany?: VolumeDiscountCreateManyTierInputEnvelope
    connect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
  }

  export type VolumeDiscountUncheckedCreateNestedManyWithoutTierInput = {
    create?: XOR<VolumeDiscountCreateWithoutTierInput, VolumeDiscountUncheckedCreateWithoutTierInput> | VolumeDiscountCreateWithoutTierInput[] | VolumeDiscountUncheckedCreateWithoutTierInput[]
    connectOrCreate?: VolumeDiscountCreateOrConnectWithoutTierInput | VolumeDiscountCreateOrConnectWithoutTierInput[]
    createMany?: VolumeDiscountCreateManyTierInputEnvelope
    connect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
  }

  export type VolumeDiscountUpdateManyWithoutTierNestedInput = {
    create?: XOR<VolumeDiscountCreateWithoutTierInput, VolumeDiscountUncheckedCreateWithoutTierInput> | VolumeDiscountCreateWithoutTierInput[] | VolumeDiscountUncheckedCreateWithoutTierInput[]
    connectOrCreate?: VolumeDiscountCreateOrConnectWithoutTierInput | VolumeDiscountCreateOrConnectWithoutTierInput[]
    upsert?: VolumeDiscountUpsertWithWhereUniqueWithoutTierInput | VolumeDiscountUpsertWithWhereUniqueWithoutTierInput[]
    createMany?: VolumeDiscountCreateManyTierInputEnvelope
    set?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    disconnect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    delete?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    connect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    update?: VolumeDiscountUpdateWithWhereUniqueWithoutTierInput | VolumeDiscountUpdateWithWhereUniqueWithoutTierInput[]
    updateMany?: VolumeDiscountUpdateManyWithWhereWithoutTierInput | VolumeDiscountUpdateManyWithWhereWithoutTierInput[]
    deleteMany?: VolumeDiscountScalarWhereInput | VolumeDiscountScalarWhereInput[]
  }

  export type VolumeDiscountUncheckedUpdateManyWithoutTierNestedInput = {
    create?: XOR<VolumeDiscountCreateWithoutTierInput, VolumeDiscountUncheckedCreateWithoutTierInput> | VolumeDiscountCreateWithoutTierInput[] | VolumeDiscountUncheckedCreateWithoutTierInput[]
    connectOrCreate?: VolumeDiscountCreateOrConnectWithoutTierInput | VolumeDiscountCreateOrConnectWithoutTierInput[]
    upsert?: VolumeDiscountUpsertWithWhereUniqueWithoutTierInput | VolumeDiscountUpsertWithWhereUniqueWithoutTierInput[]
    createMany?: VolumeDiscountCreateManyTierInputEnvelope
    set?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    disconnect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    delete?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    connect?: VolumeDiscountWhereUniqueInput | VolumeDiscountWhereUniqueInput[]
    update?: VolumeDiscountUpdateWithWhereUniqueWithoutTierInput | VolumeDiscountUpdateWithWhereUniqueWithoutTierInput[]
    updateMany?: VolumeDiscountUpdateManyWithWhereWithoutTierInput | VolumeDiscountUpdateManyWithWhereWithoutTierInput[]
    deleteMany?: VolumeDiscountScalarWhereInput | VolumeDiscountScalarWhereInput[]
  }

  export type PrintSizeCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<PrintSizeCreateWithoutDiscountsInput, PrintSizeUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: PrintSizeCreateOrConnectWithoutDiscountsInput
    connect?: PrintSizeWhereUniqueInput
  }

  export type QuantityTierCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<QuantityTierCreateWithoutDiscountsInput, QuantityTierUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: QuantityTierCreateOrConnectWithoutDiscountsInput
    connect?: QuantityTierWhereUniqueInput
  }

  export type PrintSizeUpdateOneRequiredWithoutDiscountsNestedInput = {
    create?: XOR<PrintSizeCreateWithoutDiscountsInput, PrintSizeUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: PrintSizeCreateOrConnectWithoutDiscountsInput
    upsert?: PrintSizeUpsertWithoutDiscountsInput
    connect?: PrintSizeWhereUniqueInput
    update?: XOR<XOR<PrintSizeUpdateToOneWithWhereWithoutDiscountsInput, PrintSizeUpdateWithoutDiscountsInput>, PrintSizeUncheckedUpdateWithoutDiscountsInput>
  }

  export type QuantityTierUpdateOneWithoutDiscountsNestedInput = {
    create?: XOR<QuantityTierCreateWithoutDiscountsInput, QuantityTierUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: QuantityTierCreateOrConnectWithoutDiscountsInput
    upsert?: QuantityTierUpsertWithoutDiscountsInput
    disconnect?: QuantityTierWhereInput | boolean
    delete?: QuantityTierWhereInput | boolean
    connect?: QuantityTierWhereUniqueInput
    update?: XOR<XOR<QuantityTierUpdateToOneWithWhereWithoutDiscountsInput, QuantityTierUpdateWithoutDiscountsInput>, QuantityTierUncheckedUpdateWithoutDiscountsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HelpCategoryTranslationCreateNestedManyWithoutHelpCategoryInput = {
    create?: XOR<HelpCategoryTranslationCreateWithoutHelpCategoryInput, HelpCategoryTranslationUncheckedCreateWithoutHelpCategoryInput> | HelpCategoryTranslationCreateWithoutHelpCategoryInput[] | HelpCategoryTranslationUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: HelpCategoryTranslationCreateOrConnectWithoutHelpCategoryInput | HelpCategoryTranslationCreateOrConnectWithoutHelpCategoryInput[]
    createMany?: HelpCategoryTranslationCreateManyHelpCategoryInputEnvelope
    connect?: HelpCategoryTranslationWhereUniqueInput | HelpCategoryTranslationWhereUniqueInput[]
  }

  export type HelpArticleCreateNestedManyWithoutHelpCategoryInput = {
    create?: XOR<HelpArticleCreateWithoutHelpCategoryInput, HelpArticleUncheckedCreateWithoutHelpCategoryInput> | HelpArticleCreateWithoutHelpCategoryInput[] | HelpArticleUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutHelpCategoryInput | HelpArticleCreateOrConnectWithoutHelpCategoryInput[]
    createMany?: HelpArticleCreateManyHelpCategoryInputEnvelope
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
  }

  export type HelpCategoryTranslationUncheckedCreateNestedManyWithoutHelpCategoryInput = {
    create?: XOR<HelpCategoryTranslationCreateWithoutHelpCategoryInput, HelpCategoryTranslationUncheckedCreateWithoutHelpCategoryInput> | HelpCategoryTranslationCreateWithoutHelpCategoryInput[] | HelpCategoryTranslationUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: HelpCategoryTranslationCreateOrConnectWithoutHelpCategoryInput | HelpCategoryTranslationCreateOrConnectWithoutHelpCategoryInput[]
    createMany?: HelpCategoryTranslationCreateManyHelpCategoryInputEnvelope
    connect?: HelpCategoryTranslationWhereUniqueInput | HelpCategoryTranslationWhereUniqueInput[]
  }

  export type HelpArticleUncheckedCreateNestedManyWithoutHelpCategoryInput = {
    create?: XOR<HelpArticleCreateWithoutHelpCategoryInput, HelpArticleUncheckedCreateWithoutHelpCategoryInput> | HelpArticleCreateWithoutHelpCategoryInput[] | HelpArticleUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutHelpCategoryInput | HelpArticleCreateOrConnectWithoutHelpCategoryInput[]
    createMany?: HelpArticleCreateManyHelpCategoryInputEnvelope
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
  }

  export type HelpCategoryTranslationUpdateManyWithoutHelpCategoryNestedInput = {
    create?: XOR<HelpCategoryTranslationCreateWithoutHelpCategoryInput, HelpCategoryTranslationUncheckedCreateWithoutHelpCategoryInput> | HelpCategoryTranslationCreateWithoutHelpCategoryInput[] | HelpCategoryTranslationUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: HelpCategoryTranslationCreateOrConnectWithoutHelpCategoryInput | HelpCategoryTranslationCreateOrConnectWithoutHelpCategoryInput[]
    upsert?: HelpCategoryTranslationUpsertWithWhereUniqueWithoutHelpCategoryInput | HelpCategoryTranslationUpsertWithWhereUniqueWithoutHelpCategoryInput[]
    createMany?: HelpCategoryTranslationCreateManyHelpCategoryInputEnvelope
    set?: HelpCategoryTranslationWhereUniqueInput | HelpCategoryTranslationWhereUniqueInput[]
    disconnect?: HelpCategoryTranslationWhereUniqueInput | HelpCategoryTranslationWhereUniqueInput[]
    delete?: HelpCategoryTranslationWhereUniqueInput | HelpCategoryTranslationWhereUniqueInput[]
    connect?: HelpCategoryTranslationWhereUniqueInput | HelpCategoryTranslationWhereUniqueInput[]
    update?: HelpCategoryTranslationUpdateWithWhereUniqueWithoutHelpCategoryInput | HelpCategoryTranslationUpdateWithWhereUniqueWithoutHelpCategoryInput[]
    updateMany?: HelpCategoryTranslationUpdateManyWithWhereWithoutHelpCategoryInput | HelpCategoryTranslationUpdateManyWithWhereWithoutHelpCategoryInput[]
    deleteMany?: HelpCategoryTranslationScalarWhereInput | HelpCategoryTranslationScalarWhereInput[]
  }

  export type HelpArticleUpdateManyWithoutHelpCategoryNestedInput = {
    create?: XOR<HelpArticleCreateWithoutHelpCategoryInput, HelpArticleUncheckedCreateWithoutHelpCategoryInput> | HelpArticleCreateWithoutHelpCategoryInput[] | HelpArticleUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutHelpCategoryInput | HelpArticleCreateOrConnectWithoutHelpCategoryInput[]
    upsert?: HelpArticleUpsertWithWhereUniqueWithoutHelpCategoryInput | HelpArticleUpsertWithWhereUniqueWithoutHelpCategoryInput[]
    createMany?: HelpArticleCreateManyHelpCategoryInputEnvelope
    set?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    disconnect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    delete?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    update?: HelpArticleUpdateWithWhereUniqueWithoutHelpCategoryInput | HelpArticleUpdateWithWhereUniqueWithoutHelpCategoryInput[]
    updateMany?: HelpArticleUpdateManyWithWhereWithoutHelpCategoryInput | HelpArticleUpdateManyWithWhereWithoutHelpCategoryInput[]
    deleteMany?: HelpArticleScalarWhereInput | HelpArticleScalarWhereInput[]
  }

  export type HelpCategoryTranslationUncheckedUpdateManyWithoutHelpCategoryNestedInput = {
    create?: XOR<HelpCategoryTranslationCreateWithoutHelpCategoryInput, HelpCategoryTranslationUncheckedCreateWithoutHelpCategoryInput> | HelpCategoryTranslationCreateWithoutHelpCategoryInput[] | HelpCategoryTranslationUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: HelpCategoryTranslationCreateOrConnectWithoutHelpCategoryInput | HelpCategoryTranslationCreateOrConnectWithoutHelpCategoryInput[]
    upsert?: HelpCategoryTranslationUpsertWithWhereUniqueWithoutHelpCategoryInput | HelpCategoryTranslationUpsertWithWhereUniqueWithoutHelpCategoryInput[]
    createMany?: HelpCategoryTranslationCreateManyHelpCategoryInputEnvelope
    set?: HelpCategoryTranslationWhereUniqueInput | HelpCategoryTranslationWhereUniqueInput[]
    disconnect?: HelpCategoryTranslationWhereUniqueInput | HelpCategoryTranslationWhereUniqueInput[]
    delete?: HelpCategoryTranslationWhereUniqueInput | HelpCategoryTranslationWhereUniqueInput[]
    connect?: HelpCategoryTranslationWhereUniqueInput | HelpCategoryTranslationWhereUniqueInput[]
    update?: HelpCategoryTranslationUpdateWithWhereUniqueWithoutHelpCategoryInput | HelpCategoryTranslationUpdateWithWhereUniqueWithoutHelpCategoryInput[]
    updateMany?: HelpCategoryTranslationUpdateManyWithWhereWithoutHelpCategoryInput | HelpCategoryTranslationUpdateManyWithWhereWithoutHelpCategoryInput[]
    deleteMany?: HelpCategoryTranslationScalarWhereInput | HelpCategoryTranslationScalarWhereInput[]
  }

  export type HelpArticleUncheckedUpdateManyWithoutHelpCategoryNestedInput = {
    create?: XOR<HelpArticleCreateWithoutHelpCategoryInput, HelpArticleUncheckedCreateWithoutHelpCategoryInput> | HelpArticleCreateWithoutHelpCategoryInput[] | HelpArticleUncheckedCreateWithoutHelpCategoryInput[]
    connectOrCreate?: HelpArticleCreateOrConnectWithoutHelpCategoryInput | HelpArticleCreateOrConnectWithoutHelpCategoryInput[]
    upsert?: HelpArticleUpsertWithWhereUniqueWithoutHelpCategoryInput | HelpArticleUpsertWithWhereUniqueWithoutHelpCategoryInput[]
    createMany?: HelpArticleCreateManyHelpCategoryInputEnvelope
    set?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    disconnect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    delete?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    connect?: HelpArticleWhereUniqueInput | HelpArticleWhereUniqueInput[]
    update?: HelpArticleUpdateWithWhereUniqueWithoutHelpCategoryInput | HelpArticleUpdateWithWhereUniqueWithoutHelpCategoryInput[]
    updateMany?: HelpArticleUpdateManyWithWhereWithoutHelpCategoryInput | HelpArticleUpdateManyWithWhereWithoutHelpCategoryInput[]
    deleteMany?: HelpArticleScalarWhereInput | HelpArticleScalarWhereInput[]
  }

  export type HelpCategoryCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<HelpCategoryCreateWithoutTranslationsInput, HelpCategoryUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: HelpCategoryCreateOrConnectWithoutTranslationsInput
    connect?: HelpCategoryWhereUniqueInput
  }

  export type HelpCategoryUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<HelpCategoryCreateWithoutTranslationsInput, HelpCategoryUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: HelpCategoryCreateOrConnectWithoutTranslationsInput
    upsert?: HelpCategoryUpsertWithoutTranslationsInput
    connect?: HelpCategoryWhereUniqueInput
    update?: XOR<XOR<HelpCategoryUpdateToOneWithWhereWithoutTranslationsInput, HelpCategoryUpdateWithoutTranslationsInput>, HelpCategoryUncheckedUpdateWithoutTranslationsInput>
  }

  export type HelpCategoryCreateNestedOneWithoutArticlesInput = {
    create?: XOR<HelpCategoryCreateWithoutArticlesInput, HelpCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: HelpCategoryCreateOrConnectWithoutArticlesInput
    connect?: HelpCategoryWhereUniqueInput
  }

  export type HelpArticleTranslationCreateNestedManyWithoutHelpArticleInput = {
    create?: XOR<HelpArticleTranslationCreateWithoutHelpArticleInput, HelpArticleTranslationUncheckedCreateWithoutHelpArticleInput> | HelpArticleTranslationCreateWithoutHelpArticleInput[] | HelpArticleTranslationUncheckedCreateWithoutHelpArticleInput[]
    connectOrCreate?: HelpArticleTranslationCreateOrConnectWithoutHelpArticleInput | HelpArticleTranslationCreateOrConnectWithoutHelpArticleInput[]
    createMany?: HelpArticleTranslationCreateManyHelpArticleInputEnvelope
    connect?: HelpArticleTranslationWhereUniqueInput | HelpArticleTranslationWhereUniqueInput[]
  }

  export type HelpArticleTranslationUncheckedCreateNestedManyWithoutHelpArticleInput = {
    create?: XOR<HelpArticleTranslationCreateWithoutHelpArticleInput, HelpArticleTranslationUncheckedCreateWithoutHelpArticleInput> | HelpArticleTranslationCreateWithoutHelpArticleInput[] | HelpArticleTranslationUncheckedCreateWithoutHelpArticleInput[]
    connectOrCreate?: HelpArticleTranslationCreateOrConnectWithoutHelpArticleInput | HelpArticleTranslationCreateOrConnectWithoutHelpArticleInput[]
    createMany?: HelpArticleTranslationCreateManyHelpArticleInputEnvelope
    connect?: HelpArticleTranslationWhereUniqueInput | HelpArticleTranslationWhereUniqueInput[]
  }

  export type HelpCategoryUpdateOneRequiredWithoutArticlesNestedInput = {
    create?: XOR<HelpCategoryCreateWithoutArticlesInput, HelpCategoryUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: HelpCategoryCreateOrConnectWithoutArticlesInput
    upsert?: HelpCategoryUpsertWithoutArticlesInput
    connect?: HelpCategoryWhereUniqueInput
    update?: XOR<XOR<HelpCategoryUpdateToOneWithWhereWithoutArticlesInput, HelpCategoryUpdateWithoutArticlesInput>, HelpCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type HelpArticleTranslationUpdateManyWithoutHelpArticleNestedInput = {
    create?: XOR<HelpArticleTranslationCreateWithoutHelpArticleInput, HelpArticleTranslationUncheckedCreateWithoutHelpArticleInput> | HelpArticleTranslationCreateWithoutHelpArticleInput[] | HelpArticleTranslationUncheckedCreateWithoutHelpArticleInput[]
    connectOrCreate?: HelpArticleTranslationCreateOrConnectWithoutHelpArticleInput | HelpArticleTranslationCreateOrConnectWithoutHelpArticleInput[]
    upsert?: HelpArticleTranslationUpsertWithWhereUniqueWithoutHelpArticleInput | HelpArticleTranslationUpsertWithWhereUniqueWithoutHelpArticleInput[]
    createMany?: HelpArticleTranslationCreateManyHelpArticleInputEnvelope
    set?: HelpArticleTranslationWhereUniqueInput | HelpArticleTranslationWhereUniqueInput[]
    disconnect?: HelpArticleTranslationWhereUniqueInput | HelpArticleTranslationWhereUniqueInput[]
    delete?: HelpArticleTranslationWhereUniqueInput | HelpArticleTranslationWhereUniqueInput[]
    connect?: HelpArticleTranslationWhereUniqueInput | HelpArticleTranslationWhereUniqueInput[]
    update?: HelpArticleTranslationUpdateWithWhereUniqueWithoutHelpArticleInput | HelpArticleTranslationUpdateWithWhereUniqueWithoutHelpArticleInput[]
    updateMany?: HelpArticleTranslationUpdateManyWithWhereWithoutHelpArticleInput | HelpArticleTranslationUpdateManyWithWhereWithoutHelpArticleInput[]
    deleteMany?: HelpArticleTranslationScalarWhereInput | HelpArticleTranslationScalarWhereInput[]
  }

  export type HelpArticleTranslationUncheckedUpdateManyWithoutHelpArticleNestedInput = {
    create?: XOR<HelpArticleTranslationCreateWithoutHelpArticleInput, HelpArticleTranslationUncheckedCreateWithoutHelpArticleInput> | HelpArticleTranslationCreateWithoutHelpArticleInput[] | HelpArticleTranslationUncheckedCreateWithoutHelpArticleInput[]
    connectOrCreate?: HelpArticleTranslationCreateOrConnectWithoutHelpArticleInput | HelpArticleTranslationCreateOrConnectWithoutHelpArticleInput[]
    upsert?: HelpArticleTranslationUpsertWithWhereUniqueWithoutHelpArticleInput | HelpArticleTranslationUpsertWithWhereUniqueWithoutHelpArticleInput[]
    createMany?: HelpArticleTranslationCreateManyHelpArticleInputEnvelope
    set?: HelpArticleTranslationWhereUniqueInput | HelpArticleTranslationWhereUniqueInput[]
    disconnect?: HelpArticleTranslationWhereUniqueInput | HelpArticleTranslationWhereUniqueInput[]
    delete?: HelpArticleTranslationWhereUniqueInput | HelpArticleTranslationWhereUniqueInput[]
    connect?: HelpArticleTranslationWhereUniqueInput | HelpArticleTranslationWhereUniqueInput[]
    update?: HelpArticleTranslationUpdateWithWhereUniqueWithoutHelpArticleInput | HelpArticleTranslationUpdateWithWhereUniqueWithoutHelpArticleInput[]
    updateMany?: HelpArticleTranslationUpdateManyWithWhereWithoutHelpArticleInput | HelpArticleTranslationUpdateManyWithWhereWithoutHelpArticleInput[]
    deleteMany?: HelpArticleTranslationScalarWhereInput | HelpArticleTranslationScalarWhereInput[]
  }

  export type HelpArticleCreateNestedOneWithoutTranslationsInput = {
    create?: XOR<HelpArticleCreateWithoutTranslationsInput, HelpArticleUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: HelpArticleCreateOrConnectWithoutTranslationsInput
    connect?: HelpArticleWhereUniqueInput
  }

  export type HelpArticleUpdateOneRequiredWithoutTranslationsNestedInput = {
    create?: XOR<HelpArticleCreateWithoutTranslationsInput, HelpArticleUncheckedCreateWithoutTranslationsInput>
    connectOrCreate?: HelpArticleCreateOrConnectWithoutTranslationsInput
    upsert?: HelpArticleUpsertWithoutTranslationsInput
    connect?: HelpArticleWhereUniqueInput
    update?: XOR<XOR<HelpArticleUpdateToOneWithWhereWithoutTranslationsInput, HelpArticleUpdateWithoutTranslationsInput>, HelpArticleUncheckedUpdateWithoutTranslationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OrderItemCreateWithoutOrderInput = {
    type: string
    name: string
    quantity: number
    price: number
    subtotal: number
    size?: string | null
    paper?: string | null
    options?: string | null
    files?: string | null
    createdAt?: Date | string
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    type: string
    name: string
    quantity: number
    price: number
    subtotal: number
    size?: string | null
    paper?: string | null
    options?: string | null
    files?: string | null
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    type?: StringFilter<"OrderItem"> | string
    name?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    price?: FloatFilter<"OrderItem"> | number
    subtotal?: FloatFilter<"OrderItem"> | number
    size?: StringNullableFilter<"OrderItem"> | string | null
    paper?: StringNullableFilter<"OrderItem"> | string | null
    options?: StringNullableFilter<"OrderItem"> | string | null
    files?: StringNullableFilter<"OrderItem"> | string | null
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type OrderCreateWithoutItemsInput = {
    orderNumber: string
    status?: string
    totalAmount?: number
    customerName?: string | null
    customerFirstName?: string | null
    customerLastName?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    deliveryAddress?: string | null
    deliveryMethod?: string
    recipientCityRef?: string | null
    recipientWarehouseRef?: string | null
    ttnNumber?: string | null
    ttnRef?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: number
    orderNumber: string
    status?: string
    totalAmount?: number
    customerName?: string | null
    customerFirstName?: string | null
    customerLastName?: string | null
    customerPhone?: string | null
    customerEmail?: string | null
    deliveryAddress?: string | null
    deliveryMethod?: string
    recipientCityRef?: string | null
    recipientWarehouseRef?: string | null
    ttnNumber?: string | null
    ttnRef?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLastName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: StringFieldUpdateOperationsInput | string
    recipientCityRef?: NullableStringFieldUpdateOperationsInput | string | null
    recipientWarehouseRef?: NullableStringFieldUpdateOperationsInput | string | null
    ttnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ttnRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    customerLastName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryMethod?: StringFieldUpdateOperationsInput | string
    recipientCityRef?: NullableStringFieldUpdateOperationsInput | string | null
    recipientWarehouseRef?: NullableStringFieldUpdateOperationsInput | string | null
    ttnNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ttnRef?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VolumeDiscountCreateWithoutPrintSizeInput = {
    minQuantity: number
    price: number
    tier?: QuantityTierCreateNestedOneWithoutDiscountsInput
  }

  export type VolumeDiscountUncheckedCreateWithoutPrintSizeInput = {
    id?: number
    tierId?: number | null
    minQuantity: number
    price: number
  }

  export type VolumeDiscountCreateOrConnectWithoutPrintSizeInput = {
    where: VolumeDiscountWhereUniqueInput
    create: XOR<VolumeDiscountCreateWithoutPrintSizeInput, VolumeDiscountUncheckedCreateWithoutPrintSizeInput>
  }

  export type VolumeDiscountCreateManyPrintSizeInputEnvelope = {
    data: VolumeDiscountCreateManyPrintSizeInput | VolumeDiscountCreateManyPrintSizeInput[]
  }

  export type VolumeDiscountUpsertWithWhereUniqueWithoutPrintSizeInput = {
    where: VolumeDiscountWhereUniqueInput
    update: XOR<VolumeDiscountUpdateWithoutPrintSizeInput, VolumeDiscountUncheckedUpdateWithoutPrintSizeInput>
    create: XOR<VolumeDiscountCreateWithoutPrintSizeInput, VolumeDiscountUncheckedCreateWithoutPrintSizeInput>
  }

  export type VolumeDiscountUpdateWithWhereUniqueWithoutPrintSizeInput = {
    where: VolumeDiscountWhereUniqueInput
    data: XOR<VolumeDiscountUpdateWithoutPrintSizeInput, VolumeDiscountUncheckedUpdateWithoutPrintSizeInput>
  }

  export type VolumeDiscountUpdateManyWithWhereWithoutPrintSizeInput = {
    where: VolumeDiscountScalarWhereInput
    data: XOR<VolumeDiscountUpdateManyMutationInput, VolumeDiscountUncheckedUpdateManyWithoutPrintSizeInput>
  }

  export type VolumeDiscountScalarWhereInput = {
    AND?: VolumeDiscountScalarWhereInput | VolumeDiscountScalarWhereInput[]
    OR?: VolumeDiscountScalarWhereInput[]
    NOT?: VolumeDiscountScalarWhereInput | VolumeDiscountScalarWhereInput[]
    id?: IntFilter<"VolumeDiscount"> | number
    printSizeId?: IntFilter<"VolumeDiscount"> | number
    tierId?: IntNullableFilter<"VolumeDiscount"> | number | null
    minQuantity?: IntFilter<"VolumeDiscount"> | number
    price?: FloatFilter<"VolumeDiscount"> | number
  }

  export type VolumeDiscountCreateWithoutTierInput = {
    minQuantity: number
    price: number
    printSize: PrintSizeCreateNestedOneWithoutDiscountsInput
  }

  export type VolumeDiscountUncheckedCreateWithoutTierInput = {
    id?: number
    printSizeId: number
    minQuantity: number
    price: number
  }

  export type VolumeDiscountCreateOrConnectWithoutTierInput = {
    where: VolumeDiscountWhereUniqueInput
    create: XOR<VolumeDiscountCreateWithoutTierInput, VolumeDiscountUncheckedCreateWithoutTierInput>
  }

  export type VolumeDiscountCreateManyTierInputEnvelope = {
    data: VolumeDiscountCreateManyTierInput | VolumeDiscountCreateManyTierInput[]
  }

  export type VolumeDiscountUpsertWithWhereUniqueWithoutTierInput = {
    where: VolumeDiscountWhereUniqueInput
    update: XOR<VolumeDiscountUpdateWithoutTierInput, VolumeDiscountUncheckedUpdateWithoutTierInput>
    create: XOR<VolumeDiscountCreateWithoutTierInput, VolumeDiscountUncheckedCreateWithoutTierInput>
  }

  export type VolumeDiscountUpdateWithWhereUniqueWithoutTierInput = {
    where: VolumeDiscountWhereUniqueInput
    data: XOR<VolumeDiscountUpdateWithoutTierInput, VolumeDiscountUncheckedUpdateWithoutTierInput>
  }

  export type VolumeDiscountUpdateManyWithWhereWithoutTierInput = {
    where: VolumeDiscountScalarWhereInput
    data: XOR<VolumeDiscountUpdateManyMutationInput, VolumeDiscountUncheckedUpdateManyWithoutTierInput>
  }

  export type PrintSizeCreateWithoutDiscountsInput = {
    name: string
    slug: string
    widthMm?: number | null
    heightMm?: number | null
    basePrice: number
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PrintSizeUncheckedCreateWithoutDiscountsInput = {
    id?: number
    name: string
    slug: string
    widthMm?: number | null
    heightMm?: number | null
    basePrice: number
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PrintSizeCreateOrConnectWithoutDiscountsInput = {
    where: PrintSizeWhereUniqueInput
    create: XOR<PrintSizeCreateWithoutDiscountsInput, PrintSizeUncheckedCreateWithoutDiscountsInput>
  }

  export type QuantityTierCreateWithoutDiscountsInput = {
    label: string
    minQuantity: number
    sortOrder?: number
    isActive?: boolean
  }

  export type QuantityTierUncheckedCreateWithoutDiscountsInput = {
    id?: number
    label: string
    minQuantity: number
    sortOrder?: number
    isActive?: boolean
  }

  export type QuantityTierCreateOrConnectWithoutDiscountsInput = {
    where: QuantityTierWhereUniqueInput
    create: XOR<QuantityTierCreateWithoutDiscountsInput, QuantityTierUncheckedCreateWithoutDiscountsInput>
  }

  export type PrintSizeUpsertWithoutDiscountsInput = {
    update: XOR<PrintSizeUpdateWithoutDiscountsInput, PrintSizeUncheckedUpdateWithoutDiscountsInput>
    create: XOR<PrintSizeCreateWithoutDiscountsInput, PrintSizeUncheckedCreateWithoutDiscountsInput>
    where?: PrintSizeWhereInput
  }

  export type PrintSizeUpdateToOneWithWhereWithoutDiscountsInput = {
    where?: PrintSizeWhereInput
    data: XOR<PrintSizeUpdateWithoutDiscountsInput, PrintSizeUncheckedUpdateWithoutDiscountsInput>
  }

  export type PrintSizeUpdateWithoutDiscountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    widthMm?: NullableFloatFieldUpdateOperationsInput | number | null
    heightMm?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrintSizeUncheckedUpdateWithoutDiscountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    widthMm?: NullableFloatFieldUpdateOperationsInput | number | null
    heightMm?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuantityTierUpsertWithoutDiscountsInput = {
    update: XOR<QuantityTierUpdateWithoutDiscountsInput, QuantityTierUncheckedUpdateWithoutDiscountsInput>
    create: XOR<QuantityTierCreateWithoutDiscountsInput, QuantityTierUncheckedCreateWithoutDiscountsInput>
    where?: QuantityTierWhereInput
  }

  export type QuantityTierUpdateToOneWithWhereWithoutDiscountsInput = {
    where?: QuantityTierWhereInput
    data: XOR<QuantityTierUpdateWithoutDiscountsInput, QuantityTierUncheckedUpdateWithoutDiscountsInput>
  }

  export type QuantityTierUpdateWithoutDiscountsInput = {
    label?: StringFieldUpdateOperationsInput | string
    minQuantity?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type QuantityTierUncheckedUpdateWithoutDiscountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    minQuantity?: IntFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HelpCategoryTranslationCreateWithoutHelpCategoryInput = {
    lang: string
    name: string
  }

  export type HelpCategoryTranslationUncheckedCreateWithoutHelpCategoryInput = {
    id?: number
    lang: string
    name: string
  }

  export type HelpCategoryTranslationCreateOrConnectWithoutHelpCategoryInput = {
    where: HelpCategoryTranslationWhereUniqueInput
    create: XOR<HelpCategoryTranslationCreateWithoutHelpCategoryInput, HelpCategoryTranslationUncheckedCreateWithoutHelpCategoryInput>
  }

  export type HelpCategoryTranslationCreateManyHelpCategoryInputEnvelope = {
    data: HelpCategoryTranslationCreateManyHelpCategoryInput | HelpCategoryTranslationCreateManyHelpCategoryInput[]
  }

  export type HelpArticleCreateWithoutHelpCategoryInput = {
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: HelpArticleTranslationCreateNestedManyWithoutHelpArticleInput
  }

  export type HelpArticleUncheckedCreateWithoutHelpCategoryInput = {
    id?: number
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: HelpArticleTranslationUncheckedCreateNestedManyWithoutHelpArticleInput
  }

  export type HelpArticleCreateOrConnectWithoutHelpCategoryInput = {
    where: HelpArticleWhereUniqueInput
    create: XOR<HelpArticleCreateWithoutHelpCategoryInput, HelpArticleUncheckedCreateWithoutHelpCategoryInput>
  }

  export type HelpArticleCreateManyHelpCategoryInputEnvelope = {
    data: HelpArticleCreateManyHelpCategoryInput | HelpArticleCreateManyHelpCategoryInput[]
  }

  export type HelpCategoryTranslationUpsertWithWhereUniqueWithoutHelpCategoryInput = {
    where: HelpCategoryTranslationWhereUniqueInput
    update: XOR<HelpCategoryTranslationUpdateWithoutHelpCategoryInput, HelpCategoryTranslationUncheckedUpdateWithoutHelpCategoryInput>
    create: XOR<HelpCategoryTranslationCreateWithoutHelpCategoryInput, HelpCategoryTranslationUncheckedCreateWithoutHelpCategoryInput>
  }

  export type HelpCategoryTranslationUpdateWithWhereUniqueWithoutHelpCategoryInput = {
    where: HelpCategoryTranslationWhereUniqueInput
    data: XOR<HelpCategoryTranslationUpdateWithoutHelpCategoryInput, HelpCategoryTranslationUncheckedUpdateWithoutHelpCategoryInput>
  }

  export type HelpCategoryTranslationUpdateManyWithWhereWithoutHelpCategoryInput = {
    where: HelpCategoryTranslationScalarWhereInput
    data: XOR<HelpCategoryTranslationUpdateManyMutationInput, HelpCategoryTranslationUncheckedUpdateManyWithoutHelpCategoryInput>
  }

  export type HelpCategoryTranslationScalarWhereInput = {
    AND?: HelpCategoryTranslationScalarWhereInput | HelpCategoryTranslationScalarWhereInput[]
    OR?: HelpCategoryTranslationScalarWhereInput[]
    NOT?: HelpCategoryTranslationScalarWhereInput | HelpCategoryTranslationScalarWhereInput[]
    id?: IntFilter<"HelpCategoryTranslation"> | number
    helpCategoryId?: IntFilter<"HelpCategoryTranslation"> | number
    lang?: StringFilter<"HelpCategoryTranslation"> | string
    name?: StringFilter<"HelpCategoryTranslation"> | string
  }

  export type HelpArticleUpsertWithWhereUniqueWithoutHelpCategoryInput = {
    where: HelpArticleWhereUniqueInput
    update: XOR<HelpArticleUpdateWithoutHelpCategoryInput, HelpArticleUncheckedUpdateWithoutHelpCategoryInput>
    create: XOR<HelpArticleCreateWithoutHelpCategoryInput, HelpArticleUncheckedCreateWithoutHelpCategoryInput>
  }

  export type HelpArticleUpdateWithWhereUniqueWithoutHelpCategoryInput = {
    where: HelpArticleWhereUniqueInput
    data: XOR<HelpArticleUpdateWithoutHelpCategoryInput, HelpArticleUncheckedUpdateWithoutHelpCategoryInput>
  }

  export type HelpArticleUpdateManyWithWhereWithoutHelpCategoryInput = {
    where: HelpArticleScalarWhereInput
    data: XOR<HelpArticleUpdateManyMutationInput, HelpArticleUncheckedUpdateManyWithoutHelpCategoryInput>
  }

  export type HelpArticleScalarWhereInput = {
    AND?: HelpArticleScalarWhereInput | HelpArticleScalarWhereInput[]
    OR?: HelpArticleScalarWhereInput[]
    NOT?: HelpArticleScalarWhereInput | HelpArticleScalarWhereInput[]
    id?: IntFilter<"HelpArticle"> | number
    helpCategoryId?: IntFilter<"HelpArticle"> | number
    slug?: StringFilter<"HelpArticle"> | string
    sortOrder?: IntFilter<"HelpArticle"> | number
    isActive?: BoolFilter<"HelpArticle"> | boolean
    createdAt?: DateTimeFilter<"HelpArticle"> | Date | string
    updatedAt?: DateTimeFilter<"HelpArticle"> | Date | string
  }

  export type HelpCategoryCreateWithoutTranslationsInput = {
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: HelpArticleCreateNestedManyWithoutHelpCategoryInput
  }

  export type HelpCategoryUncheckedCreateWithoutTranslationsInput = {
    id?: number
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    articles?: HelpArticleUncheckedCreateNestedManyWithoutHelpCategoryInput
  }

  export type HelpCategoryCreateOrConnectWithoutTranslationsInput = {
    where: HelpCategoryWhereUniqueInput
    create: XOR<HelpCategoryCreateWithoutTranslationsInput, HelpCategoryUncheckedCreateWithoutTranslationsInput>
  }

  export type HelpCategoryUpsertWithoutTranslationsInput = {
    update: XOR<HelpCategoryUpdateWithoutTranslationsInput, HelpCategoryUncheckedUpdateWithoutTranslationsInput>
    create: XOR<HelpCategoryCreateWithoutTranslationsInput, HelpCategoryUncheckedCreateWithoutTranslationsInput>
    where?: HelpCategoryWhereInput
  }

  export type HelpCategoryUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: HelpCategoryWhereInput
    data: XOR<HelpCategoryUpdateWithoutTranslationsInput, HelpCategoryUncheckedUpdateWithoutTranslationsInput>
  }

  export type HelpCategoryUpdateWithoutTranslationsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: HelpArticleUpdateManyWithoutHelpCategoryNestedInput
  }

  export type HelpCategoryUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    articles?: HelpArticleUncheckedUpdateManyWithoutHelpCategoryNestedInput
  }

  export type HelpCategoryCreateWithoutArticlesInput = {
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: HelpCategoryTranslationCreateNestedManyWithoutHelpCategoryInput
  }

  export type HelpCategoryUncheckedCreateWithoutArticlesInput = {
    id?: number
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    translations?: HelpCategoryTranslationUncheckedCreateNestedManyWithoutHelpCategoryInput
  }

  export type HelpCategoryCreateOrConnectWithoutArticlesInput = {
    where: HelpCategoryWhereUniqueInput
    create: XOR<HelpCategoryCreateWithoutArticlesInput, HelpCategoryUncheckedCreateWithoutArticlesInput>
  }

  export type HelpArticleTranslationCreateWithoutHelpArticleInput = {
    lang: string
    title: string
    content: string
  }

  export type HelpArticleTranslationUncheckedCreateWithoutHelpArticleInput = {
    id?: number
    lang: string
    title: string
    content: string
  }

  export type HelpArticleTranslationCreateOrConnectWithoutHelpArticleInput = {
    where: HelpArticleTranslationWhereUniqueInput
    create: XOR<HelpArticleTranslationCreateWithoutHelpArticleInput, HelpArticleTranslationUncheckedCreateWithoutHelpArticleInput>
  }

  export type HelpArticleTranslationCreateManyHelpArticleInputEnvelope = {
    data: HelpArticleTranslationCreateManyHelpArticleInput | HelpArticleTranslationCreateManyHelpArticleInput[]
  }

  export type HelpCategoryUpsertWithoutArticlesInput = {
    update: XOR<HelpCategoryUpdateWithoutArticlesInput, HelpCategoryUncheckedUpdateWithoutArticlesInput>
    create: XOR<HelpCategoryCreateWithoutArticlesInput, HelpCategoryUncheckedCreateWithoutArticlesInput>
    where?: HelpCategoryWhereInput
  }

  export type HelpCategoryUpdateToOneWithWhereWithoutArticlesInput = {
    where?: HelpCategoryWhereInput
    data: XOR<HelpCategoryUpdateWithoutArticlesInput, HelpCategoryUncheckedUpdateWithoutArticlesInput>
  }

  export type HelpCategoryUpdateWithoutArticlesInput = {
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: HelpCategoryTranslationUpdateManyWithoutHelpCategoryNestedInput
  }

  export type HelpCategoryUncheckedUpdateWithoutArticlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: HelpCategoryTranslationUncheckedUpdateManyWithoutHelpCategoryNestedInput
  }

  export type HelpArticleTranslationUpsertWithWhereUniqueWithoutHelpArticleInput = {
    where: HelpArticleTranslationWhereUniqueInput
    update: XOR<HelpArticleTranslationUpdateWithoutHelpArticleInput, HelpArticleTranslationUncheckedUpdateWithoutHelpArticleInput>
    create: XOR<HelpArticleTranslationCreateWithoutHelpArticleInput, HelpArticleTranslationUncheckedCreateWithoutHelpArticleInput>
  }

  export type HelpArticleTranslationUpdateWithWhereUniqueWithoutHelpArticleInput = {
    where: HelpArticleTranslationWhereUniqueInput
    data: XOR<HelpArticleTranslationUpdateWithoutHelpArticleInput, HelpArticleTranslationUncheckedUpdateWithoutHelpArticleInput>
  }

  export type HelpArticleTranslationUpdateManyWithWhereWithoutHelpArticleInput = {
    where: HelpArticleTranslationScalarWhereInput
    data: XOR<HelpArticleTranslationUpdateManyMutationInput, HelpArticleTranslationUncheckedUpdateManyWithoutHelpArticleInput>
  }

  export type HelpArticleTranslationScalarWhereInput = {
    AND?: HelpArticleTranslationScalarWhereInput | HelpArticleTranslationScalarWhereInput[]
    OR?: HelpArticleTranslationScalarWhereInput[]
    NOT?: HelpArticleTranslationScalarWhereInput | HelpArticleTranslationScalarWhereInput[]
    id?: IntFilter<"HelpArticleTranslation"> | number
    helpArticleId?: IntFilter<"HelpArticleTranslation"> | number
    lang?: StringFilter<"HelpArticleTranslation"> | string
    title?: StringFilter<"HelpArticleTranslation"> | string
    content?: StringFilter<"HelpArticleTranslation"> | string
  }

  export type HelpArticleCreateWithoutTranslationsInput = {
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    helpCategory: HelpCategoryCreateNestedOneWithoutArticlesInput
  }

  export type HelpArticleUncheckedCreateWithoutTranslationsInput = {
    id?: number
    helpCategoryId: number
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpArticleCreateOrConnectWithoutTranslationsInput = {
    where: HelpArticleWhereUniqueInput
    create: XOR<HelpArticleCreateWithoutTranslationsInput, HelpArticleUncheckedCreateWithoutTranslationsInput>
  }

  export type HelpArticleUpsertWithoutTranslationsInput = {
    update: XOR<HelpArticleUpdateWithoutTranslationsInput, HelpArticleUncheckedUpdateWithoutTranslationsInput>
    create: XOR<HelpArticleCreateWithoutTranslationsInput, HelpArticleUncheckedCreateWithoutTranslationsInput>
    where?: HelpArticleWhereInput
  }

  export type HelpArticleUpdateToOneWithWhereWithoutTranslationsInput = {
    where?: HelpArticleWhereInput
    data: XOR<HelpArticleUpdateWithoutTranslationsInput, HelpArticleUncheckedUpdateWithoutTranslationsInput>
  }

  export type HelpArticleUpdateWithoutTranslationsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    helpCategory?: HelpCategoryUpdateOneRequiredWithoutArticlesNestedInput
  }

  export type HelpArticleUncheckedUpdateWithoutTranslationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    helpCategoryId?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    type: string
    name: string
    quantity: number
    price: number
    subtotal: number
    size?: string | null
    paper?: string | null
    options?: string | null
    files?: string | null
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    paper?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableStringFieldUpdateOperationsInput | string | null
    files?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    paper?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableStringFieldUpdateOperationsInput | string | null
    files?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    size?: NullableStringFieldUpdateOperationsInput | string | null
    paper?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableStringFieldUpdateOperationsInput | string | null
    files?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VolumeDiscountCreateManyPrintSizeInput = {
    id?: number
    tierId?: number | null
    minQuantity: number
    price: number
  }

  export type VolumeDiscountUpdateWithoutPrintSizeInput = {
    minQuantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    tier?: QuantityTierUpdateOneWithoutDiscountsNestedInput
  }

  export type VolumeDiscountUncheckedUpdateWithoutPrintSizeInput = {
    id?: IntFieldUpdateOperationsInput | number
    tierId?: NullableIntFieldUpdateOperationsInput | number | null
    minQuantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type VolumeDiscountUncheckedUpdateManyWithoutPrintSizeInput = {
    id?: IntFieldUpdateOperationsInput | number
    tierId?: NullableIntFieldUpdateOperationsInput | number | null
    minQuantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type VolumeDiscountCreateManyTierInput = {
    id?: number
    printSizeId: number
    minQuantity: number
    price: number
  }

  export type VolumeDiscountUpdateWithoutTierInput = {
    minQuantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    printSize?: PrintSizeUpdateOneRequiredWithoutDiscountsNestedInput
  }

  export type VolumeDiscountUncheckedUpdateWithoutTierInput = {
    id?: IntFieldUpdateOperationsInput | number
    printSizeId?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type VolumeDiscountUncheckedUpdateManyWithoutTierInput = {
    id?: IntFieldUpdateOperationsInput | number
    printSizeId?: IntFieldUpdateOperationsInput | number
    minQuantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type HelpCategoryTranslationCreateManyHelpCategoryInput = {
    id?: number
    lang: string
    name: string
  }

  export type HelpArticleCreateManyHelpCategoryInput = {
    id?: number
    slug: string
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HelpCategoryTranslationUpdateWithoutHelpCategoryInput = {
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HelpCategoryTranslationUncheckedUpdateWithoutHelpCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HelpCategoryTranslationUncheckedUpdateManyWithoutHelpCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type HelpArticleUpdateWithoutHelpCategoryInput = {
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: HelpArticleTranslationUpdateManyWithoutHelpArticleNestedInput
  }

  export type HelpArticleUncheckedUpdateWithoutHelpCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    translations?: HelpArticleTranslationUncheckedUpdateManyWithoutHelpArticleNestedInput
  }

  export type HelpArticleUncheckedUpdateManyWithoutHelpCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HelpArticleTranslationCreateManyHelpArticleInput = {
    id?: number
    lang: string
    title: string
    content: string
  }

  export type HelpArticleTranslationUpdateWithoutHelpArticleInput = {
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type HelpArticleTranslationUncheckedUpdateWithoutHelpArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type HelpArticleTranslationUncheckedUpdateManyWithoutHelpArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrintSizeCountOutputTypeDefaultArgs instead
     */
    export type PrintSizeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrintSizeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuantityTierCountOutputTypeDefaultArgs instead
     */
    export type QuantityTierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuantityTierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpCategoryCountOutputTypeDefaultArgs instead
     */
    export type HelpCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpArticleCountOutputTypeDefaultArgs instead
     */
    export type HelpArticleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpArticleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrintSizeDefaultArgs instead
     */
    export type PrintSizeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrintSizeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuantityTierDefaultArgs instead
     */
    export type QuantityTierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuantityTierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VolumeDiscountDefaultArgs instead
     */
    export type VolumeDiscountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VolumeDiscountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GiftThresholdDefaultArgs instead
     */
    export type GiftThresholdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GiftThresholdDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaperTypeDefaultArgs instead
     */
    export type PaperTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaperTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrintOptionDefaultArgs instead
     */
    export type PrintOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrintOptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MagnetPriceDefaultArgs instead
     */
    export type MagnetPriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MagnetPriceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryOptionDefaultArgs instead
     */
    export type DeliveryOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeliveryOptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TranslationDefaultArgs instead
     */
    export type TranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingDefaultArgs instead
     */
    export type SettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PageDefaultArgs instead
     */
    export type PageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpCategoryDefaultArgs instead
     */
    export type HelpCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpCategoryTranslationDefaultArgs instead
     */
    export type HelpCategoryTranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpCategoryTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpArticleDefaultArgs instead
     */
    export type HelpArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HelpArticleTranslationDefaultArgs instead
     */
    export type HelpArticleTranslationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HelpArticleTranslationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderSequenceDefaultArgs instead
     */
    export type OrderSequenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderSequenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NPSenderDefaultArgs instead
     */
    export type NPSenderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NPSenderDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}